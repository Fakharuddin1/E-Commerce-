"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/block-tools/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@portabletext/block-tools/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockContentFeatures: () => (/* binding */ getBlockContentFeatures),\n/* harmony export */   htmlToBlocks: () => (/* binding */ htmlToBlocks),\n/* harmony export */   normalizeBlock: () => (/* binding */ normalizeBlock),\n/* harmony export */   randomKey: () => (/* binding */ randomKey)\n/* harmony export */ });\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n\n\n\n\n\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\";\n}\nconst objectToString = Object.prototype.toString;\nfunction resolveJsType(val) {\n  switch (objectToString.call(val)) {\n    case \"[object Function]\":\n      return \"function\";\n    case \"[object Date]\":\n      return \"date\";\n    case \"[object RegExp]\":\n      return \"regexp\";\n    case \"[object Arguments]\":\n      return \"arguments\";\n    case \"[object Array]\":\n      return \"array\";\n    case \"[object String]\":\n      return \"string\";\n  }\n  return val === null ? \"null\" : val === void 0 ? \"undefined\" : val && typeof val == \"object\" && \"nodeType\" in val && val.nodeType === 1 ? \"element\" : val === Object(val) ? \"object\" : typeof val;\n}\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };\nnew Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nconst PRESERVE_WHITESPACE_TAGS = [\"pre\", \"textarea\", \"code\"], BLOCK_DEFAULT_STYLE = \"normal\", DEFAULT_BLOCK = Object.freeze({\n  _type: \"block\",\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE\n}), DEFAULT_SPAN = Object.freeze({\n  _type: \"span\",\n  marks: []\n}), HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: { ...DEFAULT_BLOCK, style: \"blockquote\" }\n}, HTML_SPAN_TAGS = {\n  span: { object: \"text\" }\n}, HTML_LIST_CONTAINER_TAGS = {\n  ol: { object: null },\n  ul: { object: null }\n}, HTML_HEADER_TAGS = {\n  h1: { ...DEFAULT_BLOCK, style: \"h1\" },\n  h2: { ...DEFAULT_BLOCK, style: \"h2\" },\n  h3: { ...DEFAULT_BLOCK, style: \"h3\" },\n  h4: { ...DEFAULT_BLOCK, style: \"h4\" },\n  h5: { ...DEFAULT_BLOCK, style: \"h5\" },\n  h6: { ...DEFAULT_BLOCK, style: \"h6\" }\n}, HTML_MISC_TAGS = {\n  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }\n}, HTML_DECORATOR_TAGS = {\n  b: \"strong\",\n  strong: \"strong\",\n  i: \"em\",\n  em: \"em\",\n  u: \"underline\",\n  s: \"strike-through\",\n  strike: \"strike-through\",\n  del: \"strike-through\",\n  code: \"code\",\n  sup: \"sup\",\n  sub: \"sub\",\n  ins: \"ins\",\n  mark: \"mark\",\n  small: \"small\"\n}, HTML_LIST_ITEM_TAGS = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: \"bullet\"\n  }\n}, ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS\n};\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(ELEMENT_MAP).filter((tag) => \"style\" in tag).map((tag) => tag.style)\n);\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(HTML_DECORATOR_TAGS)\n);\nfunction blockContentFeatures(blockContentType) {\n  if (!blockContentType)\n    throw new Error(\"Parameter 'blockContentType' required\");\n  const blockType = blockContentType.of.find(findBlockType);\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockSchemaType)(blockType))\n    throw new Error(\"'block' type is not defined in this schema (required).\");\n  const ofType = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockChildrenObjectField)?.type?.of;\n  if (!ofType)\n    throw new Error(\"No `of` declaration found for blocks `children` field\");\n  const spanType = ofType.find(\n    (member) => member.name === \"span\"\n  );\n  if (!spanType)\n    throw new Error(\n      \"No `span` type found in `block` schema type `children` definition\"\n    );\n  const inlineObjectTypes = ofType.filter(\n    (inlineType) => inlineType.name !== \"span\" && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(inlineType)\n  ), blockObjectTypes = blockContentType.of.filter(\n    (memberType) => memberType.name !== blockType.name && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(memberType)\n  );\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes\n    }\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockStyleObjectField);\n  if (!styleField)\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\"\n    );\n  const textStyles = getTitledListValuesFromEnumListOptions(\n    styleField.type.options\n  );\n  if (textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledAnnotationTypes(spanType) {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon\n  }));\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockListObjectField);\n  if (!listField)\n    throw new Error(\n      \"A field with name 'list' is not defined in the block type (required).\"\n    );\n  const listItems = getTitledListValuesFromEnumListOptions(\n    listField.type.options\n  );\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction getTitledListValuesFromEnumListOptions(options) {\n  const list = options ? options.list : void 0;\n  return Array.isArray(list) ? list.map(\n    (item) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isTitledListValue)(item) ? item : { title: item, value: item }\n  ) : [];\n}\nconst _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9\n};\nvar preprocessGDocs = (_html, doc, options) => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || \"preserve\";\n  let gDocsRootOrSiblingNode = doc.evaluate(\n    '//*[@id and contains(@id, \"docs-internal-guid\")]',\n    doc,\n    null,\n    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n    null\n  ).iterateNext();\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === \"b\";\n    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {\n      case \"normalize\":\n        normalizeWhitespace(gDocsRootOrSiblingNode);\n        break;\n      case \"remove\":\n        removeAllWhitespace(gDocsRootOrSiblingNode);\n        break;\n    }\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i);\n      elm?.setAttribute(\"data-is-google-docs\", \"true\"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute(\"data-is-root-node\", \"true\"), tagName(elm)), tagName(elm) === \"li\" && elm.firstChild && tagName(elm?.firstChild) === \"img\" && elm.removeChild(elm.firstChild);\n    }\n    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(\n      ...Array.from(gDocsRootOrSiblingNode.childNodes)\n    ), doc;\n  }\n  return doc;\n};\nconst unwantedWordDocumentPaths = [\n  \"/html/text()\",\n  \"/html/head/text()\",\n  \"/html/body/text()\",\n  \"/html/body/ul/text()\",\n  \"/html/body/ol/text()\",\n  \"//comment()\",\n  \"//style\",\n  \"//xml\",\n  \"//script\",\n  \"//meta\",\n  \"//link\"\n];\nvar preprocessHTML = (_html, doc) => {\n  const bodyTextNodes = doc.evaluate(\n    \"/html/body/text()\",\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || \"\";\n    if (text.replace(/[^\\S\\n]+$/g, \"\")) {\n      const newNode = doc.createElement(\"span\");\n      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);\n    } else\n      node.parentNode?.removeChild(node);\n  }\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted && unwanted.parentNode?.removeChild(unwanted);\n  }\n  return doc;\n}, preprocessNotion = (html, doc) => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;\n  if (html.match(NOTION_REGEX)) {\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)\n      childNodes.snapshotItem(i)?.setAttribute(\"data-is-notion\", \"true\");\n    return doc;\n  }\n  return doc;\n}, preprocessWhitespace = (_2, doc) => {\n  function processNode(node) {\n    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(\n      node.parentElement?.tagName.toLowerCase() || \"\"\n    ))\n      node.textContent = node.textContent?.replace(/\\s\\s+/g, \" \").replace(/[\\r\\n]+/g, \" \") || \"\";\n    else\n      for (let i = 0; i < node.childNodes.length; i++)\n        processNode(node.childNodes[i]);\n  }\n  return processNode(doc.body), doc;\n};\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/, unwantedPaths = [\n  \"//o:p\",\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\"\n], mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\"\n], elementMap = {\n  MsoTocHeading: [\"h3\"],\n  MsoTitle: [\"h1\"],\n  MsoToaHeading: [\"h2\"],\n  MsoSubtitle: [\"h5\"],\n  MsoSubtleEmphasis: [\"span\", \"em\"],\n  MsoIntenseEmphasis: [\"span\", \"em\", \"strong\"]\n  // Remove cruft\n};\nfunction isWordHtml(html) {\n  return WORD_HTML_REGEX.test(html);\n}\nvar preprocessWord = (html, doc) => {\n  if (!isWordHtml(html))\n    return doc;\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join(\"|\"),\n    doc,\n    (prefix) => prefix === \"o\" ? \"urn:schemas-microsoft-com:office:office\" : null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);\n  }\n  const mappedElements = doc.evaluate(\n    mappedPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || \"\");\n    if (!tags)\n      continue;\n    const parentElement = doc.createElement(tags[0]);\n    let parent = parentElement, child = parentElement;\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag), parent.appendChild(child), parent = child;\n    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);\n  }\n  return doc;\n}, preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML\n];\nfunction createRuleOptions(blockContentType) {\n  const features = blockContentFeatures(blockContentType), enabledBlockStyles = features.styles.map(\n    (item) => item.value || item.title\n  ), enabledSpanDecorators = features.decorators.map(\n    (item) => item.value || item.title\n  ), enabledBlockAnnotations = features.annotations.map(\n    (item) => item.value || item.title || \"\"\n  ), enabledListTypes = features.lists.map(\n    (item) => item.value || item.title || \"\"\n  );\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes\n  };\n}\nfunction tagName(el) {\n  if (el && \"tagName\" in el)\n    return el.tagName.toLowerCase();\n}\nfunction preprocess(html, parseHtml, options) {\n  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));\n  return preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options);\n  }), doc;\n}\nfunction normalizeHtmlBeforePreprocess(html) {\n  return html.trim();\n}\nfunction defaultParseHtml() {\n  if (resolveJsType(DOMParser) === \"undefined\")\n    throw new Error(\n      \"The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.\"\n    );\n  return (html) => new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction flattenNestedBlocks(blocks2) {\n  let depth = 0;\n  const flattened = [], traverse = (nodes) => {\n    const toRemove = [];\n    nodes.forEach((node) => {\n      depth === 0 && flattened.push(node), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(node) && (depth > 0 && (toRemove.push(node), flattened.push(node)), depth++, traverse(node.children)), node._type === \"__block\" && (toRemove.push(node), flattened.push(node.block));\n    }), toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1);\n    }), depth--;\n  };\n  return traverse(blocks2), flattened;\n}\nfunction nextSpan(block, index) {\n  const next = block.children[index + 1];\n  return next && next._type === \"span\" ? next : null;\n}\nfunction prevSpan(block, index) {\n  const prev = block.children[index - 1];\n  return prev && prev._type === \"span\" ? prev : null;\n}\nfunction isWhiteSpaceChar(text) {\n  return [\"\\xA0\", \" \"].includes(text);\n}\nfunction trimWhitespace(blocks2) {\n  return blocks2.forEach((block) => {\n    (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(block) && block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child))\n        return;\n      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);\n      index === 0 && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), child.text || block.children.splice(index, 1), prevChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += \" \", block.children.splice(index, 1)) : nextChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));\n    });\n  }), blocks2;\n}\nfunction ensureRootIsBlocks(blocks2) {\n  return blocks2.reduce((memo, node, i, original) => {\n    if (node._type === \"block\")\n      return memo.push(node), memo;\n    if (node._type === \"__block\")\n      return memo.push(node.block), memo;\n    const lastBlock = memo[memo.length - 1];\n    if (i > 0 && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(original[i - 1]) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(lastBlock))\n      return lastBlock.children.push(node), memo;\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node]\n    };\n    return memo.push(block), memo;\n  }, []);\n}\nfunction isNodeList(node) {\n  return Object.prototype.toString.call(node) === \"[object NodeList]\";\n}\nfunction isMinimalSpan(node) {\n  return node._type === \"span\";\n}\nfunction isMinimalBlock(node) {\n  return node._type === \"block\";\n}\nfunction isPlaceholderDecorator(node) {\n  return node._type === \"__decorator\";\n}\nfunction isPlaceholderAnnotation(node) {\n  return node._type === \"__annotation\";\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction normalizeWhitespace(rootNode) {\n  let emptyBlockCount = 0, lastParent = null;\n  const nodesToRemove = [];\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child), emptyBlockCount = 0;\n      continue;\n    }\n    const elm = child;\n    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);\n  }\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction removeAllWhitespace(rootNode) {\n  const nodesToRemove = [];\n  function collectNodesToRemove(currentNode) {\n    if (isElement(currentNode)) {\n      const elm = currentNode;\n      if (tagName(elm) === \"br\" && (tagName(elm.nextElementSibling) === \"p\" || tagName(elm.previousElementSibling) === \"p\")) {\n        nodesToRemove.push(elm);\n        return;\n      }\n      if ((tagName(elm) === \"p\" || tagName(elm) === \"br\") && elm?.firstChild?.textContent?.trim() === \"\") {\n        nodesToRemove.push(elm);\n        return;\n      }\n      for (let child = elm.firstChild; child; child = child.nextSibling)\n        collectNodesToRemove(child);\n    }\n  }\n  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction isWhitespaceBlock(elm) {\n  return [\"p\", \"br\"].includes(tagName(elm) || \"\") && !elm.textContent?.trim();\n}\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);\nfunction isEmphasis$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style\\s*:\\s*italic/.test(style || \"\");\n}\nfunction isStrong$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight\\s*:\\s*700/.test(style || \"\");\n}\nfunction isUnderline$1(el) {\n  if (!isElement(el) || tagName(el.parentNode) === \"a\")\n    return !1;\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*underline/.test(style || \"\");\n}\nfunction isStrikethrough(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || \"\");\n}\nfunction isGoogleDocs(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-google-docs\");\n}\nfunction isRootNode(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-root-node\");\n}\nfunction getListItemStyle$1(el) {\n  const parentTag = tagName(el.parentNode);\n  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))\n    return tagName(el.parentNode) === \"ul\" ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel$1(el) {\n  let level = 0;\n  if (tagName(el) === \"li\") {\n    let parentNode = el.parentNode;\n    for (; parentNode; ) {\n      const parentTag = tagName(parentNode);\n      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;\n    }\n  } else\n    level = 1;\n  return level;\n}\nconst blocks = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS\n};\nfunction getBlockStyle(el, enabledBlockStyles) {\n  const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];\n  return block && enabledBlockStyles.includes(block.style) ? block.style : BLOCK_DEFAULT_STYLE;\n}\nfunction createGDocsRules(_blockContentType, options) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong$1(el) && span.marks.push(\"strong\"), isUnderline$1(el) && span.marks.push(\"underline\"), isStrikethrough(el) && span.marks.push(\"strike-through\"), isEmphasis$1(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"li\" && isGoogleDocs(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle$1(el),\n            level: getListItemLevel$1(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || [])\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el.classList.contains(\"apple-interchange-newline\"))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el?.parentNode?.textContent === \"\")\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && isRootNode(el))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n      }\n    }\n  ];\n}\nfunction keyGenerator() {\n  return randomKey(12);\n}\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(rnds8), rnds8;\n}\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i)\n  byteToHex[i] = (i + 256).toString(16).slice(1);\nfunction randomKey(length) {\n  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], \"\").slice(0, length);\n}\nfunction resolveListItem(listNodeTagName, enabledListTypes) {\n  if (listNodeTagName === \"ul\" && enabledListTypes.includes(\"bullet\"))\n    return \"bullet\";\n  if (listNodeTagName === \"ol\" && enabledListTypes.includes(\"number\"))\n    return \"number\";\n}\nfunction createHTMLRules(_blockContentType, options) {\n  return [\n    // Text nodes\n    {\n      deserialize(el) {\n        if (tagName(el) === \"pre\")\n          return;\n        const isValidText = (el.nodeType === 3 && (el.textContent || \"\").replace(/[\\r\\n]/g, \" \").replace(/\\s\\s+/g, \" \") === \" \" && el.nextSibling && el.nextSibling.nodeType !== 3 && el.previousSibling && el.previousSibling.nodeType !== 3 || el.textContent !== \" \") && tagName(el.parentNode) !== \"body\";\n        if (el.nodeName === \"#text\" && isValidText)\n          return {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: (el.textContent || \"\").replace(/\\s\\s+/g, \" \")\n          };\n      }\n    },\n    // Pre element\n    {\n      deserialize(el) {\n        if (tagName(el) !== \"pre\")\n          return;\n        const isCodeEnabled = options.enabledBlockStyles.includes(\"code\");\n        return {\n          _type: \"block\",\n          style: \"normal\",\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? [\"code\"] : [],\n              text: el.textContent || \"\"\n            }\n          ]\n        };\n      }\n    },\n    // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"blockquote\")\n          return;\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        };\n        delete blocks2.blockquote;\n        const children = [];\n        return el.childNodes.forEach((node, index) => {\n          if (node.nodeType === 1 && Object.keys(blocks2).includes(\n            node.localName.toLowerCase()\n          )) {\n            if (!el.ownerDocument)\n              return;\n            const span = el.ownerDocument.createElement(\"span\");\n            span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(!0));\n            }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), children.push(span);\n          } else\n            children.push(node);\n        }), {\n          _type: \"block\",\n          style: \"blockquote\",\n          markDefs: [],\n          children: next(children)\n        };\n      }\n    },\n    // Block elements\n    {\n      deserialize(el, next) {\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        }, tag = tagName(el);\n        let block = tag ? blocks2[tag] : void 0;\n        if (block)\n          return el.parentNode && tagName(el.parentNode) === \"li\" ? next(el.childNodes) : (options.enabledBlockStyles.includes(block.style) || (block = DEFAULT_BLOCK), {\n            ...block,\n            children: next(el.childNodes)\n          });\n      }\n    },\n    // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_SPAN_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Ignore div tags\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"div\")\n          return next(el.childNodes);\n      }\n    },\n    // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\")\n          return {\n            ...DEFAULT_SPAN,\n            text: `\n`\n          };\n      }\n    },\n    // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || \"\";\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag])\n          return;\n        const enabledListItem = resolveListItem(\n          parentTag,\n          options.enabledListTypes\n        );\n        return enabledListItem ? (listItem.listItem = enabledListItem, {\n          ...listItem,\n          children: next(el.childNodes)\n        }) : block({ _type: \"block\", children: next(el.childNodes) });\n      }\n    },\n    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || \"\"];\n        if (!(!decorator || !options.enabledSpanDecorators.includes(decorator)))\n          return {\n            _type: \"__decorator\",\n            name: decorator,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"a\")\n          return;\n        const linkEnabled = options.enabledBlockAnnotations.includes(\"link\"), href = isElement(el) && el.getAttribute(\"href\");\n        if (!href)\n          return next(el.childNodes);\n        let markDef;\n        return linkEnabled ? (markDef = {\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n          _type: \"link\",\n          href\n        }, {\n          _type: \"__annotation\",\n          markDef,\n          children: next(el.childNodes)\n        }) : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes);\n      }\n    }\n  ];\n}\nfunction isEmphasis(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style:italic/.test(style || \"\");\n}\nfunction isStrong(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight:700/.test(style || \"\") || /font-weight:600/.test(style || \"\");\n}\nfunction isUnderline(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration:underline/.test(style || \"\");\n}\nfunction isNotion(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-notion\");\n}\nfunction createNotionRules(_blockContentType) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong(el) && span.marks.push(\"strong\"), isUnderline(el) && span.marks.push(\"underline\"), isEmphasis(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    }\n  ];\n}\nfunction getListItemStyle(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (style && style.match(/lfo\\d+/))\n    return style.match(\"lfo1\") ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (!style)\n    return;\n  const levelMatch = style.match(/level\\d+/);\n  if (!levelMatch)\n    return;\n  const [level] = levelMatch[0].match(/\\d/) || [];\n  return (level ? Number.parseInt(level, 10) : 1) || 1;\n}\nfunction isWordListElement(el) {\n  return isElement(el) && el.className ? el.className === \"MsoListParagraphCxSpFirst\" || el.className === \"MsoListParagraphCxSpMiddle\" || el.className === \"MsoListParagraphCxSpLast\" : !1;\n}\nfunction createWordRules() {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"p\" && isWordListElement(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes)\n          };\n      }\n    }\n  ];\n}\nfunction createRules(blockContentType, options) {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options)\n  ];\n}\nclass HtmlDeserializer {\n  blockContentType;\n  rules;\n  parseHtml;\n  _markDefs = [];\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType, options = {}) {\n    const { rules = [], unstable_whitespaceOnPasteMode = \"preserve\" } = options;\n    if (!blockContentType)\n      throw new Error(\"Parameter 'blockContentType' is required\");\n    const standardRules = createRules(blockContentType, {\n      ...createRuleOptions(blockContentType),\n      keyGenerator: options.keyGenerator\n    });\n    this.rules = [...rules, ...standardRules];\n    const parseHtml = options.parseHtml || defaultParseHtml();\n    this.blockContentType = blockContentType, this.parseHtml = (html) => preprocess(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;\n  }\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html) => {\n    this._markDefs = [];\n    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(\n      flattenNestedBlocks(\n        ensureRootIsBlocks(this.deserializeElements(children))\n      )\n    );\n    this._markDefs.length > 0 && blocks2.filter(\n      (block) => block._type === \"block\"\n    ).forEach((block) => {\n      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(\n        this._markDefs.filter((def) => lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__(\n          block.children.map((child) => child.marks || [])\n        ).includes(def._key))\n      );\n    });\n    const type = this.blockContentType.of.find(findBlockType);\n    return type ? blocks2.map((block) => (block._type === \"block\" && (block._type = type.name), block)) : blocks2;\n  };\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements = []) => {\n    let nodes = [];\n    return elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element));\n    }), nodes;\n  };\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element) => {\n    const next = (elements) => {\n      if (isNodeList(elements))\n        return this.deserializeElements(Array.from(elements));\n      if (Array.isArray(elements))\n        return this.deserializeElements(elements);\n      if (elements)\n        return this.deserializeElement(elements);\n    }, block = (props) => ({\n      _type: \"__block\",\n      block: props\n    });\n    let node;\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i];\n      if (!rule.deserialize)\n        continue;\n      const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);\n      if (type !== \"array\" && type !== \"object\" && type !== \"null\" && type !== \"undefined\")\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        );\n      if (ret !== void 0) {\n        {\n          if (ret === null)\n            throw new Error(\"Deserializer rule returned `null`\");\n          Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;\n        }\n        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && \"listItem\" in ret) {\n          let parent = element.parentNode?.parentNode;\n          for (; parent && tagName(parent) === \"li\"; )\n            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;\n        }\n        ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === \"blockquote\" && ret.children.forEach((child, index) => {\n          isMinimalSpan(child) && child.text === \"\\r\" && (child.text = `\n\n`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));\n        });\n        break;\n      }\n    }\n    return node || next(element.childNodes) || [];\n  };\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator) => {\n    const { name } = decorator, applyDecorator = (node) => {\n      if (isPlaceholderDecorator(node))\n        return this.deserializeDecorator(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyDecorator);\n      }\n      return node;\n    };\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation) => {\n    const { markDef } = annotation;\n    this._markDefs.push(markDef);\n    const applyAnnotation = (node) => {\n      if (isPlaceholderAnnotation(node))\n        return this.deserializeAnnotation(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyAnnotation);\n      }\n      return node;\n    };\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n}\nfunction normalizeBlock(node, options = {}) {\n  if (node._type !== (options.blockTypeName || \"block\"))\n    return \"_key\" in node ? node : {\n      ...node,\n      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()\n    };\n  const block = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node\n  }, lastChild = block.children[block.children.length - 1];\n  if (!lastChild)\n    return block.children = [\n      {\n        _type: \"span\",\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: \"\",\n        marks: []\n      }\n    ], block;\n  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;\n  return block.children = block.children.reduce(\n    (acc, child) => {\n      const previousChild = acc[acc.length - 1];\n      return previousChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(previousChild) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === \"\" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);\n    },\n    []\n  ).map((child) => {\n    if (!child)\n      throw new Error(\"missing child\");\n    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {\n      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);\n      return isAllowed || isUsed;\n    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;\n  }), block.markDefs = (block.markDefs || []).filter(\n    (markDef) => usedMarkDefs.includes(markDef._key)\n  ), block;\n}\nfunction htmlToBlocks(html, blockContentType, options = {}) {\n  return new HtmlDeserializer(blockContentType, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));\n}\nfunction getBlockContentFeatures(blockContentType) {\n  return blockContentFeatures(blockContentType);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9ibG9jay10b29scy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzJLO0FBQzNLO0FBQ047QUFDa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpS0FBaUssUUFBUTtBQUNuTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQyxFQUFFLGdCQUFnQixZQUFZLHNCQUFzQixFQUFFLEVBQUUsR0FBRztBQUN2RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQixDQUFDO0FBQ0QsVUFBVTtBQUNWLENBQUM7QUFDRCxRQUFRLGNBQWM7QUFDdEIsUUFBUTtBQUNSLENBQUM7QUFDRCxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRO0FBQ1IsQ0FBQztBQUNELFFBQVE7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQWlCO0FBQ3hCO0FBQ0EsdUNBQXVDLHFFQUEwQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlFQUFlO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLCtDQUErQztBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBd0QsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1R0FBdUcsZ0NBQWdDO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQWtCLFdBQVcsaUVBQWtCLG1CQUFtQiw4Q0FBTztBQUN2RyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsaUVBQWtCO0FBQzFHO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxrSEFBa0gsb0NBQW9DO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGUvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9ibG9jay10b29scy9saWIvaW5kZXguanM/YzE0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCB7IGlzQmxvY2tTY2hlbWFUeXBlLCBpc0Jsb2NrQ2hpbGRyZW5PYmplY3RGaWVsZCwgaXNPYmplY3RTY2hlbWFUeXBlLCBpc0Jsb2NrU3R5bGVPYmplY3RGaWVsZCwgaXNCbG9ja0xpc3RPYmplY3RGaWVsZCwgaXNUaXRsZWRMaXN0VmFsdWUsIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4gfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoL3VuaXEuanNcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuZnVuY3Rpb24gZmluZEJsb2NrVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPyBmaW5kQmxvY2tUeXBlKHR5cGUudHlwZSkgOiB0eXBlLm5hbWUgPT09IFwiYmxvY2tcIjtcbn1cbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIHJlc29sdmVKc1R5cGUodmFsKSB7XG4gIHN3aXRjaCAob2JqZWN0VG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSBcIltvYmplY3QgRnVuY3Rpb25dXCI6XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgY2FzZSBcIltvYmplY3QgUmVnRXhwXVwiOlxuICAgICAgcmV0dXJuIFwicmVnZXhwXCI7XG4gICAgY2FzZSBcIltvYmplY3QgQXJndW1lbnRzXVwiOlxuICAgICAgcmV0dXJuIFwiYXJndW1lbnRzXCI7XG4gICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIHJldHVybiB2YWwgPT09IG51bGwgPyBcIm51bGxcIiA6IHZhbCA9PT0gdm9pZCAwID8gXCJ1bmRlZmluZWRcIiA6IHZhbCAmJiB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIgJiYgXCJub2RlVHlwZVwiIGluIHZhbCAmJiB2YWwubm9kZVR5cGUgPT09IDEgPyBcImVsZW1lbnRcIiA6IHZhbCA9PT0gT2JqZWN0KHZhbCkgPyBcIm9iamVjdFwiIDogdHlwZW9mIHZhbDtcbn1cbnZhciBzID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA4MjkwLCA0OiA4MjkxLCA1OiA4Mjg4LCA2OiA2NTI3OSwgNzogODI4OSwgODogMTE5MTU1LCA5OiAxMTkxNTYsIGE6IDExOTE1NywgYjogMTE5MTU4LCBjOiAxMTkxNTksIGQ6IDExOTE2MCwgZTogMTE5MTYxLCBmOiAxMTkxNjIgfSwgYyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogNjUyNzkgfTtcbm5ldyBBcnJheSg0KS5maWxsKFN0cmluZy5mcm9tQ29kZVBvaW50KGNbMF0pKS5qb2luKFwiXCIpO1xuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG52YXIgUyA9IGAke09iamVjdC52YWx1ZXMocykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBmID0gbmV3IFJlZ0V4cChgWyR7U31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBfKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShmLCBcIlwiKSwgZW5jb2RlZDogKChlID0gdC5tYXRjaChmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIE8odCkge1xuICByZXR1cm4gdCAmJiBKU09OLnBhcnNlKF8oSlNPTi5zdHJpbmdpZnkodCkpLmNsZWFuZWQpO1xufVxuY29uc3QgUFJFU0VSVkVfV0hJVEVTUEFDRV9UQUdTID0gW1wicHJlXCIsIFwidGV4dGFyZWFcIiwgXCJjb2RlXCJdLCBCTE9DS19ERUZBVUxUX1NUWUxFID0gXCJub3JtYWxcIiwgREVGQVVMVF9CTE9DSyA9IE9iamVjdC5mcmVlemUoe1xuICBfdHlwZTogXCJibG9ja1wiLFxuICBtYXJrRGVmczogW10sXG4gIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFXG59KSwgREVGQVVMVF9TUEFOID0gT2JqZWN0LmZyZWV6ZSh7XG4gIF90eXBlOiBcInNwYW5cIixcbiAgbWFya3M6IFtdXG59KSwgSFRNTF9CTE9DS19UQUdTID0ge1xuICBwOiBERUZBVUxUX0JMT0NLLFxuICBibG9ja3F1b3RlOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImJsb2NrcXVvdGVcIiB9XG59LCBIVE1MX1NQQU5fVEFHUyA9IHtcbiAgc3BhbjogeyBvYmplY3Q6IFwidGV4dFwiIH1cbn0sIEhUTUxfTElTVF9DT05UQUlORVJfVEFHUyA9IHtcbiAgb2w6IHsgb2JqZWN0OiBudWxsIH0sXG4gIHVsOiB7IG9iamVjdDogbnVsbCB9XG59LCBIVE1MX0hFQURFUl9UQUdTID0ge1xuICBoMTogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoMVwiIH0sXG4gIGgyOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImgyXCIgfSxcbiAgaDM6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDNcIiB9LFxuICBoNDogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoNFwiIH0sXG4gIGg1OiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImg1XCIgfSxcbiAgaDY6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDZcIiB9XG59LCBIVE1MX01JU0NfVEFHUyA9IHtcbiAgYnI6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEUgfVxufSwgSFRNTF9ERUNPUkFUT1JfVEFHUyA9IHtcbiAgYjogXCJzdHJvbmdcIixcbiAgc3Ryb25nOiBcInN0cm9uZ1wiLFxuICBpOiBcImVtXCIsXG4gIGVtOiBcImVtXCIsXG4gIHU6IFwidW5kZXJsaW5lXCIsXG4gIHM6IFwic3RyaWtlLXRocm91Z2hcIixcbiAgc3RyaWtlOiBcInN0cmlrZS10aHJvdWdoXCIsXG4gIGRlbDogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBjb2RlOiBcImNvZGVcIixcbiAgc3VwOiBcInN1cFwiLFxuICBzdWI6IFwic3ViXCIsXG4gIGluczogXCJpbnNcIixcbiAgbWFyazogXCJtYXJrXCIsXG4gIHNtYWxsOiBcInNtYWxsXCJcbn0sIEhUTUxfTElTVF9JVEVNX1RBR1MgPSB7XG4gIGxpOiB7XG4gICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSxcbiAgICBsZXZlbDogMSxcbiAgICBsaXN0SXRlbTogXCJidWxsZXRcIlxuICB9XG59LCBFTEVNRU5UX01BUCA9IHtcbiAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAuLi5IVE1MX1NQQU5fVEFHUyxcbiAgLi4uSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTLFxuICAuLi5IVE1MX0xJU1RfSVRFTV9UQUdTLFxuICAuLi5IVE1MX0hFQURFUl9UQUdTLFxuICAuLi5IVE1MX01JU0NfVEFHU1xufTtcbnVuaXEoXG4gIE9iamVjdC52YWx1ZXMoRUxFTUVOVF9NQVApLmZpbHRlcigodGFnKSA9PiBcInN0eWxlXCIgaW4gdGFnKS5tYXAoKHRhZykgPT4gdGFnLnN0eWxlKVxuKTtcbnVuaXEoXG4gIE9iamVjdC52YWx1ZXMoSFRNTF9ERUNPUkFUT1JfVEFHUylcbik7XG5mdW5jdGlvbiBibG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIGlmICghYmxvY2tDb250ZW50VHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgJ2Jsb2NrQ29udGVudFR5cGUnIHJlcXVpcmVkXCIpO1xuICBjb25zdCBibG9ja1R5cGUgPSBibG9ja0NvbnRlbnRUeXBlLm9mLmZpbmQoZmluZEJsb2NrVHlwZSk7XG4gIGlmICghaXNCbG9ja1NjaGVtYVR5cGUoYmxvY2tUeXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInYmxvY2snIHR5cGUgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzY2hlbWEgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IG9mVHlwZSA9IGJsb2NrVHlwZS5maWVsZHMuZmluZChpc0Jsb2NrQ2hpbGRyZW5PYmplY3RGaWVsZCk/LnR5cGU/Lm9mO1xuICBpZiAoIW9mVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBgb2ZgIGRlY2xhcmF0aW9uIGZvdW5kIGZvciBibG9ja3MgYGNoaWxkcmVuYCBmaWVsZFwiKTtcbiAgY29uc3Qgc3BhblR5cGUgPSBvZlR5cGUuZmluZChcbiAgICAobWVtYmVyKSA9PiBtZW1iZXIubmFtZSA9PT0gXCJzcGFuXCJcbiAgKTtcbiAgaWYgKCFzcGFuVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIk5vIGBzcGFuYCB0eXBlIGZvdW5kIGluIGBibG9ja2Agc2NoZW1hIHR5cGUgYGNoaWxkcmVuYCBkZWZpbml0aW9uXCJcbiAgICApO1xuICBjb25zdCBpbmxpbmVPYmplY3RUeXBlcyA9IG9mVHlwZS5maWx0ZXIoXG4gICAgKGlubGluZVR5cGUpID0+IGlubGluZVR5cGUubmFtZSAhPT0gXCJzcGFuXCIgJiYgaXNPYmplY3RTY2hlbWFUeXBlKGlubGluZVR5cGUpXG4gICksIGJsb2NrT2JqZWN0VHlwZXMgPSBibG9ja0NvbnRlbnRUeXBlLm9mLmZpbHRlcihcbiAgICAobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lICE9PSBibG9ja1R5cGUubmFtZSAmJiBpc09iamVjdFNjaGVtYVR5cGUobWVtYmVyVHlwZSlcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSksXG4gICAgZGVjb3JhdG9yczogcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSxcbiAgICBhbm5vdGF0aW9uczogcmVzb2x2ZUVuYWJsZWRBbm5vdGF0aW9uVHlwZXMoc3BhblR5cGUpLFxuICAgIGxpc3RzOiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpLFxuICAgIHR5cGVzOiB7XG4gICAgICBibG9jazogYmxvY2tDb250ZW50VHlwZSxcbiAgICAgIHNwYW46IHNwYW5UeXBlLFxuICAgICAgaW5saW5lT2JqZWN0czogaW5saW5lT2JqZWN0VHlwZXMsXG4gICAgICBibG9ja09iamVjdHM6IGJsb2NrT2JqZWN0VHlwZXNcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpIHtcbiAgY29uc3Qgc3R5bGVGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHMuZmluZChpc0Jsb2NrU3R5bGVPYmplY3RGaWVsZCk7XG4gIGlmICghc3R5bGVGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkEgZmllbGQgd2l0aCBuYW1lICdzdHlsZScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIlxuICAgICk7XG4gIGNvbnN0IHRleHRTdHlsZXMgPSBnZXRUaXRsZWRMaXN0VmFsdWVzRnJvbUVudW1MaXN0T3B0aW9ucyhcbiAgICBzdHlsZUZpZWxkLnR5cGUub3B0aW9uc1xuICApO1xuICBpZiAodGV4dFN0eWxlcy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgc3R5bGUgZmllbGRzIG5lZWQgYXQgbGVhc3Qgb25lIHN0eWxlIGRlZmluZWQuIEkuZToge3RpdGxlOiAnTm9ybWFsJywgdmFsdWU6ICdub3JtYWwnfS5cIlxuICAgICk7XG4gIHJldHVybiB0ZXh0U3R5bGVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRBbm5vdGF0aW9uVHlwZXMoc3BhblR5cGUpIHtcbiAgcmV0dXJuIHNwYW5UeXBlLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICB0aXRsZTogYW5ub3RhdGlvbi50aXRsZSxcbiAgICB0eXBlOiBhbm5vdGF0aW9uLFxuICAgIHZhbHVlOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgaWNvbjogYW5ub3RhdGlvbi5pY29uXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSkge1xuICByZXR1cm4gc3BhblR5cGUuZGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSkge1xuICBjb25zdCBsaXN0RmllbGQgPSBibG9ja1R5cGUuZmllbGRzLmZpbmQoaXNCbG9ja0xpc3RPYmplY3RGaWVsZCk7XG4gIGlmICghbGlzdEZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBmaWVsZCB3aXRoIG5hbWUgJ2xpc3QnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCJcbiAgICApO1xuICBjb25zdCBsaXN0SXRlbXMgPSBnZXRUaXRsZWRMaXN0VmFsdWVzRnJvbUVudW1MaXN0T3B0aW9ucyhcbiAgICBsaXN0RmllbGQudHlwZS5vcHRpb25zXG4gICk7XG4gIGlmICghbGlzdEl0ZW1zKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsaXN0IGZpZWxkIG5lZWQgYXQgbGVhc3QgdG8gYmUgYW4gZW1wdHkgYXJyYXlcIik7XG4gIHJldHVybiBsaXN0SXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUaXRsZWRMaXN0VmFsdWVzRnJvbUVudW1MaXN0T3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IGxpc3QgPSBvcHRpb25zID8gb3B0aW9ucy5saXN0IDogdm9pZCAwO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QubWFwKFxuICAgIChpdGVtKSA9PiBpc1RpdGxlZExpc3RWYWx1ZShpdGVtKSA/IGl0ZW0gOiB7IHRpdGxlOiBpdGVtLCB2YWx1ZTogaXRlbSB9XG4gICkgOiBbXTtcbn1cbmNvbnN0IF9YUGF0aFJlc3VsdCA9IHtcbiAgQU5ZX1RZUEU6IDAsXG4gIE5VTUJFUl9UWVBFOiAxLFxuICBTVFJJTkdfVFlQRTogMixcbiAgQk9PTEVBTl9UWVBFOiAzLFxuICBVTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOiA0LFxuICBPUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRTogNSxcbiAgVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRTogNixcbiAgT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEU6IDcsXG4gIEFOWV9VTk9SREVSRURfTk9ERV9UWVBFOiA4LFxuICBGSVJTVF9PUkRFUkVEX05PREVfVFlQRTogOVxufTtcbnZhciBwcmVwcm9jZXNzR0RvY3MgPSAoX2h0bWwsIGRvYywgb3B0aW9ucykgPT4ge1xuICBjb25zdCB3aGl0ZXNwYWNlT25QYXN0ZU1vZGUgPSBvcHRpb25zPy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgfHwgXCJwcmVzZXJ2ZVwiO1xuICBsZXQgZ0RvY3NSb290T3JTaWJsaW5nTm9kZSA9IGRvYy5ldmFsdWF0ZShcbiAgICAnLy8qW0BpZCBhbmQgY29udGFpbnMoQGlkLCBcImRvY3MtaW50ZXJuYWwtZ3VpZFwiKV0nLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSxcbiAgICBudWxsXG4gICkuaXRlcmF0ZU5leHQoKTtcbiAgaWYgKGdEb2NzUm9vdE9yU2libGluZ05vZGUpIHtcbiAgICBjb25zdCBpc1dyYXBwZWRSb290VGFnID0gdGFnTmFtZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKSA9PT0gXCJiXCI7XG4gICAgc3dpdGNoIChpc1dyYXBwZWRSb290VGFnIHx8IChnRG9jc1Jvb3RPclNpYmxpbmdOb2RlID0gZG9jLmJvZHkpLCB3aGl0ZXNwYWNlT25QYXN0ZU1vZGUpIHtcbiAgICAgIGNhc2UgXCJub3JtYWxpemVcIjpcbiAgICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgIHJlbW92ZUFsbFdoaXRlc3BhY2UoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgICAgXCIvLypcIixcbiAgICAgIGRvYyxcbiAgICAgIG51bGwsXG4gICAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVsbSA9IGNoaWxkTm9kZXMuc25hcHNob3RJdGVtKGkpO1xuICAgICAgZWxtPy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLWdvb2dsZS1kb2NzXCIsIFwidHJ1ZVwiKSwgKGVsbT8ucGFyZW50RWxlbWVudCA9PT0gZ0RvY3NSb290T3JTaWJsaW5nTm9kZSB8fCAhaXNXcmFwcGVkUm9vdFRhZyAmJiBlbG0ucGFyZW50RWxlbWVudCA9PT0gZG9jLmJvZHkpICYmIChlbG0/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtcm9vdC1ub2RlXCIsIFwidHJ1ZVwiKSwgdGFnTmFtZShlbG0pKSwgdGFnTmFtZShlbG0pID09PSBcImxpXCIgJiYgZWxtLmZpcnN0Q2hpbGQgJiYgdGFnTmFtZShlbG0/LmZpcnN0Q2hpbGQpID09PSBcImltZ1wiICYmIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBpc1dyYXBwZWRSb290VGFnICYmIGRvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkPy5yZXBsYWNlV2l0aChcbiAgICAgIC4uLkFycmF5LmZyb20oZ0RvY3NSb290T3JTaWJsaW5nTm9kZS5jaGlsZE5vZGVzKVxuICAgICksIGRvYztcbiAgfVxuICByZXR1cm4gZG9jO1xufTtcbmNvbnN0IHVud2FudGVkV29yZERvY3VtZW50UGF0aHMgPSBbXG4gIFwiL2h0bWwvdGV4dCgpXCIsXG4gIFwiL2h0bWwvaGVhZC90ZXh0KClcIixcbiAgXCIvaHRtbC9ib2R5L3RleHQoKVwiLFxuICBcIi9odG1sL2JvZHkvdWwvdGV4dCgpXCIsXG4gIFwiL2h0bWwvYm9keS9vbC90ZXh0KClcIixcbiAgXCIvL2NvbW1lbnQoKVwiLFxuICBcIi8vc3R5bGVcIixcbiAgXCIvL3htbFwiLFxuICBcIi8vc2NyaXB0XCIsXG4gIFwiLy9tZXRhXCIsXG4gIFwiLy9saW5rXCJcbl07XG52YXIgcHJlcHJvY2Vzc0hUTUwgPSAoX2h0bWwsIGRvYykgPT4ge1xuICBjb25zdCBib2R5VGV4dE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgIFwiL2h0bWwvYm9keS90ZXh0KClcIixcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSBib2R5VGV4dE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gYm9keVRleHROb2Rlcy5zbmFwc2hvdEl0ZW0oaSksIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8IFwiXCI7XG4gICAgaWYgKHRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpIHtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSksIG5vZGUucGFyZW50Tm9kZT8ucmVwbGFjZUNoaWxkKG5ld05vZGUsIG5vZGUpO1xuICAgIH0gZWxzZVxuICAgICAgbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxuICBjb25zdCB1bndhbnRlZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgIHVud2FudGVkV29yZERvY3VtZW50UGF0aHMuam9pbihcInxcIiksXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdW53YW50ZWQgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90SXRlbShpKTtcbiAgICB1bndhbnRlZCAmJiB1bndhbnRlZC5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh1bndhbnRlZCk7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn0sIHByZXByb2Nlc3NOb3Rpb24gPSAoaHRtbCwgZG9jKSA9PiB7XG4gIGNvbnN0IE5PVElPTl9SRUdFWCA9IC88IS0tIG5vdGlvbnZjOi4qPy0tPi9nO1xuICBpZiAoaHRtbC5tYXRjaChOT1RJT05fUkVHRVgpKSB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICAgIFwiLy8qXCIsXG4gICAgICBkb2MsXG4gICAgICBudWxsLFxuICAgICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gY2hpbGROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgY2hpbGROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtbm90aW9uXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIHJldHVybiBkb2M7XG59LCBwcmVwcm9jZXNzV2hpdGVzcGFjZSA9IChfMiwgZG9jKSA9PiB7XG4gIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gX1hQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSAmJiAhUFJFU0VSVkVfV0hJVEVTUEFDRV9UQUdTLmluY2x1ZGVzKFxuICAgICAgbm9kZS5wYXJlbnRFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgfHwgXCJcIlxuICAgICkpXG4gICAgICBub2RlLnRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudD8ucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikucmVwbGFjZSgvW1xcclxcbl0rL2csIFwiIFwiKSB8fCBcIlwiO1xuICAgIGVsc2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBwcm9jZXNzTm9kZShub2RlLmNoaWxkTm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiBwcm9jZXNzTm9kZShkb2MuYm9keSksIGRvYztcbn07XG5jb25zdCBXT1JEX0hUTUxfUkVHRVggPSAvKGNsYXNzPVwiP01zb3xzdHlsZT0oPzpcInwnKVteXCJdKj9cXGJtc28tfHc6V29yZERvY3VtZW50fDxvOlxcdys+fDxcXC9mb250PikvLCB1bndhbnRlZFBhdGhzID0gW1xuICBcIi8vbzpwXCIsXG4gIFwiLy9zcGFuW0BzdHlsZT0nbXNvLWxpc3Q6SWdub3JlJ11cIixcbiAgXCIvL3NwYW5bQHN0eWxlPSdtc28tbGlzdDogSWdub3JlJ11cIlxuXSwgbWFwcGVkUGF0aHMgPSBbXG4gIFwiLy9wW0BjbGFzcz0nTXNvVG9jSGVhZGluZyddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvVGl0bGUnXVwiLFxuICBcIi8vcFtAY2xhc3M9J01zb1RvYUhlYWRpbmcnXVwiLFxuICBcIi8vcFtAY2xhc3M9J01zb1N1YnRpdGxlJ11cIixcbiAgXCIvL3NwYW5bQGNsYXNzPSdNc29TdWJ0bGVFbXBoYXNpcyddXCIsXG4gIFwiLy9zcGFuW0BjbGFzcz0nTXNvSW50ZW5zZUVtcGhhc2lzJ11cIlxuXSwgZWxlbWVudE1hcCA9IHtcbiAgTXNvVG9jSGVhZGluZzogW1wiaDNcIl0sXG4gIE1zb1RpdGxlOiBbXCJoMVwiXSxcbiAgTXNvVG9hSGVhZGluZzogW1wiaDJcIl0sXG4gIE1zb1N1YnRpdGxlOiBbXCJoNVwiXSxcbiAgTXNvU3VidGxlRW1waGFzaXM6IFtcInNwYW5cIiwgXCJlbVwiXSxcbiAgTXNvSW50ZW5zZUVtcGhhc2lzOiBbXCJzcGFuXCIsIFwiZW1cIiwgXCJzdHJvbmdcIl1cbiAgLy8gUmVtb3ZlIGNydWZ0XG59O1xuZnVuY3Rpb24gaXNXb3JkSHRtbChodG1sKSB7XG4gIHJldHVybiBXT1JEX0hUTUxfUkVHRVgudGVzdChodG1sKTtcbn1cbnZhciBwcmVwcm9jZXNzV29yZCA9IChodG1sLCBkb2MpID0+IHtcbiAgaWYgKCFpc1dvcmRIdG1sKGh0bWwpKVxuICAgIHJldHVybiBkb2M7XG4gIGNvbnN0IHVud2FudGVkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgdW53YW50ZWRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgKHByZWZpeCkgPT4gcHJlZml4ID09PSBcIm9cIiA/IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlXCIgOiBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IHVud2FudGVkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHVud2FudGVkID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgdW53YW50ZWQ/LnBhcmVudE5vZGUgJiYgdW53YW50ZWQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1bndhbnRlZCk7XG4gIH1cbiAgY29uc3QgbWFwcGVkRWxlbWVudHMgPSBkb2MuZXZhbHVhdGUoXG4gICAgbWFwcGVkUGF0aHMuam9pbihcInxcIiksXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gbWFwcGVkRWxlbWVudHMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG1hcHBlZEVsbSA9IG1hcHBlZEVsZW1lbnRzLnNuYXBzaG90SXRlbShpKSwgdGFncyA9IGVsZW1lbnRNYXBbbWFwcGVkRWxtLmNsYXNzTmFtZV0sIHRleHQgPSBkb2MuY3JlYXRlVGV4dE5vZGUobWFwcGVkRWxtLnRleHRDb250ZW50IHx8IFwiXCIpO1xuICAgIGlmICghdGFncylcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWdzWzBdKTtcbiAgICBsZXQgcGFyZW50ID0gcGFyZW50RWxlbWVudCwgY2hpbGQgPSBwYXJlbnRFbGVtZW50O1xuICAgIHRhZ3Muc2xpY2UoMSkuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBjaGlsZCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyksIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCksIHBhcmVudCA9IGNoaWxkO1xuICAgIH0pLCBjaGlsZC5hcHBlbmRDaGlsZCh0ZXh0KSwgbWFwcGVkRWxtPy5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQocGFyZW50RWxlbWVudCwgbWFwcGVkRWxtKTtcbiAgfVxuICByZXR1cm4gZG9jO1xufSwgcHJlcHJvY2Vzc29ycyA9IFtcbiAgcHJlcHJvY2Vzc1doaXRlc3BhY2UsXG4gIHByZXByb2Nlc3NOb3Rpb24sXG4gIHByZXByb2Nlc3NXb3JkLFxuICBwcmVwcm9jZXNzR0RvY3MsXG4gIHByZXByb2Nlc3NIVE1MXG5dO1xuZnVuY3Rpb24gY3JlYXRlUnVsZU9wdGlvbnMoYmxvY2tDb250ZW50VHlwZSkge1xuICBjb25zdCBmZWF0dXJlcyA9IGJsb2NrQ29udGVudEZlYXR1cmVzKGJsb2NrQ29udGVudFR5cGUpLCBlbmFibGVkQmxvY2tTdHlsZXMgPSBmZWF0dXJlcy5zdHlsZXMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGVcbiAgKSwgZW5hYmxlZFNwYW5EZWNvcmF0b3JzID0gZmVhdHVyZXMuZGVjb3JhdG9ycy5tYXAoXG4gICAgKGl0ZW0pID0+IGl0ZW0udmFsdWUgfHwgaXRlbS50aXRsZVxuICApLCBlbmFibGVkQmxvY2tBbm5vdGF0aW9ucyA9IGZlYXR1cmVzLmFubm90YXRpb25zLm1hcChcbiAgICAoaXRlbSkgPT4gaXRlbS52YWx1ZSB8fCBpdGVtLnRpdGxlIHx8IFwiXCJcbiAgKSwgZW5hYmxlZExpc3RUeXBlcyA9IGZlYXR1cmVzLmxpc3RzLm1hcChcbiAgICAoaXRlbSkgPT4gaXRlbS52YWx1ZSB8fCBpdGVtLnRpdGxlIHx8IFwiXCJcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBlbmFibGVkQmxvY2tTdHlsZXMsXG4gICAgZW5hYmxlZFNwYW5EZWNvcmF0b3JzLFxuICAgIGVuYWJsZWRCbG9ja0Fubm90YXRpb25zLFxuICAgIGVuYWJsZWRMaXN0VHlwZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRhZ05hbWUoZWwpIHtcbiAgaWYgKGVsICYmIFwidGFnTmFtZVwiIGluIGVsKVxuICAgIHJldHVybiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwcmVwcm9jZXNzKGh0bWwsIHBhcnNlSHRtbCwgb3B0aW9ucykge1xuICBjb25zdCBjbGVhbkhUTUwgPSBPKGh0bWwpLCBkb2MgPSBwYXJzZUh0bWwobm9ybWFsaXplSHRtbEJlZm9yZVByZXByb2Nlc3MoY2xlYW5IVE1MKSk7XG4gIHJldHVybiBwcmVwcm9jZXNzb3JzLmZvckVhY2goKHByb2Nlc3NvcikgPT4ge1xuICAgIHByb2Nlc3NvcihjbGVhbkhUTUwsIGRvYywgb3B0aW9ucyk7XG4gIH0pLCBkb2M7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIdG1sQmVmb3JlUHJlcHJvY2VzcyhodG1sKSB7XG4gIHJldHVybiBodG1sLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzZUh0bWwoKSB7XG4gIGlmIChyZXNvbHZlSnNUeXBlKERPTVBhcnNlcikgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgbmF0aXZlIGBET01QYXJzZXJgIGdsb2JhbCB3aGljaCB0aGUgYEh0bWxgIGRlc2VyaWFsaXplciB1c2VzIGJ5IGRlZmF1bHQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBlbnZpcm9ubWVudC4gWW91IG11c3Qgc3VwcGx5IHRoZSBgb3B0aW9ucy5wYXJzZUh0bWxgIGZ1bmN0aW9uIGluc3RlYWQuXCJcbiAgICApO1xuICByZXR1cm4gKGh0bWwpID0+IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgXCJ0ZXh0L2h0bWxcIik7XG59XG5mdW5jdGlvbiBmbGF0dGVuTmVzdGVkQmxvY2tzKGJsb2NrczIpIHtcbiAgbGV0IGRlcHRoID0gMDtcbiAgY29uc3QgZmxhdHRlbmVkID0gW10sIHRyYXZlcnNlID0gKG5vZGVzKSA9PiB7XG4gICAgY29uc3QgdG9SZW1vdmUgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBkZXB0aCA9PT0gMCAmJiBmbGF0dGVuZWQucHVzaChub2RlKSwgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sobm9kZSkgJiYgKGRlcHRoID4gMCAmJiAodG9SZW1vdmUucHVzaChub2RlKSwgZmxhdHRlbmVkLnB1c2gobm9kZSkpLCBkZXB0aCsrLCB0cmF2ZXJzZShub2RlLmNoaWxkcmVuKSksIG5vZGUuX3R5cGUgPT09IFwiX19ibG9ja1wiICYmICh0b1JlbW92ZS5wdXNoKG5vZGUpLCBmbGF0dGVuZWQucHVzaChub2RlLmJsb2NrKSk7XG4gICAgfSksIHRvUmVtb3ZlLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGVzLnNwbGljZShub2Rlcy5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICB9KSwgZGVwdGgtLTtcbiAgfTtcbiAgcmV0dXJuIHRyYXZlcnNlKGJsb2NrczIpLCBmbGF0dGVuZWQ7XG59XG5mdW5jdGlvbiBuZXh0U3BhbihibG9jaywgaW5kZXgpIHtcbiAgY29uc3QgbmV4dCA9IGJsb2NrLmNoaWxkcmVuW2luZGV4ICsgMV07XG4gIHJldHVybiBuZXh0ICYmIG5leHQuX3R5cGUgPT09IFwic3BhblwiID8gbmV4dCA6IG51bGw7XG59XG5mdW5jdGlvbiBwcmV2U3BhbihibG9jaywgaW5kZXgpIHtcbiAgY29uc3QgcHJldiA9IGJsb2NrLmNoaWxkcmVuW2luZGV4IC0gMV07XG4gIHJldHVybiBwcmV2ICYmIHByZXYuX3R5cGUgPT09IFwic3BhblwiID8gcHJldiA6IG51bGw7XG59XG5mdW5jdGlvbiBpc1doaXRlU3BhY2VDaGFyKHRleHQpIHtcbiAgcmV0dXJuIFtcIlxceEEwXCIsIFwiIFwiXS5pbmNsdWRlcyh0ZXh0KTtcbn1cbmZ1bmN0aW9uIHRyaW1XaGl0ZXNwYWNlKGJsb2NrczIpIHtcbiAgcmV0dXJuIGJsb2NrczIuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTWluaW1hbFNwYW4oY2hpbGQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuZXh0Q2hpbGQgPSBuZXh0U3BhbihibG9jaywgaW5kZXgpLCBwcmV2Q2hpbGQgPSBwcmV2U3BhbihibG9jaywgaW5kZXgpO1xuICAgICAgaW5kZXggPT09IDAgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL15bXlxcU1xcbl0rL2csIFwiXCIpKSwgaW5kZXggPT09IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1teXFxTXFxuXSskL2csIFwiXCIpKSwgL1xccy8udGVzdChjaGlsZC50ZXh0LnNsaWNlKE1hdGgubWF4KDAsIGNoaWxkLnRleHQubGVuZ3RoIC0gMSkpKSAmJiBuZXh0Q2hpbGQgJiYgaXNNaW5pbWFsU3BhbihuZXh0Q2hpbGQpICYmIC9cXHMvLnRlc3QobmV4dENoaWxkLnRleHQuc2xpY2UoMCwgMSkpICYmIChjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9bXlxcU1xcbl0rJC9nLCBcIlwiKSksIC9cXHMvLnRlc3QoY2hpbGQudGV4dC5zbGljZSgwLCAxKSkgJiYgcHJldkNoaWxkICYmIGlzTWluaW1hbFNwYW4ocHJldkNoaWxkKSAmJiAvXFxzLy50ZXN0KHByZXZDaGlsZC50ZXh0LnNsaWNlKE1hdGgubWF4KDAsIHByZXZDaGlsZC50ZXh0Lmxlbmd0aCAtIDEpKSkgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL15bXlxcU1xcbl0rL2csIFwiXCIpKSwgY2hpbGQudGV4dCB8fCBibG9jay5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpLCBwcmV2Q2hpbGQgJiYgaXNFcXVhbChwcmV2Q2hpbGQubWFya3MsIGNoaWxkLm1hcmtzKSAmJiBpc1doaXRlU3BhY2VDaGFyKGNoaWxkLnRleHQpID8gKHByZXZDaGlsZC50ZXh0ICs9IFwiIFwiLCBibG9jay5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpKSA6IG5leHRDaGlsZCAmJiBpc0VxdWFsKG5leHRDaGlsZC5tYXJrcywgY2hpbGQubWFya3MpICYmIGlzV2hpdGVTcGFjZUNoYXIoY2hpbGQudGV4dCkgJiYgKG5leHRDaGlsZC50ZXh0ID0gYCAke25leHRDaGlsZC50ZXh0fWAsIGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpO1xuICAgIH0pO1xuICB9KSwgYmxvY2tzMjtcbn1cbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc0Jsb2NrcyhibG9ja3MyKSB7XG4gIHJldHVybiBibG9ja3MyLnJlZHVjZSgobWVtbywgbm9kZSwgaSwgb3JpZ2luYWwpID0+IHtcbiAgICBpZiAobm9kZS5fdHlwZSA9PT0gXCJibG9ja1wiKVxuICAgICAgcmV0dXJuIG1lbW8ucHVzaChub2RlKSwgbWVtbztcbiAgICBpZiAobm9kZS5fdHlwZSA9PT0gXCJfX2Jsb2NrXCIpXG4gICAgICByZXR1cm4gbWVtby5wdXNoKG5vZGUuYmxvY2spLCBtZW1vO1xuICAgIGNvbnN0IGxhc3RCbG9jayA9IG1lbW9bbWVtby5sZW5ndGggLSAxXTtcbiAgICBpZiAoaSA+IDAgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG9yaWdpbmFsW2kgLSAxXSkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sobGFzdEJsb2NrKSlcbiAgICAgIHJldHVybiBsYXN0QmxvY2suY2hpbGRyZW4ucHVzaChub2RlKSwgbWVtbztcbiAgICBjb25zdCBibG9jayA9IHtcbiAgICAgIC4uLkRFRkFVTFRfQkxPQ0ssXG4gICAgICBjaGlsZHJlbjogW25vZGVdXG4gICAgfTtcbiAgICByZXR1cm4gbWVtby5wdXNoKGJsb2NrKSwgbWVtbztcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdChub2RlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobm9kZSkgPT09IFwiW29iamVjdCBOb2RlTGlzdF1cIjtcbn1cbmZ1bmN0aW9uIGlzTWluaW1hbFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCI7XG59XG5mdW5jdGlvbiBpc01pbmltYWxCbG9jayhub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcImJsb2NrXCI7XG59XG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyRGVjb3JhdG9yKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiX19kZWNvcmF0b3JcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiX19hbm5vdGF0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVdoaXRlc3BhY2Uocm9vdE5vZGUpIHtcbiAgbGV0IGVtcHR5QmxvY2tDb3VudCA9IDAsIGxhc3RQYXJlbnQgPSBudWxsO1xuICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gIGZvciAobGV0IGNoaWxkID0gcm9vdE5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICBpZiAoIWlzRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2UoY2hpbGQpLCBlbXB0eUJsb2NrQ291bnQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsbSA9IGNoaWxkO1xuICAgIGlzV2hpdGVzcGFjZUJsb2NrKGVsbSkgPyAobGFzdFBhcmVudCAmJiBlbG0ucGFyZW50RWxlbWVudCA9PT0gbGFzdFBhcmVudCA/IChlbXB0eUJsb2NrQ291bnQrKywgZW1wdHlCbG9ja0NvdW50ID4gMSAmJiBub2Rlc1RvUmVtb3ZlLnB1c2goZWxtKSkgOiBlbXB0eUJsb2NrQ291bnQgPSAxLCBsYXN0UGFyZW50ID0gZWxtLnBhcmVudEVsZW1lbnQpIDogKG5vcm1hbGl6ZVdoaXRlc3BhY2UoY2hpbGQpLCBlbXB0eUJsb2NrQ291bnQgPSAwKTtcbiAgfVxuICBub2Rlc1RvUmVtb3ZlLmZvckVhY2goKG5vZGUpID0+IG5vZGUucGFyZW50RWxlbWVudD8ucmVtb3ZlQ2hpbGQobm9kZSkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsV2hpdGVzcGFjZShyb290Tm9kZSkge1xuICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gIGZ1bmN0aW9uIGNvbGxlY3ROb2Rlc1RvUmVtb3ZlKGN1cnJlbnROb2RlKSB7XG4gICAgaWYgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsbSA9IGN1cnJlbnROb2RlO1xuICAgICAgaWYgKHRhZ05hbWUoZWxtKSA9PT0gXCJiclwiICYmICh0YWdOYW1lKGVsbS5uZXh0RWxlbWVudFNpYmxpbmcpID09PSBcInBcIiB8fCB0YWdOYW1lKGVsbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSA9PT0gXCJwXCIpKSB7XG4gICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKHRhZ05hbWUoZWxtKSA9PT0gXCJwXCIgfHwgdGFnTmFtZShlbG0pID09PSBcImJyXCIpICYmIGVsbT8uZmlyc3RDaGlsZD8udGV4dENvbnRlbnQ/LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2goZWxtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgY2hpbGQgPSBlbG0uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpXG4gICAgICAgIGNvbGxlY3ROb2Rlc1RvUmVtb3ZlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgY29sbGVjdE5vZGVzVG9SZW1vdmUocm9vdE5vZGUpLCBub2Rlc1RvUmVtb3ZlLmZvckVhY2goKG5vZGUpID0+IG5vZGUucGFyZW50RWxlbWVudD8ucmVtb3ZlQ2hpbGQobm9kZSkpO1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlQmxvY2soZWxtKSB7XG4gIHJldHVybiBbXCJwXCIsIFwiYnJcIl0uaW5jbHVkZXModGFnTmFtZShlbG0pIHx8IFwiXCIpICYmICFlbG0udGV4dENvbnRlbnQ/LnRyaW0oKTtcbn1cbmNvbnN0IExJU1RfQ09OVEFJTkVSX1RBR1MgPSBPYmplY3Qua2V5cyhIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MpO1xuZnVuY3Rpb24gaXNFbXBoYXNpcyQxKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXN0eWxlXFxzKjpcXHMqaXRhbGljLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJvbmckMShlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvZm9udC13ZWlnaHRcXHMqOlxccyo3MDAvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1VuZGVybGluZSQxKGVsKSB7XG4gIGlmICghaXNFbGVtZW50KGVsKSB8fCB0YWdOYW1lKGVsLnBhcmVudE5vZGUpID09PSBcImFcIilcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC90ZXh0LWRlY29yYXRpb25cXHMqOlxccyp1bmRlcmxpbmUvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1N0cmlrZXRocm91Z2goZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvblxccyo6XFxzKig/Oi4qbGluZS10aHJvdWdoLio7KS8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzR29vZ2xlRG9jcyhlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiAhIWVsLmdldEF0dHJpYnV0ZShcImRhdGEtaXMtZ29vZ2xlLWRvY3NcIik7XG59XG5mdW5jdGlvbiBpc1Jvb3ROb2RlKGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmICEhZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pcy1yb290LW5vZGVcIik7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbVN0eWxlJDEoZWwpIHtcbiAgY29uc3QgcGFyZW50VGFnID0gdGFnTmFtZShlbC5wYXJlbnROb2RlKTtcbiAgaWYgKCEocGFyZW50VGFnICYmICFMSVNUX0NPTlRBSU5FUl9UQUdTLmluY2x1ZGVzKHBhcmVudFRhZykpKVxuICAgIHJldHVybiB0YWdOYW1lKGVsLnBhcmVudE5vZGUpID09PSBcInVsXCIgPyBcImJ1bGxldFwiIDogXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtTGV2ZWwkMShlbCkge1xuICBsZXQgbGV2ZWwgPSAwO1xuICBpZiAodGFnTmFtZShlbCkgPT09IFwibGlcIikge1xuICAgIGxldCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgcGFyZW50Tm9kZTsgKSB7XG4gICAgICBjb25zdCBwYXJlbnRUYWcgPSB0YWdOYW1lKHBhcmVudE5vZGUpO1xuICAgICAgcGFyZW50VGFnICYmIExJU1RfQ09OVEFJTkVSX1RBR1MuaW5jbHVkZXMocGFyZW50VGFnKSAmJiBsZXZlbCsrLCBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgbGV2ZWwgPSAxO1xuICByZXR1cm4gbGV2ZWw7XG59XG5jb25zdCBibG9ja3MgPSB7XG4gIC4uLkhUTUxfQkxPQ0tfVEFHUyxcbiAgLi4uSFRNTF9IRUFERVJfVEFHU1xufTtcbmZ1bmN0aW9uIGdldEJsb2NrU3R5bGUoZWwsIGVuYWJsZWRCbG9ja1N0eWxlcykge1xuICBjb25zdCBjaGlsZFRhZyA9IHRhZ05hbWUoZWwuZmlyc3RDaGlsZCksIGJsb2NrID0gY2hpbGRUYWcgJiYgYmxvY2tzW2NoaWxkVGFnXTtcbiAgcmV0dXJuIGJsb2NrICYmIGVuYWJsZWRCbG9ja1N0eWxlcy5pbmNsdWRlcyhibG9jay5zdHlsZSkgPyBibG9jay5zdHlsZSA6IEJMT0NLX0RFRkFVTFRfU1RZTEU7XG59XG5mdW5jdGlvbiBjcmVhdGVHRG9jc1J1bGVzKF9ibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudChlbCkgJiYgdGFnTmFtZShlbCkgPT09IFwic3BhblwiICYmIGlzR29vZ2xlRG9jcyhlbCkpIHtcbiAgICAgICAgICBjb25zdCBzcGFuID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgdGV4dDogZWwudGV4dENvbnRlbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpc1N0cm9uZyQxKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJzdHJvbmdcIiksIGlzVW5kZXJsaW5lJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInVuZGVybGluZVwiKSwgaXNTdHJpa2V0aHJvdWdoKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJzdHJpa2UtdGhyb3VnaFwiKSwgaXNFbXBoYXNpcyQxKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJlbVwiKSwgc3BhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImxpXCIgJiYgaXNHb29nbGVEb2NzKGVsKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICAgICAgICAgIGxpc3RJdGVtOiBnZXRMaXN0SXRlbVN0eWxlJDEoZWwpLFxuICAgICAgICAgICAgbGV2ZWw6IGdldExpc3RJdGVtTGV2ZWwkMShlbCksXG4gICAgICAgICAgICBzdHlsZTogZ2V0QmxvY2tTdHlsZShlbCwgb3B0aW9ucy5lbmFibGVkQmxvY2tTdHlsZXMpLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuZmlyc3RDaGlsZD8uY2hpbGROb2RlcyB8fCBbXSlcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIgJiYgaXNHb29nbGVEb2NzKGVsKSAmJiBpc0VsZW1lbnQoZWwpICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhcImFwcGxlLWludGVyY2hhbmdlLW5ld2xpbmVcIikpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIiAmJiBpc0dvb2dsZURvY3MoZWwpICYmIGlzRWxlbWVudChlbCkgJiYgZWw/LnBhcmVudE5vZGU/LnRleHRDb250ZW50ID09PSBcIlwiKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIgJiYgaXNHb29nbGVEb2NzKGVsKSAmJiBpc0VsZW1lbnQoZWwpICYmIGlzUm9vdE5vZGUoZWwpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBrZXlHZW5lcmF0b3IoKSB7XG4gIHJldHVybiByYW5kb21LZXkoMTIpO1xufVxuZnVuY3Rpb24gd2hhdHdnUk5HKGxlbmd0aCA9IDE2KSB7XG4gIGNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCksIHJuZHM4O1xufVxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKVxuICBieXRlVG9IZXhbaV0gPSAoaSArIDI1NikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuZnVuY3Rpb24gcmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gd2hhdHdnUk5HKGxlbmd0aCkucmVkdWNlKChzdHIsIG4pID0+IHN0ciArIGJ5dGVUb0hleFtuXSwgXCJcIikuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMaXN0SXRlbShsaXN0Tm9kZVRhZ05hbWUsIGVuYWJsZWRMaXN0VHlwZXMpIHtcbiAgaWYgKGxpc3ROb2RlVGFnTmFtZSA9PT0gXCJ1bFwiICYmIGVuYWJsZWRMaXN0VHlwZXMuaW5jbHVkZXMoXCJidWxsZXRcIikpXG4gICAgcmV0dXJuIFwiYnVsbGV0XCI7XG4gIGlmIChsaXN0Tm9kZVRhZ05hbWUgPT09IFwib2xcIiAmJiBlbmFibGVkTGlzdFR5cGVzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxuICAgIHJldHVybiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gY3JlYXRlSFRNTFJ1bGVzKF9ibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgLy8gVGV4dCBub2Rlc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJwcmVcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzVmFsaWRUZXh0ID0gKGVsLm5vZGVUeXBlID09PSAzICYmIChlbC50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikgPT09IFwiIFwiICYmIGVsLm5leHRTaWJsaW5nICYmIGVsLm5leHRTaWJsaW5nLm5vZGVUeXBlICE9PSAzICYmIGVsLnByZXZpb3VzU2libGluZyAmJiBlbC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGUgIT09IDMgfHwgZWwudGV4dENvbnRlbnQgIT09IFwiIFwiKSAmJiB0YWdOYW1lKGVsLnBhcmVudE5vZGUpICE9PSBcImJvZHlcIjtcbiAgICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSBcIiN0ZXh0XCIgJiYgaXNWYWxpZFRleHQpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIG1hcmtzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IChlbC50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBQcmUgZWxlbWVudFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsKSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gXCJwcmVcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlzQ29kZUVuYWJsZWQgPSBvcHRpb25zLmVuYWJsZWRCbG9ja1N0eWxlcy5pbmNsdWRlcyhcImNvZGVcIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgX3R5cGU6IFwiYmxvY2tcIixcbiAgICAgICAgICBzdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgICBtYXJrRGVmczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgICBtYXJrczogaXNDb2RlRW5hYmxlZCA/IFtcImNvZGVcIl0gOiBbXSxcbiAgICAgICAgICAgICAgdGV4dDogZWwudGV4dENvbnRlbnQgfHwgXCJcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJsb2NrcXVvdGUgZWxlbWVudFxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gXCJibG9ja3F1b3RlXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBibG9ja3MyID0ge1xuICAgICAgICAgIC4uLkhUTUxfQkxPQ0tfVEFHUyxcbiAgICAgICAgICAuLi5IVE1MX0hFQURFUl9UQUdTXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBibG9ja3MyLmJsb2NrcXVvdGU7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHJldHVybiBlbC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgT2JqZWN0LmtleXMoYmxvY2tzMikuaW5jbHVkZXMoXG4gICAgICAgICAgICBub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgaWYgKCFlbC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcclwiKSksIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjbikgPT4ge1xuICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGNuLmNsb25lTm9kZSghMCkpO1xuICAgICAgICAgICAgfSksIGluZGV4ICE9PSBlbC5jaGlsZE5vZGVzLmxlbmd0aCAmJiBzcGFuLmFwcGVuZENoaWxkKGVsLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXHJcIikpLCBjaGlsZHJlbi5wdXNoKHNwYW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfSksIHtcbiAgICAgICAgICBfdHlwZTogXCJibG9ja1wiLFxuICAgICAgICAgIHN0eWxlOiBcImJsb2NrcXVvdGVcIixcbiAgICAgICAgICBtYXJrRGVmczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IG5leHQoY2hpbGRyZW4pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBCbG9jayBlbGVtZW50c1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrczIgPSB7XG4gICAgICAgICAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAgICAgICAgIC4uLkhUTUxfSEVBREVSX1RBR1NcbiAgICAgICAgfSwgdGFnID0gdGFnTmFtZShlbCk7XG4gICAgICAgIGxldCBibG9jayA9IHRhZyA/IGJsb2NrczJbdGFnXSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgIHJldHVybiBlbC5wYXJlbnROb2RlICYmIHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgPT09IFwibGlcIiA/IG5leHQoZWwuY2hpbGROb2RlcykgOiAob3B0aW9ucy5lbmFibGVkQmxvY2tTdHlsZXMuaW5jbHVkZXMoYmxvY2suc3R5bGUpIHx8IChibG9jayA9IERFRkFVTFRfQkxPQ0spLCB7XG4gICAgICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBJZ25vcmUgc3BhbiB0YWdzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTmFtZShlbCk7XG4gICAgICAgIGlmICghKCF0YWcgfHwgISh0YWcgaW4gSFRNTF9TUEFOX1RBR1MpKSlcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBkaXYgdGFnc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJkaXZcIilcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBsaXN0IGNvbnRhaW5lcnNcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgaWYgKCEoIXRhZyB8fCAhKHRhZyBpbiBIVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MpKSlcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlYWwgd2l0aCBicidzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImJyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IGBcbmBcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGxpc3QgaXRlbXNcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCwgYmxvY2spIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTmFtZShlbCksIGxpc3RJdGVtID0gdGFnID8gSFRNTF9MSVNUX0lURU1fVEFHU1t0YWddIDogdm9pZCAwLCBwYXJlbnRUYWcgPSB0YWdOYW1lKGVsLnBhcmVudE5vZGUpIHx8IFwiXCI7XG4gICAgICAgIGlmICghbGlzdEl0ZW0gfHwgIWVsLnBhcmVudE5vZGUgfHwgIUhUTUxfTElTVF9DT05UQUlORVJfVEFHU1twYXJlbnRUYWddKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZW5hYmxlZExpc3RJdGVtID0gcmVzb2x2ZUxpc3RJdGVtKFxuICAgICAgICAgIHBhcmVudFRhZyxcbiAgICAgICAgICBvcHRpb25zLmVuYWJsZWRMaXN0VHlwZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWRMaXN0SXRlbSA/IChsaXN0SXRlbS5saXN0SXRlbSA9IGVuYWJsZWRMaXN0SXRlbSwge1xuICAgICAgICAgIC4uLmxpc3RJdGVtLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgIH0pIDogYmxvY2soeyBfdHlwZTogXCJibG9ja1wiLCBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlYWwgd2l0aCBkZWNvcmF0b3JzIC0gdGhpcyBpcyBhIGxpbWl0ZWQgc2V0IG9mIGtub3duIGh0bWwgZWxlbWVudHMgdGhhdCB3ZSBrbm93IGhvdyB0byBkZXNlcmlhbGl6ZVxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvciA9IEhUTUxfREVDT1JBVE9SX1RBR1NbdGFnTmFtZShlbCkgfHwgXCJcIl07XG4gICAgICAgIGlmICghKCFkZWNvcmF0b3IgfHwgIW9wdGlvbnMuZW5hYmxlZFNwYW5EZWNvcmF0b3JzLmluY2x1ZGVzKGRlY29yYXRvcikpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJfX2RlY29yYXRvclwiLFxuICAgICAgICAgICAgbmFtZTogZGVjb3JhdG9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBoeXBlcmxpbmtzLCBhZGQgYW5ub3RhdGlvbiAoaWYgYWxsb3dlZCBieSBzY2hlbWEpLFxuICAgIC8vIElmIG5vdCBzdXBwb3J0ZWQganVzdCB3cml0ZSBvdXQgdGhlIGxpbmsgdGV4dCBhbmQgaHJlZiBpbiBwbGFpbiB0ZXh0LlxuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSAhPT0gXCJhXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaW5rRW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZEJsb2NrQW5ub3RhdGlvbnMuaW5jbHVkZXMoXCJsaW5rXCIpLCBocmVmID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICBpZiAoIWhyZWYpXG4gICAgICAgICAgcmV0dXJuIG5leHQoZWwuY2hpbGROb2Rlcyk7XG4gICAgICAgIGxldCBtYXJrRGVmO1xuICAgICAgICByZXR1cm4gbGlua0VuYWJsZWQgPyAobWFya0RlZiA9IHtcbiAgICAgICAgICBfa2V5OiBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICBfdHlwZTogXCJsaW5rXCIsXG4gICAgICAgICAgaHJlZlxuICAgICAgICB9LCB7XG4gICAgICAgICAgX3R5cGU6IFwiX19hbm5vdGF0aW9uXCIsXG4gICAgICAgICAgbWFya0RlZixcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICB9KSA6IGVsLmFwcGVuZENoaWxkKGVsLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYCAoJHtocmVmfSlgKSkgJiYgbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBpc0VtcGhhc2lzKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXN0eWxlOml0YWxpYy8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3Ryb25nKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXdlaWdodDo3MDAvLnRlc3Qoc3R5bGUgfHwgXCJcIikgfHwgL2ZvbnQtd2VpZ2h0OjYwMC8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC90ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNOb3Rpb24oZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgISFlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLW5vdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlvblJ1bGVzKF9ibG9ja0NvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudChlbCkgJiYgdGFnTmFtZShlbCkgPT09IFwic3BhblwiICYmIGlzTm90aW9uKGVsKSkge1xuICAgICAgICAgIGNvbnN0IHNwYW4gPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICBtYXJrczogW10sXG4gICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGlzU3Ryb25nKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJzdHJvbmdcIiksIGlzVW5kZXJsaW5lKGVsKSAmJiBzcGFuLm1hcmtzLnB1c2goXCJ1bmRlcmxpbmVcIiksIGlzRW1waGFzaXMoZWwpICYmIHNwYW4ubWFya3MucHVzaChcImVtXCIpLCBzcGFuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1TdHlsZShlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIGlmIChzdHlsZSAmJiBzdHlsZS5tYXRjaCgvbGZvXFxkKy8pKVxuICAgIHJldHVybiBzdHlsZS5tYXRjaChcImxmbzFcIikgPyBcImJ1bGxldFwiIDogXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtTGV2ZWwoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBpZiAoIXN0eWxlKVxuICAgIHJldHVybjtcbiAgY29uc3QgbGV2ZWxNYXRjaCA9IHN0eWxlLm1hdGNoKC9sZXZlbFxcZCsvKTtcbiAgaWYgKCFsZXZlbE1hdGNoKVxuICAgIHJldHVybjtcbiAgY29uc3QgW2xldmVsXSA9IGxldmVsTWF0Y2hbMF0ubWF0Y2goL1xcZC8pIHx8IFtdO1xuICByZXR1cm4gKGxldmVsID8gTnVtYmVyLnBhcnNlSW50KGxldmVsLCAxMCkgOiAxKSB8fCAxO1xufVxuZnVuY3Rpb24gaXNXb3JkTGlzdEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgZWwuY2xhc3NOYW1lID8gZWwuY2xhc3NOYW1lID09PSBcIk1zb0xpc3RQYXJhZ3JhcGhDeFNwRmlyc3RcIiB8fCBlbC5jbGFzc05hbWUgPT09IFwiTXNvTGlzdFBhcmFncmFwaEN4U3BNaWRkbGVcIiB8fCBlbC5jbGFzc05hbWUgPT09IFwiTXNvTGlzdFBhcmFncmFwaEN4U3BMYXN0XCIgOiAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSdWxlcygpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwicFwiICYmIGlzV29yZExpc3RFbGVtZW50KGVsKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICAgICAgICAgIGxpc3RJdGVtOiBnZXRMaXN0SXRlbVN0eWxlKGVsKSxcbiAgICAgICAgICAgIGxldmVsOiBnZXRMaXN0SXRlbUxldmVsKGVsKSxcbiAgICAgICAgICAgIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGVzKGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5jcmVhdGVXb3JkUnVsZXMoKSxcbiAgICAuLi5jcmVhdGVOb3Rpb25SdWxlcygpLFxuICAgIC4uLmNyZWF0ZUdEb2NzUnVsZXMoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucyksXG4gICAgLi4uY3JlYXRlSFRNTFJ1bGVzKGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpXG4gIF07XG59XG5jbGFzcyBIdG1sRGVzZXJpYWxpemVyIHtcbiAgYmxvY2tDb250ZW50VHlwZTtcbiAgcnVsZXM7XG4gIHBhcnNlSHRtbDtcbiAgX21hcmtEZWZzID0gW107XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2VyaWFsaXplciByZXNwZWN0aW5nIGEgU2FuaXR5IGJsb2NrIGNvbnRlbnQgdHlwZSdzIHNjaGVtYVxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tDb250ZW50VHlwZSAtIFNjaGVtYSB0eXBlIGZvciBhcnJheSBjb250YWluaW5nIF9hdCBsZWFzdF8gYSBibG9jayBjaGlsZCB0eXBlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGRlc2VyaWFsaXphdGlvbiBwcm9jZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHJ1bGVzID0gW10sIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSA9IFwicHJlc2VydmVcIiB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWJsb2NrQ29udGVudFR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgJ2Jsb2NrQ29udGVudFR5cGUnIGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IHN0YW5kYXJkUnVsZXMgPSBjcmVhdGVSdWxlcyhibG9ja0NvbnRlbnRUeXBlLCB7XG4gICAgICAuLi5jcmVhdGVSdWxlT3B0aW9ucyhibG9ja0NvbnRlbnRUeXBlKSxcbiAgICAgIGtleUdlbmVyYXRvcjogb3B0aW9ucy5rZXlHZW5lcmF0b3JcbiAgICB9KTtcbiAgICB0aGlzLnJ1bGVzID0gWy4uLnJ1bGVzLCAuLi5zdGFuZGFyZFJ1bGVzXTtcbiAgICBjb25zdCBwYXJzZUh0bWwgPSBvcHRpb25zLnBhcnNlSHRtbCB8fCBkZWZhdWx0UGFyc2VIdG1sKCk7XG4gICAgdGhpcy5ibG9ja0NvbnRlbnRUeXBlID0gYmxvY2tDb250ZW50VHlwZSwgdGhpcy5wYXJzZUh0bWwgPSAoaHRtbCkgPT4gcHJlcHJvY2VzcyhodG1sLCBwYXJzZUh0bWwsIHsgdW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlIH0pLmJvZHk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIEhUTUwuXG4gICAqXG4gICAqIEBwYXJhbSBodG1sIC0gVGhlIEhUTUwgdG8gZGVzZXJpYWxpemUsIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGJsb2NrcyAtIGVpdGhlciBwb3J0YWJsZSB0ZXh0IGJsb2NrcyBvciBvdGhlciBhbGxvd2VkIGJsb2Nrc1xuICAgKi9cbiAgZGVzZXJpYWxpemUgPSAoaHRtbCkgPT4ge1xuICAgIHRoaXMuX21hcmtEZWZzID0gW107XG4gICAgY29uc3QgeyBwYXJzZUh0bWwgfSA9IHRoaXMsIGZyYWdtZW50ID0gcGFyc2VIdG1sKGh0bWwpLCBjaGlsZHJlbiA9IEFycmF5LmZyb20oZnJhZ21lbnQuY2hpbGROb2RlcyksIGJsb2NrczIgPSB0cmltV2hpdGVzcGFjZShcbiAgICAgIGZsYXR0ZW5OZXN0ZWRCbG9ja3MoXG4gICAgICAgIGVuc3VyZVJvb3RJc0Jsb2Nrcyh0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoY2hpbGRyZW4pKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5fbWFya0RlZnMubGVuZ3RoID4gMCAmJiBibG9ja3MyLmZpbHRlcihcbiAgICAgIChibG9jaykgPT4gYmxvY2suX3R5cGUgPT09IFwiYmxvY2tcIlxuICAgICkuZm9yRWFjaCgoYmxvY2spID0+IHtcbiAgICAgIGJsb2NrLm1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgfHwgW10sIGJsb2NrLm1hcmtEZWZzID0gYmxvY2subWFya0RlZnMuY29uY2F0KFxuICAgICAgICB0aGlzLl9tYXJrRGVmcy5maWx0ZXIoKGRlZikgPT4gZmxhdHRlbihcbiAgICAgICAgICBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5tYXJrcyB8fCBbXSlcbiAgICAgICAgKS5pbmNsdWRlcyhkZWYuX2tleSkpXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmJsb2NrQ29udGVudFR5cGUub2YuZmluZChmaW5kQmxvY2tUeXBlKTtcbiAgICByZXR1cm4gdHlwZSA/IGJsb2NrczIubWFwKChibG9jaykgPT4gKGJsb2NrLl90eXBlID09PSBcImJsb2NrXCIgJiYgKGJsb2NrLl90eXBlID0gdHlwZS5uYW1lKSwgYmxvY2spKSA6IGJsb2NrczI7XG4gIH07XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhbiBhcnJheSBvZiBET00gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50cyAtIEFycmF5IG9mIERPTSBlbGVtZW50cyB0byBkZXNlcmlhbGl6ZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZGVzZXJpYWxpemVFbGVtZW50cyA9IChlbGVtZW50cyA9IFtdKSA9PiB7XG4gICAgbGV0IG5vZGVzID0gW107XG4gICAgcmV0dXJuIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KHRoaXMuZGVzZXJpYWxpemVFbGVtZW50KGVsZW1lbnQpKTtcbiAgICB9KSwgbm9kZXM7XG4gIH07XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gRGVzZXJpYWxpemUgYSBET00gZWxlbWVudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZGVzZXJpYWxpemVFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBuZXh0ID0gKGVsZW1lbnRzKSA9PiB7XG4gICAgICBpZiAoaXNOb2RlTGlzdChlbGVtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoQXJyYXkuZnJvbShlbGVtZW50cykpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcbiAgICAgIGlmIChlbGVtZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50KGVsZW1lbnRzKTtcbiAgICB9LCBibG9jayA9IChwcm9wcykgPT4gKHtcbiAgICAgIF90eXBlOiBcIl9fYmxvY2tcIixcbiAgICAgIGJsb2NrOiBwcm9wc1xuICAgIH0pO1xuICAgIGxldCBub2RlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcnVsZSA9IHRoaXMucnVsZXNbaV07XG4gICAgICBpZiAoIXJ1bGUuZGVzZXJpYWxpemUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcmV0ID0gcnVsZS5kZXNlcmlhbGl6ZShlbGVtZW50LCBuZXh0LCBibG9jayksIHR5cGUgPSByZXNvbHZlSnNUeXBlKHJldCk7XG4gICAgICBpZiAodHlwZSAhPT0gXCJhcnJheVwiICYmIHR5cGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gXCJudWxsXCIgJiYgdHlwZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBIHJ1bGUgcmV0dXJuZWQgYW4gaW52YWxpZCBkZXNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb246IFwiJHtub2RlfVwiLmBcbiAgICAgICAgKTtcbiAgICAgIGlmIChyZXQgIT09IHZvaWQgMCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHJldCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlc2VyaWFsaXplciBydWxlIHJldHVybmVkIGBudWxsYFwiKTtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHJldCkgPyBub2RlID0gcmV0IDogaXNQbGFjZWhvbGRlckRlY29yYXRvcihyZXQpID8gbm9kZSA9IHRoaXMuZGVzZXJpYWxpemVEZWNvcmF0b3IocmV0KSA6IGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKHJldCkgPyBub2RlID0gdGhpcy5kZXNlcmlhbGl6ZUFubm90YXRpb24ocmV0KSA6IG5vZGUgPSByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCAmJiAhQXJyYXkuaXNBcnJheShyZXQpICYmIGlzTWluaW1hbEJsb2NrKHJldCkgJiYgXCJsaXN0SXRlbVwiIGluIHJldCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU/LnBhcmVudE5vZGU7XG4gICAgICAgICAgZm9yICg7IHBhcmVudCAmJiB0YWdOYW1lKHBhcmVudCkgPT09IFwibGlcIjsgKVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU/LnBhcmVudE5vZGUsIHJldC5sZXZlbCA9IHJldC5sZXZlbCA/IHJldC5sZXZlbCArIDEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldCAmJiAhQXJyYXkuaXNBcnJheShyZXQpICYmIGlzTWluaW1hbEJsb2NrKHJldCkgJiYgcmV0LnN0eWxlID09PSBcImJsb2NrcXVvdGVcIiAmJiByZXQuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaXNNaW5pbWFsU3BhbihjaGlsZCkgJiYgY2hpbGQudGV4dCA9PT0gXCJcXHJcIiAmJiAoY2hpbGQudGV4dCA9IGBcblxuYCwgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSByZXQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgJiYgcmV0LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlIHx8IG5leHQoZWxlbWVudC5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgYF9fZGVjb3JhdG9yYCB0eXBlXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBkZWNvcmF0b3JzIGV4Y2x1c2l2ZWx5KVxuICAgKlxuICAgKiBAcGFyYW0gZGVjb3JhdG9yIC1cbiAgICogQHJldHVybnMgYXJyYXkgb2YgLi4uXG4gICAqL1xuICBkZXNlcmlhbGl6ZURlY29yYXRvciA9IChkZWNvcmF0b3IpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGRlY29yYXRvciwgYXBwbHlEZWNvcmF0b3IgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGVjb3JhdG9yKG5vZGUpO1xuICAgICAgaWYgKGlzTWluaW1hbFNwYW4obm9kZSkpXG4gICAgICAgIG5vZGUubWFya3MgPSBub2RlLm1hcmtzIHx8IFtdLCBub2RlLnRleHQudHJpbSgpICYmIG5vZGUubWFya3MudW5zaGlmdChuYW1lKTtcbiAgICAgIGVsc2UgaWYgKFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcChhcHBseURlY29yYXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBkZWNvcmF0b3IuY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlEZWNvcmF0b3Iobm9kZSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXQpID8gY2hpbGRyZW4uY29uY2F0KHJldCkgOiAoY2hpbGRyZW4ucHVzaChyZXQpLCBjaGlsZHJlbik7XG4gICAgfSwgW10pO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBgX19hbm5vdGF0aW9uYCBvYmplY3QuXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBhbm5vdGF0aW9ucyBleGNsdXNpdmVseSlcbiAgICpcbiAgICogQHBhcmFtIGFubm90YXRpb24gLVxuICAgKiBAcmV0dXJucyBBcnJheSBvZi4uLlxuICAgKi9cbiAgZGVzZXJpYWxpemVBbm5vdGF0aW9uID0gKGFubm90YXRpb24pID0+IHtcbiAgICBjb25zdCB7IG1hcmtEZWYgfSA9IGFubm90YXRpb247XG4gICAgdGhpcy5fbWFya0RlZnMucHVzaChtYXJrRGVmKTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKG5vZGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUFubm90YXRpb24obm9kZSk7XG4gICAgICBpZiAoaXNNaW5pbWFsU3Bhbihub2RlKSlcbiAgICAgICAgbm9kZS5tYXJrcyA9IG5vZGUubWFya3MgfHwgW10sIG5vZGUudGV4dC50cmltKCkgJiYgbm9kZS5tYXJrcy51bnNoaWZ0KG1hcmtEZWYuX2tleSk7XG4gICAgICBlbHNlIGlmIChcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoYXBwbHlBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIGFubm90YXRpb24uY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmV0KSA/IGNoaWxkcmVuLmNvbmNhdChyZXQpIDogKGNoaWxkcmVuLnB1c2gocmV0KSwgY2hpbGRyZW4pO1xuICAgIH0sIFtdKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsb2NrKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobm9kZS5fdHlwZSAhPT0gKG9wdGlvbnMuYmxvY2tUeXBlTmFtZSB8fCBcImJsb2NrXCIpKVxuICAgIHJldHVybiBcIl9rZXlcIiBpbiBub2RlID8gbm9kZSA6IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgICBfa2V5OiBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKVxuICAgIH07XG4gIGNvbnN0IGJsb2NrID0ge1xuICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBtYXJrRGVmczogW10sXG4gICAgLi4ubm9kZVxuICB9LCBsYXN0Q2hpbGQgPSBibG9jay5jaGlsZHJlbltibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKCFsYXN0Q2hpbGQpXG4gICAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1cbiAgICBdLCBibG9jaztcbiAgY29uc3QgdXNlZE1hcmtEZWZzID0gW10sIGFsbG93ZWREZWNvcmF0b3JzID0gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxsb3dlZERlY29yYXRvcnMpID8gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyA6ICExO1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5yZWR1Y2UoXG4gICAgKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHByZXZpb3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ocHJldmlvdXNDaGlsZCkgJiYgaXNFcXVhbChwcmV2aW91c0NoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgPyAobGFzdENoaWxkICYmIGxhc3RDaGlsZCA9PT0gY2hpbGQgJiYgY2hpbGQudGV4dCA9PT0gXCJcIiAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IChwcmV2aW91c0NoaWxkLnRleHQgKz0gY2hpbGQudGV4dCksIGFjYykgOiAoYWNjLnB1c2goY2hpbGQpLCBhY2MpO1xuICAgIH0sXG4gICAgW11cbiAgKS5tYXAoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFjaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hpbGRcIik7XG4gICAgcmV0dXJuIGNoaWxkLl9rZXkgPSBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKSwgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiAoY2hpbGQubWFya3MgPyBhbGxvd2VkRGVjb3JhdG9ycyAmJiAoY2hpbGQubWFya3MgPSBjaGlsZC5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWREZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspLCBpc1VzZWQgPSBibG9jay5tYXJrRGVmcz8uc29tZSgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyayk7XG4gICAgICByZXR1cm4gaXNBbGxvd2VkIHx8IGlzVXNlZDtcbiAgICB9KSkgOiBjaGlsZC5tYXJrcyA9IFtdLCB1c2VkTWFya0RlZnMucHVzaCguLi5jaGlsZC5tYXJrcykpLCBjaGlsZDtcbiAgfSksIGJsb2NrLm1hcmtEZWZzID0gKGJsb2NrLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoXG4gICAgKG1hcmtEZWYpID0+IHVzZWRNYXJrRGVmcy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpXG4gICksIGJsb2NrO1xufVxuZnVuY3Rpb24gaHRtbFRvQmxvY2tzKGh0bWwsIGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbmV3IEh0bWxEZXNlcmlhbGl6ZXIoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykuZGVzZXJpYWxpemUoaHRtbCkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHsga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvciB9KSk7XG59XG5mdW5jdGlvbiBnZXRCbG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBibG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKTtcbn1cbmV4cG9ydCB7XG4gIGdldEJsb2NrQ29udGVudEZlYXR1cmVzLFxuICBodG1sVG9CbG9ja3MsXG4gIG5vcm1hbGl6ZUJsb2NrLFxuICByYW5kb21LZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coreBehavior: () => (/* binding */ coreBehavior),\n/* harmony export */   coreBehaviors: () => (/* binding */ coreBehaviors),\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   isCustomBehaviorEvent: () => (/* binding */ isCustomBehaviorEvent),\n/* harmony export */   isHotkey: () => (/* binding */ isHotkey),\n/* harmony export */   raise: () => (/* binding */ raise)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selector.is-selection-collapsed.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\");\n/* harmony import */ var _util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.is-empty-text-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\");\n\n\n\nconst IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {\n  alt: \"altKey\",\n  control: \"ctrlKey\",\n  meta: \"metaKey\",\n  shift: \"shiftKey\"\n}, aliases = {\n  add: \"+\",\n  break: \"pause\",\n  cmd: \"meta\",\n  command: \"meta\",\n  ctl: \"control\",\n  ctrl: \"control\",\n  del: \"delete\",\n  down: \"arrowdown\",\n  esc: \"escape\",\n  ins: \"insert\",\n  left: \"arrowleft\",\n  mod: IS_MAC ? \"meta\" : \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  return: \"enter\",\n  right: \"arrowright\",\n  space: \" \",\n  spacebar: \" \",\n  up: \"arrowup\",\n  win: \"meta\",\n  windows: \"meta\"\n}, keyCodes = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  \" \": 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  \";\": 186,\n  \"=\": 187,\n  \",\": 188,\n  \"-\": 189,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"[\": 219,\n  \"\\\\\": 220,\n  \"]\": 221,\n  \"'\": 222,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  f13: 124,\n  f14: 125,\n  f15: 126,\n  f16: 127,\n  f17: 128,\n  f18: 129,\n  f19: 130,\n  f20: 131\n};\nfunction isHotkey(hotkey, event) {\n  return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n  const parsedHotkey = {\n    altKey: !1,\n    ctrlKey: !1,\n    metaKey: !1,\n    shiftKey: !1\n  }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];\n    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n  }\n  return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n  const keyName = toKeyName(name);\n  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n  const keyName = name.toLowerCase();\n  return aliases[keyName] ?? keyName;\n}\nfunction isCustomBehaviorEvent(event) {\n  return event.type.startsWith(\"custom.\");\n}\nfunction raise(event) {\n  return {\n    type: \"raise\",\n    event\n  };\n}\nfunction defineBehavior(behavior) {\n  return behavior;\n}\nconst arrowDownOnLonelyBlockObject = {\n  on: \"key.down\",\n  guard: ({\n    context,\n    event\n  }) => {\n    const isArrowDown = isHotkey(\"ArrowDown\", event.keyboardEvent), focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)({\n      context\n    }), nextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getNextBlock)({\n      context\n    });\n    return isArrowDown && focusBlockObject && !nextBlock;\n  },\n  actions: [() => [{\n    type: \"insert.text block\",\n    placement: \"after\"\n  }]]\n}, arrowUpOnLonelyBlockObject = {\n  on: \"key.down\",\n  guard: ({\n    context,\n    event\n  }) => {\n    const isArrowUp = isHotkey(\"ArrowUp\", event.keyboardEvent), focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)({\n      context\n    }), previousBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousBlock)({\n      context\n    });\n    return isArrowUp && focusBlockObject && !previousBlock;\n  },\n  actions: [() => [{\n    type: \"insert.text block\",\n    placement: \"before\"\n  }, {\n    type: \"select.previous block\"\n  }]]\n}, breakingBlockObject = {\n  on: \"insert.break\",\n  guard: ({\n    context\n  }) => {\n    const focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusBlockObject)({\n      context\n    });\n    return (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }) && focusBlockObject !== void 0;\n  },\n  actions: [() => [{\n    type: \"insert.text block\",\n    placement: \"after\"\n  }]]\n}, deletingEmptyTextBlockAfterBlockObject = {\n  on: \"delete.backward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)({\n      context\n    }), selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }), previousBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getPreviousBlock)({\n      context\n    });\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextTextBlock)(previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [{\n    type: \"delete.block\",\n    blockPath: focusTextBlock.path\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, deletingEmptyTextBlockBeforeBlockObject = {\n  on: \"delete.forward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)({\n      context\n    }), selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }), nextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getNextBlock)({\n      context\n    });\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : (0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextTextBlock)(nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [{\n    type: \"delete.block\",\n    blockPath: focusTextBlock.path\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, coreBlockObjectBehaviors = {\n  arrowDownOnLonelyBlockObject,\n  arrowUpOnLonelyBlockObject,\n  breakingBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject\n}, coreDecoratorBehaviors = {\n  strongShortcut: {\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => isHotkey(\"mod+b\", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === \"strong\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"strong\"\n    })]]\n  },\n  emShortcut: {\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => isHotkey(\"mod+i\", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === \"em\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"em\"\n    })]]\n  },\n  underlineShortcut: {\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => isHotkey(\"mod+u\", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === \"underline\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"underline\"\n    })]]\n  },\n  codeShortcut: {\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => isHotkey(\"mod+'\", event.keyboardEvent) && context.schema.decorators.some((decorator) => decorator.value === \"code\"),\n    actions: [() => [raise({\n      type: \"decorator.toggle\",\n      decorator: \"code\"\n    })]]\n  }\n}, MAX_LIST_LEVEL = 10, clearListOnBackspace = {\n  on: \"delete.backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }), focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)({\n      context\n    }), focusSpan = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)({\n      context\n    });\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [{\n    type: \"text block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusTextBlock.path\n  }]]\n}, unindentListOnBackspace = {\n  on: \"delete.backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }), focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusTextBlock)({\n      context\n    }), focusSpan = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusSpan)({\n      context\n    });\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [{\n    type: \"text block.set\",\n    level,\n    at: focusTextBlock.path\n  }]]\n}, clearListOnEnter = {\n  on: \"insert.break\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.isSelectionCollapsed)({\n      context\n    }), focusListBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getFocusListBlock)({\n      context\n    });\n    return !selectionCollapsed || !focusListBlock || !(0,_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyTextBlock)(focusListBlock.node) ? !1 : {\n      focusListBlock\n    };\n  },\n  actions: [(_, {\n    focusListBlock\n  }) => [{\n    type: \"text block.unset\",\n    props: [\"listItem\", \"level\"],\n    at: focusListBlock.path\n  }]]\n}, indentListOnTab = {\n  on: \"key.down\",\n  guard: ({\n    context,\n    event\n  }) => {\n    if (!isHotkey(\"Tab\", event.keyboardEvent))\n      return !1;\n    const selectedBlocks = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getSelectedBlocks)({\n      context\n    }), guards = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.createGuards)(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => ({\n    type: \"text block.set\",\n    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1)),\n    at: selectedListBlock.path\n  }))]\n}, unindentListOnShiftTab = {\n  on: \"key.down\",\n  guard: ({\n    context,\n    event\n  }) => {\n    if (!isHotkey(\"Shift+Tab\", event.keyboardEvent))\n      return !1;\n    const selectedBlocks = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.getSelectedBlocks)({\n      context\n    }), guards = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_0__.createGuards)(context), selectedListBlocks = selectedBlocks.flatMap((block) => guards.isListBlock(block.node) ? [{\n      node: block.node,\n      path: block.path\n    }] : []);\n    return selectedListBlocks.length === selectedBlocks.length ? {\n      selectedListBlocks\n    } : !1;\n  },\n  actions: [(_, {\n    selectedListBlocks\n  }) => selectedListBlocks.map((selectedListBlock) => ({\n    type: \"text block.set\",\n    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1)),\n    at: selectedListBlock.path\n  }))]\n}, coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace,\n  clearListOnEnter,\n  indentListOnTab,\n  unindentListOnShiftTab\n}, softReturn = {\n  on: \"insert.soft break\",\n  actions: [() => [{\n    type: \"insert.text\",\n    text: `\n`\n  }]]\n}, coreBehaviors = [softReturn, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab], coreBehavior = {\n  softReturn,\n  decorators: coreDecoratorBehaviors,\n  blockObjects: coreBlockObjectBehaviors,\n  lists: coreListBehaviors\n};\n\n//# sourceMappingURL=behavior.core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvYmVoYXZpb3IuY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDOEo7QUFDcko7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVGQUF1Rix3RkFBbUI7QUFDMUc7QUFDQSxLQUFLLGVBQWUsaUZBQVk7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxH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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkIsc0ZBQWlCO0FBQzVDO0FBQ0EsS0FBSyxZQUFZLGlGQUFZO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkIsc0ZBQWlCO0FBQzVDO0FBQ0EsS0FBSyxZQUFZLGlGQUFZO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanM/MTZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRGb2N1c0Jsb2NrT2JqZWN0LCBnZXROZXh0QmxvY2ssIGdldFByZXZpb3VzQmxvY2ssIGlzU2VsZWN0aW9uQ29sbGFwc2VkLCBnZXRGb2N1c1RleHRCbG9jaywgZ2V0Rm9jdXNTcGFuLCBnZXRGb2N1c0xpc3RCbG9jaywgZ2V0U2VsZWN0ZWRCbG9ja3MsIGNyZWF0ZUd1YXJkcyB9IGZyb20gXCIuL3NlbGVjdG9yLmlzLXNlbGVjdGlvbi1jb2xsYXBzZWQuanNcIjtcbmltcG9ydCB7IGlzRW1wdHlUZXh0QmxvY2sgfSBmcm9tIFwiLi91dGlsLmlzLWVtcHR5LXRleHQtYmxvY2suanNcIjtcbmNvbnN0IElTX01BQyA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLCBtb2RpZmllcnMgPSB7XG4gIGFsdDogXCJhbHRLZXlcIixcbiAgY29udHJvbDogXCJjdHJsS2V5XCIsXG4gIG1ldGE6IFwibWV0YUtleVwiLFxuICBzaGlmdDogXCJzaGlmdEtleVwiXG59LCBhbGlhc2VzID0ge1xuICBhZGQ6IFwiK1wiLFxuICBicmVhazogXCJwYXVzZVwiLFxuICBjbWQ6IFwibWV0YVwiLFxuICBjb21tYW5kOiBcIm1ldGFcIixcbiAgY3RsOiBcImNvbnRyb2xcIixcbiAgY3RybDogXCJjb250cm9sXCIsXG4gIGRlbDogXCJkZWxldGVcIixcbiAgZG93bjogXCJhcnJvd2Rvd25cIixcbiAgZXNjOiBcImVzY2FwZVwiLFxuICBpbnM6IFwiaW5zZXJ0XCIsXG4gIGxlZnQ6IFwiYXJyb3dsZWZ0XCIsXG4gIG1vZDogSVNfTUFDID8gXCJtZXRhXCIgOiBcImNvbnRyb2xcIixcbiAgb3B0OiBcImFsdFwiLFxuICBvcHRpb246IFwiYWx0XCIsXG4gIHJldHVybjogXCJlbnRlclwiLFxuICByaWdodDogXCJhcnJvd3JpZ2h0XCIsXG4gIHNwYWNlOiBcIiBcIixcbiAgc3BhY2ViYXI6IFwiIFwiLFxuICB1cDogXCJhcnJvd3VwXCIsXG4gIHdpbjogXCJtZXRhXCIsXG4gIHdpbmRvd3M6IFwibWV0YVwiXG59LCBrZXlDb2RlcyA9IHtcbiAgYmFja3NwYWNlOiA4LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc2hpZnQ6IDE2LFxuICBjb250cm9sOiAxNyxcbiAgYWx0OiAxOCxcbiAgcGF1c2U6IDE5LFxuICBjYXBzbG9jazogMjAsXG4gIGVzY2FwZTogMjcsXG4gIFwiIFwiOiAzMixcbiAgcGFnZXVwOiAzMyxcbiAgcGFnZWRvd246IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3d1cDogMzgsXG4gIGFycm93cmlnaHQ6IDM5LFxuICBhcnJvd2Rvd246IDQwLFxuICBpbnNlcnQ6IDQ1LFxuICBkZWxldGU6IDQ2LFxuICBtZXRhOiA5MSxcbiAgbnVtbG9jazogMTQ0LFxuICBzY3JvbGxsb2NrOiAxNDUsXG4gIFwiO1wiOiAxODYsXG4gIFwiPVwiOiAxODcsXG4gIFwiLFwiOiAxODgsXG4gIFwiLVwiOiAxODksXG4gIFwiLlwiOiAxOTAsXG4gIFwiL1wiOiAxOTEsXG4gIFwiYFwiOiAxOTIsXG4gIFwiW1wiOiAyMTksXG4gIFwiXFxcXFwiOiAyMjAsXG4gIFwiXVwiOiAyMjEsXG4gIFwiJ1wiOiAyMjIsXG4gIGYxOiAxMTIsXG4gIGYyOiAxMTMsXG4gIGYzOiAxMTQsXG4gIGY0OiAxMTUsXG4gIGY1OiAxMTYsXG4gIGY2OiAxMTcsXG4gIGY3OiAxMTgsXG4gIGY4OiAxMTksXG4gIGY5OiAxMjAsXG4gIGYxMDogMTIxLFxuICBmMTE6IDEyMixcbiAgZjEyOiAxMjMsXG4gIGYxMzogMTI0LFxuICBmMTQ6IDEyNSxcbiAgZjE1OiAxMjYsXG4gIGYxNjogMTI3LFxuICBmMTc6IDEyOCxcbiAgZjE4OiAxMjksXG4gIGYxOTogMTMwLFxuICBmMjA6IDEzMVxufTtcbmZ1bmN0aW9uIGlzSG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGNvbXBhcmVIb3RrZXkocGFyc2VIb3RrZXkoaG90a2V5KSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gcGFyc2VIb3RrZXkoaG90a2V5KSB7XG4gIGNvbnN0IHBhcnNlZEhvdGtleSA9IHtcbiAgICBhbHRLZXk6ICExLFxuICAgIGN0cmxLZXk6ICExLFxuICAgIG1ldGFLZXk6ICExLFxuICAgIHNoaWZ0S2V5OiAhMVxuICB9LCBob3RrZXlTZWdtZW50cyA9IGhvdGtleS5yZXBsYWNlKFwiKytcIiwgXCIrYWRkXCIpLnNwbGl0KFwiK1wiKTtcbiAgZm9yIChjb25zdCByYXdIb3RrZXlTZWdtZW50IG9mIGhvdGtleVNlZ21lbnRzKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSByYXdIb3RrZXlTZWdtZW50LmVuZHNXaXRoKFwiP1wiKSAmJiByYXdIb3RrZXlTZWdtZW50Lmxlbmd0aCA+IDEsIGhvdGtleVNlZ21lbnQgPSBvcHRpb25hbCA/IHJhd0hvdGtleVNlZ21lbnQuc2xpY2UoMCwgLTEpIDogcmF3SG90a2V5U2VnbWVudCwga2V5TmFtZSA9IHRvS2V5TmFtZShob3RrZXlTZWdtZW50KSwgbW9kaWZpZXIgPSBtb2RpZmllcnNba2V5TmFtZV0sIGFsaWFzID0gYWxpYXNlc1tob3RrZXlTZWdtZW50XSwgY29kZSA9IGtleUNvZGVzW2tleU5hbWVdO1xuICAgIGlmIChob3RrZXlTZWdtZW50Lmxlbmd0aCA+IDEgJiYgbW9kaWZpZXIgPT09IHZvaWQgMCAmJiBhbGlhcyA9PT0gdm9pZCAwICYmIGNvZGUgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gbW9kaWZpZXI6IFwiJHtob3RrZXlTZWdtZW50fVwiYCk7XG4gICAgKGhvdGtleVNlZ21lbnRzLmxlbmd0aCA9PT0gMSB8fCBtb2RpZmllciA9PT0gdm9pZCAwKSAmJiAocGFyc2VkSG90a2V5LmtleSA9IGtleU5hbWUsIHBhcnNlZEhvdGtleS5rZXlDb2RlID0gdG9LZXlDb2RlKGhvdGtleVNlZ21lbnQpKSwgbW9kaWZpZXIgIT09IHZvaWQgMCAmJiAocGFyc2VkSG90a2V5W21vZGlmaWVyXSA9IG9wdGlvbmFsID8gbnVsbCA6ICEwKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkSG90a2V5O1xufVxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShwYXJzZWRIb3RrZXksIGV2ZW50KSB7XG4gIHJldHVybiAocGFyc2VkSG90a2V5LmFsdEtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5hbHRLZXkgPT09IGV2ZW50LmFsdEtleSkgJiYgKHBhcnNlZEhvdGtleS5jdHJsS2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LmN0cmxLZXkgPT09IGV2ZW50LmN0cmxLZXkpICYmIChwYXJzZWRIb3RrZXkubWV0YUtleSA9PSBudWxsIHx8IHBhcnNlZEhvdGtleS5tZXRhS2V5ID09PSBldmVudC5tZXRhS2V5KSAmJiAocGFyc2VkSG90a2V5LnNoaWZ0S2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LnNoaWZ0S2V5ID09PSBldmVudC5zaGlmdEtleSkgPyBwYXJzZWRIb3RrZXkua2V5Q29kZSAhPT0gdm9pZCAwICYmIGV2ZW50LmtleUNvZGUgIT09IHZvaWQgMCA/IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSA5MSAmJiBldmVudC5rZXlDb2RlID09PSA5MyA/ICEwIDogcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgOiBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSB8fCBwYXJzZWRIb3RrZXkua2V5ID09PSBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA6ICExO1xufVxuZnVuY3Rpb24gdG9LZXlDb2RlKG5hbWUpIHtcbiAgY29uc3Qga2V5TmFtZSA9IHRvS2V5TmFtZShuYW1lKTtcbiAgcmV0dXJuIGtleUNvZGVzW2tleU5hbWVdID8/IGtleU5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xufVxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgY29uc3Qga2V5TmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGFsaWFzZXNba2V5TmFtZV0gPz8ga2V5TmFtZTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmVoYXZpb3JFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwiY3VzdG9tLlwiKTtcbn1cbmZ1bmN0aW9uIHJhaXNlKGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJyYWlzZVwiLFxuICAgIGV2ZW50XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVCZWhhdmlvcihiZWhhdmlvcikge1xuICByZXR1cm4gYmVoYXZpb3I7XG59XG5jb25zdCBhcnJvd0Rvd25PbkxvbmVseUJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBpc0Fycm93RG93biA9IGlzSG90a2V5KFwiQXJyb3dEb3duXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpLCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdCh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIG5leHRCbG9jayA9IGdldE5leHRCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQXJyb3dEb3duICYmIGZvY3VzQmxvY2tPYmplY3QgJiYgIW5leHRCbG9jaztcbiAgfSxcbiAgYWN0aW9uczogWygpID0+IFt7XG4gICAgdHlwZTogXCJpbnNlcnQudGV4dCBibG9ja1wiLFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gIH1dXVxufSwgYXJyb3dVcE9uTG9uZWx5QmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImtleS5kb3duXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGlzQXJyb3dVcCA9IGlzSG90a2V5KFwiQXJyb3dVcFwiLCBldmVudC5rZXlib2FyZEV2ZW50KSwgZm9jdXNCbG9ja09iamVjdCA9IGdldEZvY3VzQmxvY2tPYmplY3Qoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQXJyb3dVcCAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFwcmV2aW91c0Jsb2NrO1xuICB9LFxuICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICB0eXBlOiBcImluc2VydC50ZXh0IGJsb2NrXCIsXG4gICAgcGxhY2VtZW50OiBcImJlZm9yZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNlbGVjdC5wcmV2aW91cyBibG9ja1wiXG4gIH1dXVxufSwgYnJlYWtpbmdCbG9ja09iamVjdCA9IHtcbiAgb246IFwiaW5zZXJ0LmJyZWFrXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHtcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgY29udGV4dFxuICAgIH0pICYmIGZvY3VzQmxvY2tPYmplY3QgIT09IHZvaWQgMDtcbiAgfSxcbiAgYWN0aW9uczogWygpID0+IFt7XG4gICAgdHlwZTogXCJpbnNlcnQudGV4dCBibG9ja1wiLFxuICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gIH1dXVxufSwgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0FmdGVyQmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBwcmV2aW91c0Jsb2NrID0gZ2V0UHJldmlvdXNCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFwcmV2aW91c0Jsb2NrID8gITEgOiBpc0VtcHR5VGV4dEJsb2NrKGZvY3VzVGV4dEJsb2NrLm5vZGUpICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhwcmV2aW91c0Jsb2NrLm5vZGUpID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBwcmV2aW91c0Jsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBwcmV2aW91c0Jsb2NrXG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSwge1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBwcmV2aW91c0Jsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH1cbiAgfV1dXG59LCBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImRlbGV0ZS5mb3J3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIG5leHRCbG9jayA9IGdldE5leHRCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuICFmb2N1c1RleHRCbG9jayB8fCAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFuZXh0QmxvY2sgPyAhMSA6IGlzRW1wdHlUZXh0QmxvY2soZm9jdXNUZXh0QmxvY2subm9kZSkgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5leHRCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbmV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBuZXh0QmxvY2tcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgIGJsb2NrUGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICB9LCB7XG4gICAgdHlwZTogXCJzZWxlY3RcIixcbiAgICBzZWxlY3Rpb246IHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBuZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH1cbiAgfV1dXG59LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMgPSB7XG4gIGFycm93RG93bk9uTG9uZWx5QmxvY2tPYmplY3QsXG4gIGFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0LFxuICBicmVha2luZ0Jsb2NrT2JqZWN0LFxuICBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCxcbiAgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0XG59LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzID0ge1xuICBzdHJvbmdTaG9ydGN1dDoge1xuICAgIG9uOiBcImtleS5kb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiBpc0hvdGtleShcIm1vZCtiXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpICYmIGNvbnRleHQuc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IFwic3Ryb25nXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwic3Ryb25nXCJcbiAgICB9KV1dXG4gIH0sXG4gIGVtU2hvcnRjdXQ6IHtcbiAgICBvbjogXCJrZXkuZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QraVwiLCBldmVudC5rZXlib2FyZEV2ZW50KSAmJiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBcImVtXCIpLFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbcmFpc2Uoe1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IudG9nZ2xlXCIsXG4gICAgICBkZWNvcmF0b3I6IFwiZW1cIlxuICAgIH0pXV1cbiAgfSxcbiAgdW5kZXJsaW5lU2hvcnRjdXQ6IHtcbiAgICBvbjogXCJrZXkuZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QrdVwiLCBldmVudC5rZXlib2FyZEV2ZW50KSAmJiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBcInVuZGVybGluZVwiKSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3JhaXNlKHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgZGVjb3JhdG9yOiBcInVuZGVybGluZVwiXG4gICAgfSldXVxuICB9LFxuICBjb2RlU2hvcnRjdXQ6IHtcbiAgICBvbjogXCJrZXkuZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gaXNIb3RrZXkoXCJtb2QrJ1wiLCBldmVudC5rZXlib2FyZEV2ZW50KSAmJiBjb250ZXh0LnNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBcImNvZGVcIiksXG4gICAgYWN0aW9uczogWygpID0+IFtyYWlzZSh7XG4gICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgIGRlY29yYXRvcjogXCJjb2RlXCJcbiAgICB9KV1dXG4gIH1cbn0sIE1BWF9MSVNUX0xFVkVMID0gMTAsIGNsZWFyTGlzdE9uQmFja3NwYWNlID0ge1xuICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbiA/ICExIDogZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIGNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCA9PT0gMSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9ja1xuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwidGV4dCBibG9jay51bnNldFwiLFxuICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH1dXVxufSwgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2UgPSB7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuID8gITEgOiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuWzBdLl9rZXkgPT09IGZvY3VzU3Bhbi5ub2RlLl9rZXkgJiYgY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA9PT0gMCAmJiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsICE9PSB2b2lkIDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCA+IDEgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIGxldmVsOiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsIC0gMVxuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgbGV2ZWxcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcInRleHQgYmxvY2suc2V0XCIsXG4gICAgbGV2ZWwsXG4gICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfV1dXG59LCBjbGVhckxpc3RPbkVudGVyID0ge1xuICBvbjogXCJpbnNlcnQuYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBmb2N1c0xpc3RCbG9jayA9IGdldEZvY3VzTGlzdEJsb2NrKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNMaXN0QmxvY2sgfHwgIWlzRW1wdHlUZXh0QmxvY2soZm9jdXNMaXN0QmxvY2subm9kZSkgPyAhMSA6IHtcbiAgICAgIGZvY3VzTGlzdEJsb2NrXG4gICAgfTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNMaXN0QmxvY2tcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcInRleHQgYmxvY2sudW5zZXRcIixcbiAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICBhdDogZm9jdXNMaXN0QmxvY2sucGF0aFxuICB9XV1cbn0sIGluZGVudExpc3RPblRhYiA9IHtcbiAgb246IFwia2V5LmRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKCFpc0hvdGtleShcIlRhYlwiLCBldmVudC5rZXlib2FyZEV2ZW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gZ3VhcmRzLmlzTGlzdEJsb2NrKGJsb2NrLm5vZGUpID8gW3tcbiAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICBwYXRoOiBibG9jay5wYXRoXG4gICAgfV0gOiBbXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdEJsb2Nrcy5sZW5ndGggPT09IHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA/IHtcbiAgICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkTGlzdEJsb2Nrcy5tYXAoKHNlbGVjdGVkTGlzdEJsb2NrKSA9PiAoe1xuICAgIHR5cGU6IFwidGV4dCBibG9jay5zZXRcIixcbiAgICBsZXZlbDogTWF0aC5taW4oTUFYX0xJU1RfTEVWRUwsIE1hdGgubWF4KDEsIHNlbGVjdGVkTGlzdEJsb2NrLm5vZGUubGV2ZWwgKyAxKSksXG4gICAgYXQ6IHNlbGVjdGVkTGlzdEJsb2NrLnBhdGhcbiAgfSkpXVxufSwgdW5pbmRlbnRMaXN0T25TaGlmdFRhYiA9IHtcbiAgb246IFwia2V5LmRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgaWYgKCFpc0hvdGtleShcIlNoaWZ0K1RhYlwiLCBldmVudC5rZXlib2FyZEV2ZW50KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IGdldFNlbGVjdGVkQmxvY2tzKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZExpc3RCbG9ja3MgPSBzZWxlY3RlZEJsb2Nrcy5mbGF0TWFwKChibG9jaykgPT4gZ3VhcmRzLmlzTGlzdEJsb2NrKGJsb2NrLm5vZGUpID8gW3tcbiAgICAgIG5vZGU6IGJsb2NrLm5vZGUsXG4gICAgICBwYXRoOiBibG9jay5wYXRoXG4gICAgfV0gOiBbXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkTGlzdEJsb2Nrcy5sZW5ndGggPT09IHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA/IHtcbiAgICAgIHNlbGVjdGVkTGlzdEJsb2Nrc1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gIH0pID0+IHNlbGVjdGVkTGlzdEJsb2Nrcy5tYXAoKHNlbGVjdGVkTGlzdEJsb2NrKSA9PiAoe1xuICAgIHR5cGU6IFwidGV4dCBibG9jay5zZXRcIixcbiAgICBsZXZlbDogTWF0aC5taW4oTUFYX0xJU1RfTEVWRUwsIE1hdGgubWF4KDEsIHNlbGVjdGVkTGlzdEJsb2NrLm5vZGUubGV2ZWwgLSAxKSksXG4gICAgYXQ6IHNlbGVjdGVkTGlzdEJsb2NrLnBhdGhcbiAgfSkpXVxufSwgY29yZUxpc3RCZWhhdmlvcnMgPSB7XG4gIGNsZWFyTGlzdE9uQmFja3NwYWNlLFxuICB1bmluZGVudExpc3RPbkJhY2tzcGFjZSxcbiAgY2xlYXJMaXN0T25FbnRlcixcbiAgaW5kZW50TGlzdE9uVGFiLFxuICB1bmluZGVudExpc3RPblNoaWZ0VGFiXG59LCBzb2Z0UmV0dXJuID0ge1xuICBvbjogXCJpbnNlcnQuc29mdCBicmVha1wiLFxuICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgdGV4dDogYFxuYFxuICB9XV1cbn0sIGNvcmVCZWhhdmlvcnMgPSBbc29mdFJldHVybiwgY29yZURlY29yYXRvckJlaGF2aW9ycy5zdHJvbmdTaG9ydGN1dCwgY29yZURlY29yYXRvckJlaGF2aW9ycy5lbVNob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLnVuZGVybGluZVNob3J0Y3V0LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmNvZGVTaG9ydGN1dCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmFycm93RG93bk9uTG9uZWx5QmxvY2tPYmplY3QsIGNvcmVCbG9ja09iamVjdEJlaGF2aW9ycy5hcnJvd1VwT25Mb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmJyZWFraW5nQmxvY2tPYmplY3QsIGNvcmVCbG9ja09iamVjdEJlaGF2aW9ycy5kZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tCZWZvcmVCbG9ja09iamVjdCwgY29yZUxpc3RCZWhhdmlvcnMuY2xlYXJMaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLnVuaW5kZW50TGlzdE9uQmFja3NwYWNlLCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkVudGVyLCBjb3JlTGlzdEJlaGF2aW9ycy5pbmRlbnRMaXN0T25UYWIsIGNvcmVMaXN0QmVoYXZpb3JzLnVuaW5kZW50TGlzdE9uU2hpZnRUYWJdLCBjb3JlQmVoYXZpb3IgPSB7XG4gIHNvZnRSZXR1cm4sXG4gIGRlY29yYXRvcnM6IGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMsXG4gIGJsb2NrT2JqZWN0czogY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLFxuICBsaXN0czogY29yZUxpc3RCZWhhdmlvcnNcbn07XG5leHBvcnQge1xuICBjb3JlQmVoYXZpb3IsXG4gIGNvcmVCZWhhdmlvcnMsXG4gIGRlZmluZUJlaGF2aW9yLFxuICBpc0N1c3RvbUJlaGF2aW9yRXZlbnQsXG4gIGlzSG90a2V5LFxuICByYWlzZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlaGF2aW9yLmNvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockTextBefore: () => (/* binding */ getBlockTextBefore),\n/* harmony export */   getSelectionText: () => (/* binding */ getSelectionText)\n/* harmony export */ });\n/* harmony import */ var _util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.reverse-selection.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js\");\n/* harmony import */ var _util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.is-keyed-segment.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-keyed-segment.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\n\n\nconst getSelectionText = ({\n  context\n}) => {\n  let text = \"\";\n  const {\n    value,\n    selection\n  } = context;\n  if (!value || !selection)\n    return text;\n  const forwardSelection = selection.backward ? (0,_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(selection) : selection;\n  if (!forwardSelection)\n    return text;\n  for (const block of value)\n    if (!((0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextTextBlock)(block)) {\n      for (const child of block.children)\n        if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_2__.isPortableTextSpan)(child)) {\n          if ((0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && (0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {\n            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);\n            break;\n          }\n          if ((0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {\n            text = text + child.text.slice(forwardSelection.anchor.offset);\n            continue;\n          }\n          if ((0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {\n            text = text + child.text.slice(0, forwardSelection.focus.offset);\n            break;\n          }\n          text.length > 0 && (text = text + child.text);\n        }\n      if ((0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)\n        break;\n    }\n  return text;\n}, getBlockTextBefore = ({\n  context\n}) => {\n  if (!context.selection)\n    return \"\";\n  const point = (context.selection.backward ? (0,_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__.reverseSelection)(context.selection) : context.selection).anchor, key = (0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(point.path[0]) ? point.path[0]._key : void 0, block = key ? context.value.find((block2) => block2._key === key) : void 0;\n  if (!block)\n    return \"\";\n  const startOfBlock = (0,_util_reverse_selection_js__WEBPACK_IMPORTED_MODULE_0__.getBlockStartPoint)({\n    node: block,\n    path: [{\n      _key: block._key\n    }]\n  });\n  return getSelectionText({\n    context: {\n      ...context,\n      value: context.value,\n      selection: {\n        anchor: startOfBlock,\n        focus: point\n      }\n    }\n  });\n};\n\n//# sourceMappingURL=selector.get-text-before.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXRleHQtYmVmb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GO0FBQ3ZCO0FBQ2dCO0FBQzVFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdEQUFnRCw0RUFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5RUFBYyw2RkFBNkYsc0VBQXVCO0FBQzVJO0FBQ0EsWUFBWSxpRUFBa0I7QUFDOUIsY0FBYyx5RUFBYyw0RkFBNEYseUVBQWM7QUFDdEk7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5RUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlFQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlFQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLDRFQUFnQix1REFBdUQseUVBQWM7QUFDbkk7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanM/MjcwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXZlcnNlU2VsZWN0aW9uLCBnZXRCbG9ja1N0YXJ0UG9pbnQgfSBmcm9tIFwiLi91dGlsLnJldmVyc2Utc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBpc0tleWVkU2VnbWVudCB9IGZyb20gXCIuL3V0aWwuaXMta2V5ZWQtc2VnbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5jb25zdCBnZXRTZWxlY3Rpb25UZXh0ID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGNvbnN0IHtcbiAgICB2YWx1ZSxcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGNvbnRleHQ7XG4gIGlmICghdmFsdWUgfHwgIXNlbGVjdGlvbilcbiAgICByZXR1cm4gdGV4dDtcbiAgY29uc3QgZm9yd2FyZFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5iYWNrd2FyZCA/IHJldmVyc2VTZWxlY3Rpb24oc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgaWYgKCFmb3J3YXJkU2VsZWN0aW9uKVxuICAgIHJldHVybiB0ZXh0O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgIGlmICghKGlzS2V5ZWRTZWdtZW50KGZvcndhcmRTZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pICYmIGJsb2NrLl9rZXkgIT09IGZvcndhcmRTZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgIGlmIChpc0tleWVkU2VnbWVudChmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdKSAmJiBjaGlsZC5fa2V5ID09PSBmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdLl9rZXkgJiYgaXNLZXllZFNlZ21lbnQoZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdKSAmJiBjaGlsZC5fa2V5ID09PSBmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0uX2tleSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQgKyBjaGlsZC50ZXh0LnNsaWNlKGZvcndhcmRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCwgZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0tleWVkU2VnbWVudChmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdKSAmJiBjaGlsZC5fa2V5ID09PSBmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdLl9rZXkpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0ICsgY2hpbGQudGV4dC5zbGljZShmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0tleWVkU2VnbWVudChmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0pICYmIGNoaWxkLl9rZXkgPT09IGZvcndhcmRTZWxlY3Rpb24uZm9jdXMucGF0aFsyXS5fa2V5KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArIGNoaWxkLnRleHQuc2xpY2UoMCwgZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQubGVuZ3RoID4gMCAmJiAodGV4dCA9IHRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgaWYgKGlzS2V5ZWRTZWdtZW50KGZvcndhcmRTZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgJiYgYmxvY2suX2tleSA9PT0gZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHRleHQ7XG59LCBnZXRCbG9ja1RleHRCZWZvcmUgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGlmICghY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHBvaW50ID0gKGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gcmV2ZXJzZVNlbGVjdGlvbihjb250ZXh0LnNlbGVjdGlvbikgOiBjb250ZXh0LnNlbGVjdGlvbikuYW5jaG9yLCBrZXkgPSBpc0tleWVkU2VnbWVudChwb2ludC5wYXRoWzBdKSA/IHBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgYmxvY2sgPSBrZXkgPyBjb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrMikgPT4gYmxvY2syLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHN0YXJ0T2ZCbG9jayA9IGdldEJsb2NrU3RhcnRQb2ludCh7XG4gICAgbm9kZTogYmxvY2ssXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9XVxuICB9KTtcbiAgcmV0dXJuIGdldFNlbGVjdGlvblRleHQoe1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICB2YWx1ZTogY29udGV4dC52YWx1ZSxcbiAgICAgIHNlbGVjdGlvbjoge1xuICAgICAgICBhbmNob3I6IHN0YXJ0T2ZCbG9jayxcbiAgICAgICAgZm9jdXM6IHBvaW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5leHBvcnQge1xuICBnZXRCbG9ja1RleHRCZWZvcmUsXG4gIGdldFNlbGVjdGlvblRleHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rvci5nZXQtdGV4dC1iZWZvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGuards: () => (/* binding */ createGuards),\n/* harmony export */   getFirstBlock: () => (/* binding */ getFirstBlock),\n/* harmony export */   getFocusBlock: () => (/* binding */ getFocusBlock),\n/* harmony export */   getFocusBlockObject: () => (/* binding */ getFocusBlockObject),\n/* harmony export */   getFocusChild: () => (/* binding */ getFocusChild),\n/* harmony export */   getFocusListBlock: () => (/* binding */ getFocusListBlock),\n/* harmony export */   getFocusSpan: () => (/* binding */ getFocusSpan),\n/* harmony export */   getFocusTextBlock: () => (/* binding */ getFocusTextBlock),\n/* harmony export */   getLastBlock: () => (/* binding */ getLastBlock),\n/* harmony export */   getNextBlock: () => (/* binding */ getNextBlock),\n/* harmony export */   getPreviousBlock: () => (/* binding */ getPreviousBlock),\n/* harmony export */   getSelectedBlocks: () => (/* binding */ getSelectedBlocks),\n/* harmony export */   getSelectionEndBlock: () => (/* binding */ getSelectionEndBlock),\n/* harmony export */   getSelectionStartBlock: () => (/* binding */ getSelectionStartBlock),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\nfunction createGuards({\n  schema\n}) {\n  function isListBlock(block) {\n    return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListBlock)(block) && block._type === schema.block.name;\n  }\n  function isTextBlock(block) {\n    return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) && block._type === schema.block.name;\n  }\n  return {\n    isListBlock,\n    isTextBlock\n  };\n}\nconst getFocusBlock = ({\n  context\n}) => {\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getFocusListBlock = ({\n  context\n}) => {\n  const guards = createGuards(context), focusBlock = getFocusBlock({\n    context\n  });\n  return focusBlock && guards.isListBlock(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusTextBlock = ({\n  context\n}) => {\n  const focusBlock = getFocusBlock({\n    context\n  });\n  return focusBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusBlockObject = ({\n  context\n}) => {\n  const focusBlock = getFocusBlock({\n    context\n  });\n  return focusBlock && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}, getFocusChild = ({\n  context\n}) => {\n  const focusBlock = getFocusTextBlock({\n    context\n  });\n  if (!focusBlock)\n    return;\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}, getFocusSpan = ({\n  context\n}) => {\n  const focusChild = getFocusChild({\n    context\n  });\n  return focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}, getFirstBlock = ({\n  context\n}) => {\n  const node = context.value[0];\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getLastBlock = ({\n  context\n}) => {\n  const node = context.value[context.value.length - 1] ? context.value[context.value.length - 1] : void 0;\n  return node ? {\n    node,\n    path: [{\n      _key: node._key\n    }]\n  } : void 0;\n}, getSelectedBlocks = ({\n  context\n}) => {\n  if (!context.selection)\n    return [];\n  const selectedBlocks = [], startKey = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, endKey = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0;\n  if (!startKey || !endKey)\n    return selectedBlocks;\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      if (selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      }), startKey === endKey)\n        break;\n      continue;\n    }\n    if (block._key === endKey) {\n      selectedBlocks.push({\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      });\n      break;\n    }\n    selectedBlocks.length > 0 && selectedBlocks.push({\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    });\n  }\n  return selectedBlocks;\n}, getSelectionStartBlock = ({\n  context\n}) => {\n  if (!context.selection)\n    return;\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getSelectionEndBlock = ({\n  context\n}) => {\n  if (!context.selection)\n    return;\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}, getPreviousBlock = ({\n  context\n}) => {\n  let previousBlock;\n  const selectionStartBlock = getSelectionStartBlock({\n    context\n  });\n  if (!selectionStartBlock)\n    return;\n  let foundSelectionStartBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = !0;\n      break;\n    }\n    previousBlock = {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    };\n  }\n  if (foundSelectionStartBlock && previousBlock)\n    return previousBlock;\n}, getNextBlock = ({\n  context\n}) => {\n  let nextBlock;\n  const selectionEndBlock = getSelectionEndBlock({\n    context\n  });\n  if (!selectionEndBlock)\n    return;\n  let foundSelectionEndBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = !0;\n      continue;\n    }\n    if (foundSelectionEndBlock) {\n      nextBlock = {\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      };\n      break;\n    }\n  }\n  if (foundSelectionEndBlock && nextBlock)\n    return nextBlock;\n}, isSelectionCollapsed = ({\n  context\n}) => JSON.stringify(context.selection?.anchor.path) === JSON.stringify(context.selection?.focus.path) && context.selection?.anchor.offset === context.selection?.focus.offset;\n\n//# sourceMappingURL=selector.is-selection-collapsed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1IO0FBQ25IO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxXQUFXLHNFQUF1QjtBQUNsQztBQUNBO0FBQ0EsV0FBVyxzRUFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsMkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsc0VBQXVCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLHNFQUF1QjtBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUMsMkRBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixpRUFBa0I7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EscUVBQXFFLDJEQUFZLG9GQUFvRiwyREFBWSwySEFBMkgsMkRBQVksc0ZBQXNGLDJEQUFZO0FBQzFaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkNBQTJDLDJEQUFZLG9GQUFvRiwyREFBWTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQ0FBMkMsMkRBQVksc0ZBQXNGLDJEQUFZO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQWlCQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1zZWxlY3Rpb24tY29sbGFwc2VkLmpzPzI1YWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQb3J0YWJsZVRleHRMaXN0QmxvY2ssIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc0tleVNlZ21lbnQsIGlzUG9ydGFibGVUZXh0U3BhbiB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5mdW5jdGlvbiBjcmVhdGVHdWFyZHMoe1xuICBzY2hlbWFcbn0pIHtcbiAgZnVuY3Rpb24gaXNMaXN0QmxvY2soYmxvY2spIHtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRMaXN0QmxvY2soYmxvY2spICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWEuYmxvY2submFtZTtcbiAgfVxuICBmdW5jdGlvbiBpc1RleHRCbG9jayhibG9jaykge1xuICAgIHJldHVybiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYS5ibG9jay5uYW1lO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNMaXN0QmxvY2ssXG4gICAgaXNUZXh0QmxvY2tcbiAgfTtcbn1cbmNvbnN0IGdldEZvY3VzQmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uICYmIGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNMaXN0QmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhjb250ZXh0KSwgZm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2soe1xuICAgIGNvbnRleHRcbiAgfSk7XG4gIHJldHVybiBmb2N1c0Jsb2NrICYmIGd1YXJkcy5pc0xpc3RCbG9jayhmb2N1c0Jsb2NrLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQmxvY2subm9kZSxcbiAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzVGV4dEJsb2NrID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgY29udGV4dFxuICB9KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0Jsb2NrT2JqZWN0ID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgY29udGV4dFxuICB9KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgIWlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aFxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNDaGlsZCA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICBjb250ZXh0XG4gIH0pO1xuICBpZiAoIWZvY3VzQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFsyXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW4uZmluZCgoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbLi4uZm9jdXNCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c1NwYW4gPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IGZvY3VzQ2hpbGQgPSBnZXRGb2N1c0NoaWxkKHtcbiAgICBjb250ZXh0XG4gIH0pO1xuICByZXR1cm4gZm9jdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0NoaWxkLm5vZGUsXG4gICAgcGF0aDogZm9jdXNDaGlsZC5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGaXJzdEJsb2NrID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBjb25zdCBub2RlID0gY29udGV4dC52YWx1ZVswXTtcbiAgcmV0dXJuIG5vZGUgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogbm9kZS5fa2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldExhc3RCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgY29uc3Qgbm9kZSA9IGNvbnRleHQudmFsdWVbY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA/IGNvbnRleHQudmFsdWVbY29udGV4dC52YWx1ZS5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleTogbm9kZS5fa2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldFNlbGVjdGVkQmxvY2tzID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBpZiAoIWNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbXSwgc3RhcnRLZXkgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBlbmRLZXkgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwO1xuICBpZiAoIXN0YXJ0S2V5IHx8ICFlbmRLZXkpXG4gICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc3RhcnRLZXkpIHtcbiAgICAgIGlmIChzZWxlY3RlZEJsb2Nrcy5wdXNoKHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfSksIHN0YXJ0S2V5ID09PSBlbmRLZXkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChibG9jay5fa2V5ID09PSBlbmRLZXkpIHtcbiAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgbm9kZTogYmxvY2ssXG4gICAgICBwYXRoOiBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWxlY3RlZEJsb2Nrcztcbn0sIGdldFNlbGVjdGlvblN0YXJ0QmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGlmICghY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRTZWxlY3Rpb25FbmRCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgaWYgKCFjb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBjb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrKSA9PiBibG9jay5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldFByZXZpb3VzQmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGxldCBwcmV2aW91c0Jsb2NrO1xuICBjb25zdCBzZWxlY3Rpb25TdGFydEJsb2NrID0gZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayh7XG4gICAgY29udGV4dFxuICB9KTtcbiAgaWYgKCFzZWxlY3Rpb25TdGFydEJsb2NrKVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kU2VsZWN0aW9uU3RhcnRCbG9jayA9ICExO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc2VsZWN0aW9uU3RhcnRCbG9jay5ub2RlLl9rZXkpIHtcbiAgICAgIGZvdW5kU2VsZWN0aW9uU3RhcnRCbG9jayA9ICEwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzQmxvY2sgPSB7XG4gICAgICBub2RlOiBibG9jayxcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH1dXG4gICAgfTtcbiAgfVxuICBpZiAoZm91bmRTZWxlY3Rpb25TdGFydEJsb2NrICYmIHByZXZpb3VzQmxvY2spXG4gICAgcmV0dXJuIHByZXZpb3VzQmxvY2s7XG59LCBnZXROZXh0QmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGxldCBuZXh0QmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soe1xuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmICghc2VsZWN0aW9uRW5kQmxvY2spXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmRTZWxlY3Rpb25FbmRCbG9jayA9ICExO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc2VsZWN0aW9uRW5kQmxvY2subm9kZS5fa2V5KSB7XG4gICAgICBmb3VuZFNlbGVjdGlvbkVuZEJsb2NrID0gITA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZvdW5kU2VsZWN0aW9uRW5kQmxvY2spIHtcbiAgICAgIG5leHRCbG9jayA9IHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoZm91bmRTZWxlY3Rpb25FbmRCbG9jayAmJiBuZXh0QmxvY2spXG4gICAgcmV0dXJuIG5leHRCbG9jaztcbn0sIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gKHtcbiAgY29udGV4dFxufSkgPT4gSlNPTi5zdHJpbmdpZnkoY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5wYXRoKSA9PT0gSlNPTi5zdHJpbmdpZnkoY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLnBhdGgpICYmIGNvbnRleHQuc2VsZWN0aW9uPy5hbmNob3Iub2Zmc2V0ID09PSBjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0O1xuZXhwb3J0IHtcbiAgY3JlYXRlR3VhcmRzLFxuICBnZXRGaXJzdEJsb2NrLFxuICBnZXRGb2N1c0Jsb2NrLFxuICBnZXRGb2N1c0Jsb2NrT2JqZWN0LFxuICBnZXRGb2N1c0NoaWxkLFxuICBnZXRGb2N1c0xpc3RCbG9jayxcbiAgZ2V0Rm9jdXNTcGFuLFxuICBnZXRGb2N1c1RleHRCbG9jayxcbiAgZ2V0TGFzdEJsb2NrLFxuICBnZXROZXh0QmxvY2ssXG4gIGdldFByZXZpb3VzQmxvY2ssXG4gIGdldFNlbGVjdGVkQmxvY2tzLFxuICBnZXRTZWxlY3Rpb25FbmRCbG9jayxcbiAgZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayxcbiAgaXNTZWxlY3Rpb25Db2xsYXBzZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rvci5pcy1zZWxlY3Rpb24tY29sbGFwc2VkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* binding */ blockOffsetToSpanSelectionPoint),\n/* harmony export */   getTextBlockText: () => (/* binding */ getTextBlockText),\n/* harmony export */   isEmptyTextBlock: () => (/* binding */ isEmptyTextBlock),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* binding */ spanSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.is-keyed-segment.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-keyed-segment.js\");\n\n\nfunction blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset\n}) {\n  let offsetLeft = blockOffset.offset, selectionPoint;\n  for (const block of value)\n    if (block._key === blockOffset.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n      for (const child of block.children)\n        if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n          if (offsetLeft === 0) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: 0\n            };\n            break;\n          }\n          if (offsetLeft <= child.text.length) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: offsetLeft\n            };\n            break;\n          }\n          offsetLeft -= child.text.length;\n        }\n    }\n  return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint\n}) {\n  let offset = 0;\n  const blockKey = (0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, spanKey = (0,_util_is_keyed_segment_js__WEBPACK_IMPORTED_MODULE_1__.isKeyedSegment)(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;\n  if (!(!blockKey || !spanKey)) {\n    for (const block of value)\n      if (block._key === blockKey && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        for (const child of block.children)\n          if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (child._key === spanKey)\n              return {\n                path: [{\n                  _key: block._key\n                }],\n                offset: offset + selectionPoint.offset\n              };\n            offset += child.text.length;\n          }\n      }\n  }\n}\nfunction getTextBlockText(block) {\n  return block.children.map((child) => child.text ?? \"\").join(\"\");\n}\nfunction isEmptyTextBlock(block) {\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block))\n    return !1;\n  const onlyText = block.children.every(_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan), blockText = getTextBlockText(block);\n  return onlyText && blockText === \"\";\n}\n\n//# sourceMappingURL=util.is-empty-text-block.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5pcy1lbXB0eS10ZXh0LWJsb2NrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0RTtBQUNoQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1EQUFtRCxzRUFBdUI7QUFDMUU7QUFDQSxZQUFZLGlFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQix5RUFBYywyRUFBMkUseUVBQWM7QUFDMUg7QUFDQTtBQUNBLHFDQUFxQyxzRUFBdUI7QUFDNUQ7QUFDQSxjQUFjLGlFQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRUFBdUI7QUFDOUI7QUFDQSx3Q0FBd0MsNkRBQWtCO0FBQzFEO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmlzLWVtcHR5LXRleHQtYmxvY2suanM/MGI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IGlzS2V5ZWRTZWdtZW50IH0gZnJvbSBcIi4vdXRpbC5pcy1rZXllZC1zZWdtZW50LmpzXCI7XG5mdW5jdGlvbiBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50KHtcbiAgdmFsdWUsXG4gIGJsb2NrT2Zmc2V0XG59KSB7XG4gIGxldCBvZmZzZXRMZWZ0ID0gYmxvY2tPZmZzZXQub2Zmc2V0LCBzZWxlY3Rpb25Qb2ludDtcbiAgZm9yIChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gYmxvY2tPZmZzZXQucGF0aFswXS5fa2V5ICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBibG9jay5jaGlsZHJlbilcbiAgICAgICAgaWYgKGlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uUG9pbnQgPSB7XG4gICAgICAgICAgICAgIHBhdGg6IFsuLi5ibG9ja09mZnNldC5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPD0gY2hpbGQudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRMZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldExlZnQgLT0gY2hpbGQudGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gIHJldHVybiBzZWxlY3Rpb25Qb2ludDtcbn1cbmZ1bmN0aW9uIHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICB2YWx1ZSxcbiAgc2VsZWN0aW9uUG9pbnRcbn0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGJsb2NrS2V5ID0gaXNLZXllZFNlZ21lbnQoc2VsZWN0aW9uUG9pbnQucGF0aFswXSkgPyBzZWxlY3Rpb25Qb2ludC5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIHNwYW5LZXkgPSBpc0tleWVkU2VnbWVudChzZWxlY3Rpb25Qb2ludC5wYXRoWzJdKSA/IHNlbGVjdGlvblBvaW50LnBhdGhbMl0uX2tleSA6IHZvaWQgMDtcbiAgaWYgKCEoIWJsb2NrS2V5IHx8ICFzcGFuS2V5KSkge1xuICAgIGZvciAoY29uc3QgYmxvY2sgb2YgdmFsdWUpXG4gICAgICBpZiAoYmxvY2suX2tleSA9PT0gYmxvY2tLZXkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzUG9ydGFibGVUZXh0U3BhbihjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBzcGFuS2V5KVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRleHRCbG9ja1RleHQoYmxvY2spIHtcbiAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRleHQgPz8gXCJcIikuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0QmxvY2soYmxvY2spIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBvbmx5VGV4dCA9IGJsb2NrLmNoaWxkcmVuLmV2ZXJ5KGlzUG9ydGFibGVUZXh0U3BhbiksIGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoYmxvY2spO1xuICByZXR1cm4gb25seVRleHQgJiYgYmxvY2tUZXh0ID09PSBcIlwiO1xufVxuZXhwb3J0IHtcbiAgYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCxcbiAgZ2V0VGV4dEJsb2NrVGV4dCxcbiAgaXNFbXB0eVRleHRCbG9jayxcbiAgc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuaXMtZW1wdHktdGV4dC1ibG9jay5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-keyed-segment.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.is-keyed-segment.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isKeyedSegment: () => (/* binding */ isKeyedSegment)\n/* harmony export */ });\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && segment !== null && \"_key\" in segment;\n}\n\n//# sourceMappingURL=util.is-keyed-segment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5pcy1rZXllZC1zZWdtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLmlzLWtleWVkLXNlZ21lbnQuanM/MTA3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIHNlZ21lbnQgIT09IG51bGwgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmV4cG9ydCB7XG4gIGlzS2V5ZWRTZWdtZW50XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5pcy1rZXllZC1zZWdtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-keyed-segment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockStartPoint: () => (/* binding */ getBlockStartPoint),\n/* harmony export */   reverseSelection: () => (/* binding */ reverseSelection)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\nfunction getBlockStartPoint({\n  node,\n  path\n}) {\n  return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(node) ? {\n    path: [...path, \"children\", {\n      _key: node.children[0]._key\n    }],\n    offset: 0\n  } : {\n    path,\n    offset: 0\n  };\n}\nfunction reverseSelection(selection) {\n  return selection.backward ? {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !1\n  } : {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !0\n  };\n}\n\n//# sourceMappingURL=util.reverse-selection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvdXRpbC5yZXZlcnNlLXNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVMsc0VBQXVCO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvX2NodW5rcy1lcy91dGlsLnJldmVyc2Utc2VsZWN0aW9uLmpzP2EzOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuZnVuY3Rpb24gZ2V0QmxvY2tTdGFydFBvaW50KHtcbiAgbm9kZSxcbiAgcGF0aFxufSkge1xuICByZXR1cm4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sobm9kZSkgPyB7XG4gICAgcGF0aDogWy4uLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogbm9kZS5jaGlsZHJlblswXS5fa2V5XG4gICAgfV0sXG4gICAgb2Zmc2V0OiAwXG4gIH0gOiB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24uYmFja3dhcmQgPyB7XG4gICAgYW5jaG9yOiBzZWxlY3Rpb24uZm9jdXMsXG4gICAgZm9jdXM6IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgYmFja3dhcmQ6ICExXG4gIH0gOiB7XG4gICAgYW5jaG9yOiBzZWxlY3Rpb24uZm9jdXMsXG4gICAgZm9jdXM6IHNlbGVjdGlvbi5hbmNob3IsXG4gICAgYmFja3dhcmQ6ICEwXG4gIH07XG59XG5leHBvcnQge1xuICBnZXRCbG9ja1N0YXJ0UG9pbnQsXG4gIHJldmVyc2VTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLnJldmVyc2Utc2VsZWN0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.reverse-selection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/behaviors/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coreBehavior: () => (/* reexport safe */ _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.coreBehavior),\n/* harmony export */   coreBehaviors: () => (/* reexport safe */ _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.coreBehaviors),\n/* harmony export */   createCodeEditorBehaviors: () => (/* binding */ createCodeEditorBehaviors),\n/* harmony export */   createEmojiPickerBehaviors: () => (/* binding */ createEmojiPickerBehaviors),\n/* harmony export */   createLinkBehaviors: () => (/* binding */ createLinkBehaviors),\n/* harmony export */   createMarkdownBehaviors: () => (/* binding */ createMarkdownBehaviors),\n/* harmony export */   defineBehavior: () => (/* reexport safe */ _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior),\n/* harmony export */   raise: () => (/* reexport safe */ _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.raise)\n/* harmony export */ });\n/* harmony import */ var _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_chunks-es/behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n/* harmony import */ var _chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_chunks-es/selector.is-selection-collapsed.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var _chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_chunks-es/selector.get-text-before.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../_chunks-es/util.is-empty-text-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\");\n\n\n\n\n\n\n\nfunction createCodeEditorBehaviors(config) {\n  return [(0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const isMoveUpShortcut = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(config.moveBlockUpShortcut, event.keyboardEvent), firstBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFirstBlock)({\n        context\n      }), selectedBlocks = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)({\n        context\n      }), blocksAbove = firstBlock?.node._key !== selectedBlocks[0]?.node._key;\n      return !isMoveUpShortcut || !blocksAbove ? !1 : {\n        paths: selectedBlocks.map((block) => block.path)\n      };\n    },\n    actions: [(_, {\n      paths\n    }) => paths.map((at) => ({\n      type: \"move.block up\",\n      at\n    }))]\n  }), (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const isMoveDownShortcut = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(config.moveBlockDownShortcut, event.keyboardEvent), lastBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getLastBlock)({\n        context\n      }), selectedBlocks = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)({\n        context\n      }), blocksBelow = lastBlock?.node._key !== selectedBlocks[selectedBlocks.length - 1]?.node._key;\n      return !isMoveDownShortcut || !blocksBelow ? !1 : {\n        paths: selectedBlocks.map((block) => block.path).reverse()\n      };\n    },\n    actions: [(_, {\n      paths\n    }) => paths.map((at) => ({\n      type: \"move.block down\",\n      at\n    }))]\n  })];\n}\nconst emojiCharRegEx = /^[a-zA-Z-_0-9]{1}$/, incompleteEmojiRegEx = /:([a-zA-Z-_0-9]+)$/, emojiRegEx = /:([a-zA-Z-_0-9]+):$/;\nfunction createEmojiPickerBehaviors(config) {\n  const emojiPickerActor = (0,xstate__WEBPACK_IMPORTED_MODULE_2__.A)(createEmojiPickerMachine());\n  return emojiPickerActor.start(), emojiPickerActor.subscribe((state) => {\n    config.onMatchesChanged({\n      matches: state.context.matches\n    }), config.onSelectedIndexChanged({\n      selectedIndex: state.context.selectedIndex\n    });\n  }), [(0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text === \":\")\n        return !1;\n      if (!emojiCharRegEx.test(event.text))\n        return {\n          emojis: []\n        };\n      const focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), emojiKeyword = `${(0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)({\n        context\n      })}${event.text}`.match(incompleteEmojiRegEx)?.[1];\n      return !focusBlock || emojiKeyword === void 0 ? {\n        emojis: []\n      } : {\n        emojis: config.matchEmojis({\n          keyword: emojiKeyword\n        })\n      };\n    },\n    actions: [(_, params) => [{\n      type: \"effect\",\n      effect: () => {\n        emojiPickerActor.send({\n          type: \"emojis found\",\n          matches: params.emojis\n        });\n      }\n    }]]\n  }), (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \":\")\n        return !1;\n      const matches = emojiPickerActor.getSnapshot().context.matches, selectedIndex = emojiPickerActor.getSnapshot().context.selectedIndex, emoji = matches[selectedIndex] ? config.parseMatch({\n        match: matches[selectedIndex]\n      }) : void 0, focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)({\n        context\n      }), emojiKeyword = `${textBefore}:`.match(emojiRegEx)?.[1];\n      if (!focusBlock || emojiKeyword === void 0)\n        return !1;\n      const emojiStringLength = emojiKeyword.length + 2;\n      return emoji ? {\n        focusBlock,\n        emoji,\n        emojiStringLength,\n        textBeforeLength: textBefore.length + 1\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert.text\",\n      text: \":\"\n    }], (_, params) => [{\n      type: \"effect\",\n      effect: () => {\n        emojiPickerActor.send({\n          type: \"select\"\n        });\n      }\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: params.focusBlock.path,\n        offset: params.textBeforeLength - params.emojiStringLength\n      },\n      focus: {\n        path: params.focusBlock.path,\n        offset: params.textBeforeLength\n      }\n    }, {\n      type: \"insert.text\",\n      text: params.emoji\n    }]]\n  }), (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"key.down\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const matches = emojiPickerActor.getSnapshot().context.matches;\n      if (matches.length === 0)\n        return !1;\n      if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(\"Escape\", event.keyboardEvent))\n        return {\n          action: \"reset\"\n        };\n      const isEnter = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(\"Enter\", event.keyboardEvent), isTab = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(\"Tab\", event.keyboardEvent);\n      if (isEnter || isTab) {\n        const selectedIndex = emojiPickerActor.getSnapshot().context.selectedIndex, emoji = matches[selectedIndex] ? config.parseMatch({\n          match: matches[selectedIndex]\n        }) : void 0;\n        if (!emoji)\n          return !1;\n        const focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n          context\n        }), textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)({\n          context\n        }), emojiKeyword = textBefore.match(incompleteEmojiRegEx)?.[1];\n        if (!focusBlock || emojiKeyword === void 0)\n          return !1;\n        const emojiStringLength = emojiKeyword.length + 1;\n        return emoji ? {\n          action: \"select\",\n          focusBlock,\n          emoji,\n          emojiStringLength,\n          textBeforeLength: textBefore.length\n        } : !1;\n      }\n      const isArrowDown = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(\"ArrowDown\", event.keyboardEvent), isArrowUp = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(\"ArrowUp\", event.keyboardEvent);\n      return isArrowDown && matches.length > 0 ? {\n        action: \"navigate down\"\n      } : isArrowUp && matches.length > 0 ? {\n        action: \"navigate up\"\n      } : !1;\n    },\n    actions: [(_, params) => params.action === \"select\" ? [{\n      type: \"effect\",\n      effect: () => {\n        emojiPickerActor.send({\n          type: \"select\"\n        });\n      }\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: params.focusBlock.path,\n        offset: params.textBeforeLength - params.emojiStringLength\n      },\n      focus: {\n        path: params.focusBlock.path,\n        offset: params.textBeforeLength\n      }\n    }, {\n      type: \"insert.text\",\n      text: params.emoji\n    }] : params.action === \"navigate up\" ? [\n      // If we are navigating then we want to hijack the key event and\n      // turn it into a noop.\n      {\n        type: \"noop\"\n      },\n      {\n        type: \"effect\",\n        effect: () => {\n          emojiPickerActor.send({\n            type: \"navigate up\"\n          });\n        }\n      }\n    ] : params.action === \"navigate down\" ? [\n      // If we are navigating then we want to hijack the key event and\n      // turn it into a noop.\n      {\n        type: \"noop\"\n      },\n      {\n        type: \"effect\",\n        effect: () => {\n          emojiPickerActor.send({\n            type: \"navigate down\"\n          });\n        }\n      }\n    ] : [{\n      type: \"effect\",\n      effect: () => {\n        emojiPickerActor.send({\n          type: \"reset\"\n        });\n      }\n    }]]\n  }), (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"delete.backward\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.unit !== \"character\" || emojiPickerActor.getSnapshot().context.matches.length === 0)\n        return !1;\n      const focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)({\n        context\n      }), emojiKeyword = textBefore.slice(0, textBefore.length - 1).match(incompleteEmojiRegEx)?.[1];\n      return !focusBlock || emojiKeyword === void 0 ? {\n        emojis: []\n      } : {\n        emojis: config.matchEmojis({\n          keyword: emojiKeyword\n        })\n      };\n    },\n    actions: [(_, params) => [{\n      type: \"effect\",\n      effect: () => {\n        emojiPickerActor.send({\n          type: \"emojis found\",\n          matches: params.emojis\n        });\n      }\n    }]]\n  })];\n}\nfunction createEmojiPickerMachine() {\n  return (0,xstate__WEBPACK_IMPORTED_MODULE_4__.setup)({\n    types: {\n      context: {},\n      events: {}\n    },\n    actions: {\n      \"assign matches\": (0,xstate__WEBPACK_IMPORTED_MODULE_5__.a)({\n        matches: ({\n          event\n        }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_4__.assertEvent)(event, \"emojis found\"), event.matches)\n      }),\n      \"reset matches\": (0,xstate__WEBPACK_IMPORTED_MODULE_5__.a)({\n        matches: []\n      }),\n      \"reset selected index\": (0,xstate__WEBPACK_IMPORTED_MODULE_5__.a)({\n        selectedIndex: 0\n      }),\n      \"increment selected index\": (0,xstate__WEBPACK_IMPORTED_MODULE_5__.a)({\n        selectedIndex: ({\n          context\n        }) => context.selectedIndex === context.matches.length - 1 ? 0 : context.selectedIndex + 1\n      }),\n      \"decrement selected index\": (0,xstate__WEBPACK_IMPORTED_MODULE_5__.a)({\n        selectedIndex: ({\n          context\n        }) => context.selectedIndex === 0 ? context.matches.length - 1 : context.selectedIndex - 1\n      })\n    },\n    guards: {\n      \"no matches\": ({\n        context\n      }) => context.matches.length === 0\n    }\n  }).createMachine({\n    id: \"emoji picker\",\n    context: {\n      matches: [],\n      selectedIndex: 0\n    },\n    initial: \"idle\",\n    states: {\n      idle: {\n        on: {\n          \"emojis found\": {\n            actions: \"assign matches\",\n            target: \"showing matches\"\n          }\n        }\n      },\n      \"showing matches\": {\n        always: {\n          guard: \"no matches\",\n          target: \"idle\"\n        },\n        exit: [\"reset selected index\"],\n        on: {\n          \"emojis found\": {\n            actions: \"assign matches\"\n          },\n          \"navigate down\": {\n            actions: \"increment selected index\"\n          },\n          \"navigate up\": {\n            actions: \"decrement selected index\"\n          },\n          reset: {\n            target: \"idle\",\n            actions: [\"reset selected index\", \"reset matches\"]\n          },\n          select: {\n            target: \"idle\",\n            actions: [\"reset selected index\", \"reset matches\"]\n          }\n        }\n      }\n    }\n  });\n}\nfunction looksLikeUrl(text) {\n  let looksLikeUrl2 = !1;\n  try {\n    const url = new URL(text);\n    if (!sensibleProtocols.includes(url.protocol))\n      return !1;\n    looksLikeUrl2 = !0;\n  } catch {\n  }\n  return looksLikeUrl2;\n}\nconst sensibleProtocols = [\"http:\", \"https:\", \"mailto:\", \"tel:\"];\nfunction createLinkBehaviors(config) {\n  const pasteLinkOnSelection = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      }), text = event.data.getData(\"text/plain\"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({\n        url,\n        schema: context.schema\n      }) : void 0;\n      return annotation && !selectionCollapsed ? {\n        annotation\n      } : !1;\n    },\n    actions: [(_, {\n      annotation\n    }) => [{\n      type: \"annotation.add\",\n      annotation\n    }]]\n  }), pasteLinkAtCaret = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const focusSpan = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n        context\n      }), selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      });\n      if (!focusSpan || !selectionCollapsed)\n        return !1;\n      const text = event.data.getData(\"text/plain\"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({\n        url,\n        schema: context.schema\n      }) : void 0;\n      return url && annotation && selectionCollapsed ? {\n        focusSpan,\n        annotation,\n        url\n      } : !1;\n    },\n    actions: [(_, {\n      annotation,\n      url\n    }) => [{\n      type: \"insert.span\",\n      text: url,\n      annotations: [annotation]\n    }]]\n  });\n  return [pasteLinkOnSelection, pasteLinkAtCaret];\n}\nfunction createMarkdownBehaviors(config) {\n  const automaticBlockquoteOnSpace = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      }), focusTextBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), focusSpan = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n        context\n      });\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.spanSelectionPointToBlockOffset)({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.getTextBlockText)(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.(context);\n      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert.text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      style\n    }) => [{\n      type: \"text block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }, {\n      type: \"text block.set\",\n      style,\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: 2\n      }\n    }]]\n  }), automaticHr = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const hrCharacter = event.text === \"-\" ? \"-\" : event.text === \"*\" ? \"*\" : event.text === \"_\" ? \"_\" : void 0;\n      if (hrCharacter === void 0)\n        return !1;\n      const hrObject = config.horizontalRuleObject?.(context), focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      });\n      if (!hrObject || !focusBlock || !selectionCollapsed)\n        return !1;\n      const textBefore = (0,_chunks_es_selector_get_text_before_js__WEBPACK_IMPORTED_MODULE_3__.getBlockTextBefore)({\n        context\n      }), hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3\n        }\n      };\n      return textBefore === `${hrCharacter}${hrCharacter}` ? {\n        hrObject,\n        focusBlock,\n        hrCharacter,\n        hrBlockOffsets\n      } : !1;\n    },\n    actions: [(_, {\n      hrCharacter\n    }) => [{\n      type: \"insert.text\",\n      text: hrCharacter\n    }], (_, {\n      hrObject,\n      hrBlockOffsets\n    }) => [{\n      type: \"insert.block object\",\n      placement: \"before\",\n      blockObject: hrObject\n    }, {\n      type: \"delete.text\",\n      ...hrBlockOffsets\n    }]]\n  }), automaticHrOnPaste = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const text = event.data.getData(\"text/plain\"), hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.(context), focusBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlock)({\n        context\n      });\n      return !hrCharacters || !hrObject || !focusBlock ? !1 : {\n        hrCharacters,\n        hrObject,\n        focusBlock\n      };\n    },\n    actions: [(_, {\n      hrCharacters\n    }) => [{\n      type: \"insert.text\",\n      text: hrCharacters\n    }], (_, {\n      hrObject,\n      focusBlock\n    }) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_7__.isPortableTextTextBlock)(focusBlock.node) ? [{\n      type: \"insert.text block\",\n      textBlock: {\n        children: focusBlock.node.children\n      },\n      placement: \"after\"\n    }, {\n      type: \"insert.block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }, {\n      type: \"delete.block\",\n      blockPath: focusBlock.path\n    }] : [{\n      type: \"insert.block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }]]\n  }), automaticHeadingOnSpace = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      }), focusTextBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), focusSpan = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n        context\n      });\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.spanSelectionPointToBlockOffset)({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.getTextBlockText)(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0;\n      if (blockOffset.offset !== level)\n        return !1;\n      const style = level !== void 0 ? config.headingStyle?.({\n        schema: context.schema,\n        level\n      }) : void 0;\n      return level !== void 0 && style !== void 0 ? {\n        focusTextBlock,\n        style,\n        level\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [event], (_, {\n      focusTextBlock,\n      style,\n      level\n    }) => [{\n      type: \"text block.unset\",\n      props: [\"listItem\", \"level\"],\n      at: focusTextBlock.path\n    }, {\n      type: \"text block.set\",\n      style,\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: level + 1\n      }\n    }]]\n  }), clearStyleOnBackspace = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"delete.backward\",\n    guard: ({\n      context\n    }) => {\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      }), focusTextBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), focusSpan = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n        context\n      });\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0, defaultStyle = config.defaultStyle?.(context);\n      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [{\n      type: \"text block.set\",\n      style: defaultStyle,\n      at: focusTextBlock.path\n    }]]\n  }), automaticListOnSpace = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_0__.defineBehavior)({\n    on: \"insert.text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n        context\n      }), focusTextBlock = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n        context\n      }), focusSpan = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n        context\n      });\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.spanSelectionPointToBlockOffset)({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection?.focus.offset ?? 0\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_6__.getTextBlockText)(focusTextBlock.node), defaultStyle = config.defaultStyle?.(context), looksLikeUnorderedList = /^(-|\\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.(context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;\n      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle\n        };\n      const looksLikeOrderedList = /^1\\./.test(blockText), orderedListStyle = config.orderedListStyle?.(context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;\n      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        listItem: orderedListStyle,\n        listItemLength: 2,\n        style: defaultStyle\n      } : !1;\n    },\n    actions: [({\n      event\n    }) => [event], (_, {\n      focusTextBlock,\n      style,\n      listItem,\n      listItemLength\n    }) => [{\n      type: \"text block.set\",\n      listItem,\n      level: 1,\n      style,\n      at: focusTextBlock.path\n    }, {\n      type: \"delete.text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: listItemLength + 1\n      }\n    }]]\n  });\n  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2JlaGF2aW9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBFO0FBQ1U7QUFDb0c7QUFDdkg7QUFDYztBQUN2QjtBQUNzRDtBQUM5RztBQUNBLFVBQVUsMkVBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCLHFFQUFRLGdFQUFnRSw0RkFBYTtBQUNwSDtBQUNBLE9BQU8sb0JBQW9CLGdHQUFpQjtBQUM1QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsR0FBRywyRUFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMscUVBQVEsaUVBQWlFLDJGQUFZO0FBQ3RIO0FBQ0EsT0FBTyxvQkFBb0IsZ0dBQWlCO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQSwyQkFBMkIseUNBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSSwyRUFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0dBQWlCO0FBQzFDO0FBQ0EsT0FBTyxxQkFBcUIsMEZBQWtCO0FBQzlDO0FBQ0EsT0FBTyxFQUFFLEVBQUUsV0FBVztBQUN0QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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ZUFBZSwyRkFBWTtBQUNsQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLHVHQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0Isd0ZBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvYmVoYXZpb3JzL2luZGV4LmpzPzc3MjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lQmVoYXZpb3IsIGlzSG90a2V5IH0gZnJvbSBcIi4uL19jaHVua3MtZXMvYmVoYXZpb3IuY29yZS5qc1wiO1xuaW1wb3J0IHsgY29yZUJlaGF2aW9yLCBjb3JlQmVoYXZpb3JzLCByYWlzZSB9IGZyb20gXCIuLi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanNcIjtcbmltcG9ydCB7IGdldEZpcnN0QmxvY2ssIGdldFNlbGVjdGVkQmxvY2tzLCBnZXRMYXN0QmxvY2ssIGdldEZvY3VzVGV4dEJsb2NrLCBpc1NlbGVjdGlvbkNvbGxhcHNlZCwgZ2V0Rm9jdXNTcGFuLCBnZXRGb2N1c0Jsb2NrIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQWN0b3IsIHNldHVwLCBhc3NpZ24sIGFzc2VydEV2ZW50IH0gZnJvbSBcInhzdGF0ZVwiO1xuaW1wb3J0IHsgZ2V0QmxvY2tUZXh0QmVmb3JlIH0gZnJvbSBcIi4uL19jaHVua3MtZXMvc2VsZWN0b3IuZ2V0LXRleHQtYmVmb3JlLmpzXCI7XG5pbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgeyBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0LCBnZXRUZXh0QmxvY2tUZXh0IH0gZnJvbSBcIi4uL19jaHVua3MtZXMvdXRpbC5pcy1lbXB0eS10ZXh0LWJsb2NrLmpzXCI7XG5mdW5jdGlvbiBjcmVhdGVDb2RlRWRpdG9yQmVoYXZpb3JzKGNvbmZpZykge1xuICByZXR1cm4gW2RlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJrZXkuZG93blwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaXNNb3ZlVXBTaG9ydGN1dCA9IGlzSG90a2V5KGNvbmZpZy5tb3ZlQmxvY2tVcFNob3J0Y3V0LCBldmVudC5rZXlib2FyZEV2ZW50KSwgZmlyc3RCbG9jayA9IGdldEZpcnN0QmxvY2soe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSwgc2VsZWN0ZWRCbG9ja3MgPSBnZXRTZWxlY3RlZEJsb2Nrcyh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBibG9ja3NBYm92ZSA9IGZpcnN0QmxvY2s/Lm5vZGUuX2tleSAhPT0gc2VsZWN0ZWRCbG9ja3NbMF0/Lm5vZGUuX2tleTtcbiAgICAgIHJldHVybiAhaXNNb3ZlVXBTaG9ydGN1dCB8fCAhYmxvY2tzQWJvdmUgPyAhMSA6IHtcbiAgICAgICAgcGF0aHM6IHNlbGVjdGVkQmxvY2tzLm1hcCgoYmxvY2spID0+IGJsb2NrLnBhdGgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBwYXRoc1xuICAgIH0pID0+IHBhdGhzLm1hcCgoYXQpID0+ICh7XG4gICAgICB0eXBlOiBcIm1vdmUuYmxvY2sgdXBcIixcbiAgICAgIGF0XG4gICAgfSkpXVxuICB9KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleS5kb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBpc01vdmVEb3duU2hvcnRjdXQgPSBpc0hvdGtleShjb25maWcubW92ZUJsb2NrRG93blNob3J0Y3V0LCBldmVudC5rZXlib2FyZEV2ZW50KSwgbGFzdEJsb2NrID0gZ2V0TGFzdEJsb2NrKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSwgYmxvY2tzQmVsb3cgPSBsYXN0QmxvY2s/Lm5vZGUuX2tleSAhPT0gc2VsZWN0ZWRCbG9ja3Nbc2VsZWN0ZWRCbG9ja3MubGVuZ3RoIC0gMV0/Lm5vZGUuX2tleTtcbiAgICAgIHJldHVybiAhaXNNb3ZlRG93blNob3J0Y3V0IHx8ICFibG9ja3NCZWxvdyA/ICExIDoge1xuICAgICAgICBwYXRoczogc2VsZWN0ZWRCbG9ja3MubWFwKChibG9jaykgPT4gYmxvY2sucGF0aCkucmV2ZXJzZSgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBwYXRoc1xuICAgIH0pID0+IHBhdGhzLm1hcCgoYXQpID0+ICh7XG4gICAgICB0eXBlOiBcIm1vdmUuYmxvY2sgZG93blwiLFxuICAgICAgYXRcbiAgICB9KSldXG4gIH0pXTtcbn1cbmNvbnN0IGVtb2ppQ2hhclJlZ0V4ID0gL15bYS16QS1aLV8wLTldezF9JC8sIGluY29tcGxldGVFbW9qaVJlZ0V4ID0gLzooW2EtekEtWi1fMC05XSspJC8sIGVtb2ppUmVnRXggPSAvOihbYS16QS1aLV8wLTldKyk6JC87XG5mdW5jdGlvbiBjcmVhdGVFbW9qaVBpY2tlckJlaGF2aW9ycyhjb25maWcpIHtcbiAgY29uc3QgZW1vamlQaWNrZXJBY3RvciA9IGNyZWF0ZUFjdG9yKGNyZWF0ZUVtb2ppUGlja2VyTWFjaGluZSgpKTtcbiAgcmV0dXJuIGVtb2ppUGlja2VyQWN0b3Iuc3RhcnQoKSwgZW1vamlQaWNrZXJBY3Rvci5zdWJzY3JpYmUoKHN0YXRlKSA9PiB7XG4gICAgY29uZmlnLm9uTWF0Y2hlc0NoYW5nZWQoe1xuICAgICAgbWF0Y2hlczogc3RhdGUuY29udGV4dC5tYXRjaGVzXG4gICAgfSksIGNvbmZpZy5vblNlbGVjdGVkSW5kZXhDaGFuZ2VkKHtcbiAgICAgIHNlbGVjdGVkSW5kZXg6IHN0YXRlLmNvbnRleHQuc2VsZWN0ZWRJbmRleFxuICAgIH0pO1xuICB9KSwgW2RlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRleHQgPT09IFwiOlwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoIWVtb2ppQ2hhclJlZ0V4LnRlc3QoZXZlbnQudGV4dCkpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW1vamlzOiBbXVxuICAgICAgICB9O1xuICAgICAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIGVtb2ppS2V5d29yZCA9IGAke2dldEJsb2NrVGV4dEJlZm9yZSh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pfSR7ZXZlbnQudGV4dH1gLm1hdGNoKGluY29tcGxldGVFbW9qaVJlZ0V4KT8uWzFdO1xuICAgICAgcmV0dXJuICFmb2N1c0Jsb2NrIHx8IGVtb2ppS2V5d29yZCA9PT0gdm9pZCAwID8ge1xuICAgICAgICBlbW9qaXM6IFtdXG4gICAgICB9IDoge1xuICAgICAgICBlbW9qaXM6IGNvbmZpZy5tYXRjaEVtb2ppcyh7XG4gICAgICAgICAga2V5d29yZDogZW1vamlLZXl3b3JkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCBwYXJhbXMpID0+IFt7XG4gICAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgICAgZWZmZWN0OiAoKSA9PiB7XG4gICAgICAgIGVtb2ppUGlja2VyQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJlbW9qaXMgZm91bmRcIixcbiAgICAgICAgICBtYXRjaGVzOiBwYXJhbXMuZW1vamlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dXVxuICB9KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCI6XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBlbW9qaVBpY2tlckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5tYXRjaGVzLCBzZWxlY3RlZEluZGV4ID0gZW1vamlQaWNrZXJBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2VsZWN0ZWRJbmRleCwgZW1vamkgPSBtYXRjaGVzW3NlbGVjdGVkSW5kZXhdID8gY29uZmlnLnBhcnNlTWF0Y2goe1xuICAgICAgICBtYXRjaDogbWF0Y2hlc1tzZWxlY3RlZEluZGV4XVxuICAgICAgfSkgOiB2b2lkIDAsIGZvY3VzQmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCB0ZXh0QmVmb3JlID0gZ2V0QmxvY2tUZXh0QmVmb3JlKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIGVtb2ppS2V5d29yZCA9IGAke3RleHRCZWZvcmV9OmAubWF0Y2goZW1vamlSZWdFeCk/LlsxXTtcbiAgICAgIGlmICghZm9jdXNCbG9jayB8fCBlbW9qaUtleXdvcmQgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgZW1vamlTdHJpbmdMZW5ndGggPSBlbW9qaUtleXdvcmQubGVuZ3RoICsgMjtcbiAgICAgIHJldHVybiBlbW9qaSA/IHtcbiAgICAgICAgZm9jdXNCbG9jayxcbiAgICAgICAgZW1vamksXG4gICAgICAgIGVtb2ppU3RyaW5nTGVuZ3RoLFxuICAgICAgICB0ZXh0QmVmb3JlTGVuZ3RoOiB0ZXh0QmVmb3JlLmxlbmd0aCArIDFcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgdGV4dDogXCI6XCJcbiAgICB9XSwgKF8sIHBhcmFtcykgPT4gW3tcbiAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgZW1vamlQaWNrZXJBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBwYXJhbXMuZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IHBhcmFtcy50ZXh0QmVmb3JlTGVuZ3RoIC0gcGFyYW1zLmVtb2ppU3RyaW5nTGVuZ3RoXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcGFyYW1zLmZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiBwYXJhbXMudGV4dEJlZm9yZUxlbmd0aFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IHBhcmFtcy5lbW9qaVxuICAgIH1dXVxuICB9KSwgZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImtleS5kb3duXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZW1vamlQaWNrZXJBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF0Y2hlcztcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGlzSG90a2V5KFwiRXNjYXBlXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogXCJyZXNldFwiXG4gICAgICAgIH07XG4gICAgICBjb25zdCBpc0VudGVyID0gaXNIb3RrZXkoXCJFbnRlclwiLCBldmVudC5rZXlib2FyZEV2ZW50KSwgaXNUYWIgPSBpc0hvdGtleShcIlRhYlwiLCBldmVudC5rZXlib2FyZEV2ZW50KTtcbiAgICAgIGlmIChpc0VudGVyIHx8IGlzVGFiKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBlbW9qaVBpY2tlckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zZWxlY3RlZEluZGV4LCBlbW9qaSA9IG1hdGNoZXNbc2VsZWN0ZWRJbmRleF0gPyBjb25maWcucGFyc2VNYXRjaCh7XG4gICAgICAgICAgbWF0Y2g6IG1hdGNoZXNbc2VsZWN0ZWRJbmRleF1cbiAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgIGlmICghZW1vamkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSksIHRleHRCZWZvcmUgPSBnZXRCbG9ja1RleHRCZWZvcmUoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSksIGVtb2ppS2V5d29yZCA9IHRleHRCZWZvcmUubWF0Y2goaW5jb21wbGV0ZUVtb2ppUmVnRXgpPy5bMV07XG4gICAgICAgIGlmICghZm9jdXNCbG9jayB8fCBlbW9qaUtleXdvcmQgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGVtb2ppU3RyaW5nTGVuZ3RoID0gZW1vamlLZXl3b3JkLmxlbmd0aCArIDE7XG4gICAgICAgIHJldHVybiBlbW9qaSA/IHtcbiAgICAgICAgICBhY3Rpb246IFwic2VsZWN0XCIsXG4gICAgICAgICAgZm9jdXNCbG9jayxcbiAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICBlbW9qaVN0cmluZ0xlbmd0aCxcbiAgICAgICAgICB0ZXh0QmVmb3JlTGVuZ3RoOiB0ZXh0QmVmb3JlLmxlbmd0aFxuICAgICAgICB9IDogITE7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0Fycm93RG93biA9IGlzSG90a2V5KFwiQXJyb3dEb3duXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpLCBpc0Fycm93VXAgPSBpc0hvdGtleShcIkFycm93VXBcIiwgZXZlbnQua2V5Ym9hcmRFdmVudCk7XG4gICAgICByZXR1cm4gaXNBcnJvd0Rvd24gJiYgbWF0Y2hlcy5sZW5ndGggPiAwID8ge1xuICAgICAgICBhY3Rpb246IFwibmF2aWdhdGUgZG93blwiXG4gICAgICB9IDogaXNBcnJvd1VwICYmIG1hdGNoZXMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgYWN0aW9uOiBcIm5hdmlnYXRlIHVwXCJcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywgcGFyYW1zKSA9PiBwYXJhbXMuYWN0aW9uID09PSBcInNlbGVjdFwiID8gW3tcbiAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgZW1vamlQaWNrZXJBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBwYXJhbXMuZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IHBhcmFtcy50ZXh0QmVmb3JlTGVuZ3RoIC0gcGFyYW1zLmVtb2ppU3RyaW5nTGVuZ3RoXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcGFyYW1zLmZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiBwYXJhbXMudGV4dEJlZm9yZUxlbmd0aFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgIHRleHQ6IHBhcmFtcy5lbW9qaVxuICAgIH1dIDogcGFyYW1zLmFjdGlvbiA9PT0gXCJuYXZpZ2F0ZSB1cFwiID8gW1xuICAgICAgLy8gSWYgd2UgYXJlIG5hdmlnYXRpbmcgdGhlbiB3ZSB3YW50IHRvIGhpamFjayB0aGUga2V5IGV2ZW50IGFuZFxuICAgICAgLy8gdHVybiBpdCBpbnRvIGEgbm9vcC5cbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJub29wXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGVtb2ppUGlja2VyQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5hdmlnYXRlIHVwXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0gOiBwYXJhbXMuYWN0aW9uID09PSBcIm5hdmlnYXRlIGRvd25cIiA/IFtcbiAgICAgIC8vIElmIHdlIGFyZSBuYXZpZ2F0aW5nIHRoZW4gd2Ugd2FudCB0byBoaWphY2sgdGhlIGtleSBldmVudCBhbmRcbiAgICAgIC8vIHR1cm4gaXQgaW50byBhIG5vb3AuXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibm9vcFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImVmZmVjdFwiLFxuICAgICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgICBlbW9qaVBpY2tlckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJuYXZpZ2F0ZSBkb3duXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF0gOiBbe1xuICAgICAgdHlwZTogXCJlZmZlY3RcIixcbiAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICBlbW9qaVBpY2tlckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwicmVzZXRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XV1cbiAgfSksIGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC51bml0ICE9PSBcImNoYXJhY3RlclwiIHx8IGVtb2ppUGlja2VyQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0Lm1hdGNoZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSwgdGV4dEJlZm9yZSA9IGdldEJsb2NrVGV4dEJlZm9yZSh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBlbW9qaUtleXdvcmQgPSB0ZXh0QmVmb3JlLnNsaWNlKDAsIHRleHRCZWZvcmUubGVuZ3RoIC0gMSkubWF0Y2goaW5jb21wbGV0ZUVtb2ppUmVnRXgpPy5bMV07XG4gICAgICByZXR1cm4gIWZvY3VzQmxvY2sgfHwgZW1vamlLZXl3b3JkID09PSB2b2lkIDAgPyB7XG4gICAgICAgIGVtb2ppczogW11cbiAgICAgIH0gOiB7XG4gICAgICAgIGVtb2ppczogY29uZmlnLm1hdGNoRW1vamlzKHtcbiAgICAgICAgICBrZXl3b3JkOiBlbW9qaUtleXdvcmRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHBhcmFtcykgPT4gW3tcbiAgICAgIHR5cGU6IFwiZWZmZWN0XCIsXG4gICAgICBlZmZlY3Q6ICgpID0+IHtcbiAgICAgICAgZW1vamlQaWNrZXJBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImVtb2ppcyBmb3VuZFwiLFxuICAgICAgICAgIG1hdGNoZXM6IHBhcmFtcy5lbW9qaXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV1dXG4gIH0pXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtb2ppUGlja2VyTWFjaGluZSgpIHtcbiAgcmV0dXJuIHNldHVwKHtcbiAgICB0eXBlczoge1xuICAgICAgY29udGV4dDoge30sXG4gICAgICBldmVudHM6IHt9XG4gICAgfSxcbiAgICBhY3Rpb25zOiB7XG4gICAgICBcImFzc2lnbiBtYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICAgIG1hdGNoZXM6ICh7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImVtb2ppcyBmb3VuZFwiKSwgZXZlbnQubWF0Y2hlcylcbiAgICAgIH0pLFxuICAgICAgXCJyZXNldCBtYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICAgIG1hdGNoZXM6IFtdXG4gICAgICB9KSxcbiAgICAgIFwicmVzZXQgc2VsZWN0ZWQgaW5kZXhcIjogYXNzaWduKHtcbiAgICAgICAgc2VsZWN0ZWRJbmRleDogMFxuICAgICAgfSksXG4gICAgICBcImluY3JlbWVudCBzZWxlY3RlZCBpbmRleFwiOiBhc3NpZ24oe1xuICAgICAgICBzZWxlY3RlZEluZGV4OiAoe1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSkgPT4gY29udGV4dC5zZWxlY3RlZEluZGV4ID09PSBjb250ZXh0Lm1hdGNoZXMubGVuZ3RoIC0gMSA/IDAgOiBjb250ZXh0LnNlbGVjdGVkSW5kZXggKyAxXG4gICAgICB9KSxcbiAgICAgIFwiZGVjcmVtZW50IHNlbGVjdGVkIGluZGV4XCI6IGFzc2lnbih7XG4gICAgICAgIHNlbGVjdGVkSW5kZXg6ICh7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KSA9PiBjb250ZXh0LnNlbGVjdGVkSW5kZXggPT09IDAgPyBjb250ZXh0Lm1hdGNoZXMubGVuZ3RoIC0gMSA6IGNvbnRleHQuc2VsZWN0ZWRJbmRleCAtIDFcbiAgICAgIH0pXG4gICAgfSxcbiAgICBndWFyZHM6IHtcbiAgICAgIFwibm8gbWF0Y2hlc1wiOiAoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSA9PiBjb250ZXh0Lm1hdGNoZXMubGVuZ3RoID09PSAwXG4gICAgfVxuICB9KS5jcmVhdGVNYWNoaW5lKHtcbiAgICBpZDogXCJlbW9qaSBwaWNrZXJcIixcbiAgICBjb250ZXh0OiB7XG4gICAgICBtYXRjaGVzOiBbXSxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IDBcbiAgICB9LFxuICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgIHN0YXRlczoge1xuICAgICAgaWRsZToge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIFwiZW1vamlzIGZvdW5kXCI6IHtcbiAgICAgICAgICAgIGFjdGlvbnM6IFwiYXNzaWduIG1hdGNoZXNcIixcbiAgICAgICAgICAgIHRhcmdldDogXCJzaG93aW5nIG1hdGNoZXNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwic2hvd2luZyBtYXRjaGVzXCI6IHtcbiAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgZ3VhcmQ6IFwibm8gbWF0Y2hlc1wiLFxuICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgZXhpdDogW1wicmVzZXQgc2VsZWN0ZWQgaW5kZXhcIl0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgXCJlbW9qaXMgZm91bmRcIjoge1xuICAgICAgICAgICAgYWN0aW9uczogXCJhc3NpZ24gbWF0Y2hlc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm5hdmlnYXRlIGRvd25cIjoge1xuICAgICAgICAgICAgYWN0aW9uczogXCJpbmNyZW1lbnQgc2VsZWN0ZWQgaW5kZXhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJuYXZpZ2F0ZSB1cFwiOiB7XG4gICAgICAgICAgICBhY3Rpb25zOiBcImRlY3JlbWVudCBzZWxlY3RlZCBpbmRleFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcInJlc2V0IHNlbGVjdGVkIGluZGV4XCIsIFwicmVzZXQgbWF0Y2hlc1wiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wicmVzZXQgc2VsZWN0ZWQgaW5kZXhcIiwgXCJyZXNldCBtYXRjaGVzXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZVVybCh0ZXh0KSB7XG4gIGxldCBsb29rc0xpa2VVcmwyID0gITE7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0ZXh0KTtcbiAgICBpZiAoIXNlbnNpYmxlUHJvdG9jb2xzLmluY2x1ZGVzKHVybC5wcm90b2NvbCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgbG9va3NMaWtlVXJsMiA9ICEwO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbG9va3NMaWtlVXJsMjtcbn1cbmNvbnN0IHNlbnNpYmxlUHJvdG9jb2xzID0gW1wiaHR0cDpcIiwgXCJodHRwczpcIiwgXCJtYWlsdG86XCIsIFwidGVsOlwiXTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtCZWhhdmlvcnMoY29uZmlnKSB7XG4gIGNvbnN0IHBhc3RlTGlua09uU2VsZWN0aW9uID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCB0ZXh0ID0gZXZlbnQuZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgdXJsID0gbG9va3NMaWtlVXJsKHRleHQpID8gdGV4dCA6IHZvaWQgMCwgYW5ub3RhdGlvbiA9IHVybCAhPT0gdm9pZCAwID8gY29uZmlnLmxpbmtBbm5vdGF0aW9uPy4oe1xuICAgICAgICB1cmwsXG4gICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGFubm90YXRpb24gJiYgIXNlbGVjdGlvbkNvbGxhcHNlZCA/IHtcbiAgICAgICAgYW5ub3RhdGlvblxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWyhfLCB7XG4gICAgICBhbm5vdGF0aW9uXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgIGFubm90YXRpb25cbiAgICB9XV1cbiAgfSksIHBhc3RlTGlua0F0Q2FyZXQgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwicGFzdGVcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbih7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmb2N1c1NwYW4gfHwgIXNlbGVjdGlvbkNvbGxhcHNlZClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIHVybCA9IGxvb2tzTGlrZVVybCh0ZXh0KSA/IHRleHQgOiB2b2lkIDAsIGFubm90YXRpb24gPSB1cmwgIT09IHZvaWQgMCA/IGNvbmZpZy5saW5rQW5ub3RhdGlvbj8uKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB1cmwgJiYgYW5ub3RhdGlvbiAmJiBzZWxlY3Rpb25Db2xsYXBzZWQgPyB7XG4gICAgICAgIGZvY3VzU3BhbixcbiAgICAgICAgYW5ub3RhdGlvbixcbiAgICAgICAgdXJsXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGFubm90YXRpb24sXG4gICAgICB1cmxcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQuc3BhblwiLFxuICAgICAgdGV4dDogdXJsLFxuICAgICAgYW5ub3RhdGlvbnM6IFthbm5vdGF0aW9uXVxuICAgIH1dXVxuICB9KTtcbiAgcmV0dXJuIFtwYXN0ZUxpbmtPblNlbGVjdGlvbiwgcGFzdGVMaW5rQXRDYXJldF07XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyhjb25maWcpIHtcbiAgY29uc3QgYXV0b21hdGljQmxvY2txdW90ZU9uU3BhY2UgPSBkZWZpbmVCZWhhdmlvcih7XG4gICAgb246IFwiaW5zZXJ0LnRleHRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChldmVudC50ZXh0ICE9PSBcIiBcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBibG9ja09mZnNldCA9IHNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQoe1xuICAgICAgICB2YWx1ZTogY29udGV4dC52YWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uUG9pbnQ6IHtcbiAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgX2tleTogZm9jdXNUZXh0QmxvY2subm9kZS5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1NwYW4ubm9kZS5fa2V5XG4gICAgICAgICAgfV0sXG4gICAgICAgICAgb2Zmc2V0OiBjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID8/IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWJsb2NrT2Zmc2V0KVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBibG9ja1RleHQgPSBnZXRUZXh0QmxvY2tUZXh0KGZvY3VzVGV4dEJsb2NrLm5vZGUpLCBjYXJldEF0VGhlRW5kT2ZRdW90ZSA9IGJsb2NrT2Zmc2V0Lm9mZnNldCA9PT0gMSwgbG9va3NMaWtlTWFya2Rvd25RdW90ZSA9IC9ePi8udGVzdChibG9ja1RleHQpLCBibG9ja3F1b3RlU3R5bGUgPSBjb25maWcuYmxvY2txdW90ZVN0eWxlPy4oY29udGV4dCk7XG4gICAgICByZXR1cm4gY2FyZXRBdFRoZUVuZE9mUXVvdGUgJiYgbG9va3NMaWtlTWFya2Rvd25RdW90ZSAmJiBibG9ja3F1b3RlU3R5bGUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIHN0eWxlOiBibG9ja3F1b3RlU3R5bGVcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgdGV4dDogXCIgXCJcbiAgICB9XSwgKF8sIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgc3R5bGVcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnVuc2V0XCIsXG4gICAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnNldFwiLFxuICAgICAgc3R5bGUsXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiZGVsZXRlLnRleHRcIixcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDJcbiAgICAgIH1cbiAgICB9XV1cbiAgfSksIGF1dG9tYXRpY0hyID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcImluc2VydC50ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBockNoYXJhY3RlciA9IGV2ZW50LnRleHQgPT09IFwiLVwiID8gXCItXCIgOiBldmVudC50ZXh0ID09PSBcIipcIiA/IFwiKlwiIDogZXZlbnQudGV4dCA9PT0gXCJfXCIgPyBcIl9cIiA6IHZvaWQgMDtcbiAgICAgIGlmIChockNoYXJhY3RlciA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBock9iamVjdCA9IGNvbmZpZy5ob3Jpem9udGFsUnVsZU9iamVjdD8uKGNvbnRleHQpLCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmICghaHJPYmplY3QgfHwgIWZvY3VzQmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgdGV4dEJlZm9yZSA9IGdldEJsb2NrVGV4dEJlZm9yZSh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBockJsb2NrT2Zmc2V0cyA9IHtcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogZm9jdXNCbG9jay5wYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0ZXh0QmVmb3JlID09PSBgJHtockNoYXJhY3Rlcn0ke2hyQ2hhcmFjdGVyfWAgPyB7XG4gICAgICAgIGhyT2JqZWN0LFxuICAgICAgICBmb2N1c0Jsb2NrLFxuICAgICAgICBockNoYXJhY3RlcixcbiAgICAgICAgaHJCbG9ja09mZnNldHNcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgaHJDaGFyYWN0ZXJcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dFwiLFxuICAgICAgdGV4dDogaHJDaGFyYWN0ZXJcbiAgICB9XSwgKF8sIHtcbiAgICAgIGhyT2JqZWN0LFxuICAgICAgaHJCbG9ja09mZnNldHNcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgICBwbGFjZW1lbnQ6IFwiYmVmb3JlXCIsXG4gICAgICBibG9ja09iamVjdDogaHJPYmplY3RcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICAuLi5ockJsb2NrT2Zmc2V0c1xuICAgIH1dXVxuICB9KSwgYXV0b21hdGljSHJPblBhc3RlID0gZGVmaW5lQmVoYXZpb3Ioe1xuICAgIG9uOiBcInBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgaHJSZWdFeHAgPSAvXigtLS0pJHwoX19fKSR8KFxcKlxcKlxcKikkL2dtLCBockNoYXJhY3RlcnMgPSB0ZXh0Lm1hdGNoKGhyUmVnRXhwKT8uWzBdLCBock9iamVjdCA9IGNvbmZpZy5ob3Jpem9udGFsUnVsZU9iamVjdD8uKGNvbnRleHQpLCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFockNoYXJhY3RlcnMgfHwgIWhyT2JqZWN0IHx8ICFmb2N1c0Jsb2NrID8gITEgOiB7XG4gICAgICAgIGhyQ2hhcmFjdGVycyxcbiAgICAgICAgaHJPYmplY3QsXG4gICAgICAgIGZvY3VzQmxvY2tcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGhyQ2hhcmFjdGVyc1xuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImluc2VydC50ZXh0XCIsXG4gICAgICB0ZXh0OiBockNoYXJhY3RlcnNcbiAgICB9XSwgKF8sIHtcbiAgICAgIGhyT2JqZWN0LFxuICAgICAgZm9jdXNCbG9ja1xuICAgIH0pID0+IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQudGV4dCBibG9ja1wiLFxuICAgICAgdGV4dEJsb2NrOiB7XG4gICAgICAgIGNoaWxkcmVuOiBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW5cbiAgICAgIH0sXG4gICAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiLFxuICAgICAgYmxvY2tPYmplY3Q6IGhyT2JqZWN0LFxuICAgICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZS5ibG9ja1wiLFxuICAgICAgYmxvY2tQYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgICB9XSA6IFt7XG4gICAgICB0eXBlOiBcImluc2VydC5ibG9jayBvYmplY3RcIixcbiAgICAgIGJsb2NrT2JqZWN0OiBock9iamVjdCxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfV1dXG4gIH0pLCBhdXRvbWF0aWNIZWFkaW5nT25TcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRleHQgIT09IFwiIFwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbih7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0LnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IGNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPz8gMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIG1hcmtkb3duSGVhZGluZ1NlYXJjaCA9IC9eIysvLmV4ZWMoYmxvY2tUZXh0KSwgbGV2ZWwgPSBtYXJrZG93bkhlYWRpbmdTZWFyY2ggPyBtYXJrZG93bkhlYWRpbmdTZWFyY2hbMF0ubGVuZ3RoIDogdm9pZCAwO1xuICAgICAgaWYgKGJsb2NrT2Zmc2V0Lm9mZnNldCAhPT0gbGV2ZWwpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHN0eWxlID0gbGV2ZWwgIT09IHZvaWQgMCA/IGNvbmZpZy5oZWFkaW5nU3R5bGU/Lih7XG4gICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgIGxldmVsXG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBsZXZlbCAhPT0gdm9pZCAwICYmIHN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgbGV2ZWxcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiBbZXZlbnRdLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZSxcbiAgICAgIGxldmVsXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwidGV4dCBibG9jay51bnNldFwiLFxuICAgICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidGV4dCBibG9jay5zZXRcIixcbiAgICAgIHN0eWxlLFxuICAgICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZS50ZXh0XCIsXG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiBsZXZlbCArIDFcbiAgICAgIH1cbiAgICB9XV1cbiAgfSksIGNsZWFyU3R5bGVPbkJhY2tzcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICBndWFyZDogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbih7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGF0VGhlQmVnaW5uaW5nT2ZCTG9jayA9IGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleSA9PT0gZm9jdXNTcGFuLm5vZGUuX2tleSAmJiBjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID09PSAwLCBkZWZhdWx0U3R5bGUgPSBjb25maWcuZGVmYXVsdFN0eWxlPy4oY29udGV4dCk7XG4gICAgICByZXR1cm4gYXRUaGVCZWdpbm5pbmdPZkJMb2NrICYmIGRlZmF1bHRTdHlsZSAmJiBmb2N1c1RleHRCbG9jay5ub2RlLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgPyB7XG4gICAgICAgIGRlZmF1bHRTdHlsZSxcbiAgICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnNldFwiLFxuICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfV1dXG4gIH0pLCBhdXRvbWF0aWNMaXN0T25TcGFjZSA9IGRlZmluZUJlaGF2aW9yKHtcbiAgICBvbjogXCJpbnNlcnQudGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRleHQgIT09IFwiIFwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbih7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0LnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IGNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQgPz8gMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIGRlZmF1bHRTdHlsZSA9IGNvbmZpZy5kZWZhdWx0U3R5bGU/Lihjb250ZXh0KSwgbG9va3NMaWtlVW5vcmRlcmVkTGlzdCA9IC9eKC18XFwqKS8udGVzdChibG9ja1RleHQpLCB1bm9yZGVyZWRMaXN0U3R5bGUgPSBjb25maWcudW5vcmRlcmVkTGlzdFN0eWxlPy4oY29udGV4dCksIGNhcmV0QXRUaGVFbmRPZlVub3JkZXJlZExpc3QgPSBibG9ja09mZnNldC5vZmZzZXQgPT09IDE7XG4gICAgICBpZiAoZGVmYXVsdFN0eWxlICYmIGNhcmV0QXRUaGVFbmRPZlVub3JkZXJlZExpc3QgJiYgbG9va3NMaWtlVW5vcmRlcmVkTGlzdCAmJiB1bm9yZGVyZWRMaXN0U3R5bGUgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgICBsaXN0SXRlbTogdW5vcmRlcmVkTGlzdFN0eWxlLFxuICAgICAgICAgIGxpc3RJdGVtTGVuZ3RoOiAxLFxuICAgICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGxvb2tzTGlrZU9yZGVyZWRMaXN0ID0gL14xXFwuLy50ZXN0KGJsb2NrVGV4dCksIG9yZGVyZWRMaXN0U3R5bGUgPSBjb25maWcub3JkZXJlZExpc3RTdHlsZT8uKGNvbnRleHQpLCBjYXJldEF0VGhlRW5kT2ZPcmRlcmVkTGlzdCA9IGJsb2NrT2Zmc2V0Lm9mZnNldCA9PT0gMjtcbiAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgJiYgY2FyZXRBdFRoZUVuZE9mT3JkZXJlZExpc3QgJiYgbG9va3NMaWtlT3JkZXJlZExpc3QgJiYgb3JkZXJlZExpc3RTdHlsZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgbGlzdEl0ZW06IG9yZGVyZWRMaXN0U3R5bGUsXG4gICAgICAgIGxpc3RJdGVtTGVuZ3RoOiAyLFxuICAgICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gW2V2ZW50XSwgKF8sIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgc3R5bGUsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIGxpc3RJdGVtTGVuZ3RoXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwidGV4dCBibG9jay5zZXRcIixcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbGV2ZWw6IDEsXG4gICAgICBzdHlsZSxcbiAgICAgIGF0OiBmb2N1c1RleHRCbG9jay5wYXRoXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUudGV4dFwiLFxuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogbGlzdEl0ZW1MZW5ndGggKyAxXG4gICAgICB9XG4gICAgfV1dXG4gIH0pO1xuICByZXR1cm4gW2F1dG9tYXRpY0Jsb2NrcXVvdGVPblNwYWNlLCBhdXRvbWF0aWNIZWFkaW5nT25TcGFjZSwgYXV0b21hdGljSHIsIGF1dG9tYXRpY0hyT25QYXN0ZSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlLCBhdXRvbWF0aWNMaXN0T25TcGFjZV07XG59XG5leHBvcnQge1xuICBjb3JlQmVoYXZpb3IsXG4gIGNvcmVCZWhhdmlvcnMsXG4gIGNyZWF0ZUNvZGVFZGl0b3JCZWhhdmlvcnMsXG4gIGNyZWF0ZUVtb2ppUGlja2VyQmVoYXZpb3JzLFxuICBjcmVhdGVMaW5rQmVoYXZpb3JzLFxuICBjcmVhdGVNYXJrZG93bkJlaGF2aW9ycyxcbiAgZGVmaW5lQmVoYXZpb3IsXG4gIHJhaXNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/behaviors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   editorMachine: () => (/* binding */ editorMachine),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorSelector: () => (/* binding */ useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/./node_modules/lodash.startcase/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var _chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./_chunks-es/selector.is-selection-collapsed.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\");\n/* harmony import */ var _chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./_chunks-es/util.is-empty-text-block.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/util.is-empty-text-block.js\");\n/* harmony import */ var _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./_chunks-es/behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var _portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @portabletext/block-tools */ \"(ssr)/./node_modules/@portabletext/block-tools/lib/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createEditorSchema(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction defineSchema(definition) {\n  return definition;\n}\nfunction compileSchemaDefinition(definition) {\n  const blockObjects = definition?.blockObjects?.map((blockObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n    type: \"object\",\n    // Very naive way to work around `SanitySchema.compile` adding default\n    // fields to objects with the name `image`\n    name: blockObject.name === \"image\" ? \"tmp-image\" : blockObject.name,\n    title: blockObject.name === \"image\" && blockObject.title === void 0 ? \"Image\" : blockObject.title,\n    fields: []\n  })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n    type: \"object\",\n    name: inlineObject.name,\n    title: inlineObject.title,\n    fields: []\n  })) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineField)({\n    type: \"array\",\n    name: \"portable-text\",\n    of: [...blockObjects.map((blockObject) => ({\n      type: blockObject.name\n    })), {\n      type: \"block\",\n      name: \"block\",\n      of: inlineObjects.map((inlineObject) => ({\n        type: inlineObject.name\n      })),\n      marks: {\n        decorators: definition?.decorators?.map((decorator) => ({\n          title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(decorator.name),\n          value: decorator.name\n        })) ?? [],\n        annotations: definition?.annotations?.map((annotation) => ({\n          name: annotation.name,\n          type: \"object\",\n          title: annotation.title\n        })) ?? []\n      },\n      lists: definition?.lists?.map((list) => ({\n        value: list.name,\n        title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(list.name)\n      })) ?? [],\n      styles: definition?.styles?.map((style) => ({\n        value: style.name,\n        title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(style.name)\n      })) ?? []\n    }]\n  }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects]\n  }).get(\"portable-text\"), pteSchema = createEditorSchema(schema);\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) => blockObject.name === \"tmp-image\" ? {\n      ...blockObject,\n      name: \"image\",\n      type: {\n        ...blockObject.type,\n        name: \"image\"\n      }\n    } : blockObject)\n  };\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_5__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_5__ && debug__WEBPACK_IMPORTED_MODULE_5__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_5__(namespace) : debug__WEBPACK_IMPORTED_MODULE_5__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n  const blockPath = [point.path[0]];\n  if (!value)\n    return null;\n  const block = value[blockPath[0]];\n  if (!block)\n    return null;\n  const keyedBlockPath = [{\n    _key: block._key\n  }];\n  if (block._type !== types.block.name)\n    return keyedBlockPath;\n  let keyedChildPath;\n  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n  return child && (keyedChildPath = [\"children\", {\n    _key: child._key\n  }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;\n}\nfunction toSlatePath(path, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: [],\n    match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isKeySegment)(path[0]) && n._key === path[0]._key\n  }))[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__([{\n    _key: child._key\n  }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return [blockPath[0], 0];\n}\nfunction toPortableTextRange(value, range, types) {\n  if (!range)\n    return null;\n  let anchor = null, focus = null;\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n  anchorPath && range.anchor && (anchor = {\n    path: anchorPath,\n    offset: range.anchor.offset\n  });\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n  focusPath && range.focus && (focus = {\n    path: focusPath,\n    offset: range.focus.offset\n  });\n  const backward = !!(slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(range));\n  return anchor && focus ? {\n    anchor,\n    focus,\n    backward\n  } : null;\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: toSlatePath(selection.anchor.path, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: toSlatePath(selection.focus.path, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : focus ? {\n    anchor,\n    focus\n  } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block, voidChildren = [{\n      _key: VOID_CHILD_KEY,\n      _type: \"span\",\n      text: \"\",\n      marks: []\n    }];\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: voidChildren,\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: voidChildren,\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = {\n    userSelect: \"none\"\n  }, $[0] = t0) : t0 = $[0];\n  let t1;\n  return $[1] !== props.value._key || $[2] !== props.value._type ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { style: t0, children: [\n    \"[\",\n    props.value._type,\n    \": \",\n    props.value._key,\n    \"]\"\n  ] }), $[1] = props.value._key, $[2] = props.value._type, $[3] = t1) : t1 = $[3], t1;\n};\nDefaultObject.displayName = \"DefaultObject\";\nconst debug$j = debugWithName(\"components:DraggableBlock\"), DraggableBlock = (t0) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(51), {\n    children,\n    element,\n    readOnly,\n    blockRef\n  } = t0, editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(void 0), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n  let t1, t2;\n  $[0] !== editor || $[1] !== element ? (t2 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, element), $[0] = editor, $[1] = element, $[2] = t2) : t2 = $[2], t1 = t2;\n  const isVoid = t1;\n  let t3, t4;\n  $[3] !== editor || $[4] !== element ? (t4 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isInline(editor, element), $[3] = editor, $[4] = element, $[5] = t4) : t4 = $[5], t3 = t4;\n  const isInline = t3, [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n  let t5, t6;\n  $[6] !== blockRef || $[7] !== editor || $[8] !== element ? (t5 = () => setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, element)), t6 = [editor, element, blockRef], $[6] = blockRef, $[7] = editor, $[8] = element, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t5, t6);\n  let t7;\n  $[11] !== blockElement || $[12] !== editor || $[13] !== element ? (t7 = (event) => {\n    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n    if (!isMyDragOver || !blockElement)\n      return;\n    event.preventDefault(), event.dataTransfer.dropEffect = \"move\", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n    const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n    if (element === editor.children[0] || (loc < height / 2 ? IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"top\") : IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"bottom\")), isMyDragOver === element) {\n      event.dataTransfer.dropEffect = \"none\";\n      return;\n    }\n    setIsDragOver(!0);\n  }, $[11] = blockElement, $[12] = editor, $[13] = element, $[14] = t7) : t7 = $[14];\n  const handleDragOver = t7;\n  let t8;\n  $[15] === Symbol.for(\"react.memo_cache_sentinel\") ? (t8 = () => {\n    setIsDragOver(!1);\n  }, $[15] = t8) : t8 = $[15];\n  const handleDragLeave = t8;\n  let t9;\n  $[16] !== editor || $[17] !== element ? (t9 = (event_0) => {\n    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);\n    if (targetBlock) {\n      IS_DRAGGING.set(editor, !1), event_0.preventDefault(), event_0.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$j(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n      const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n      let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, targetBlock);\n      const myPath = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(myPath, targetPath);\n      if (dragPosition === \"bottom\" && !isBefore) {\n        if (targetPath[0] >= editor.children.length - 1) {\n          debug$j(\"target is already at the bottom, not moving\");\n          return;\n        }\n        const originalPath = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(targetPath), debug$j(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (dragPosition === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n        const originalPath_0 = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(targetPath), debug$j(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(targetPath, myPath)) {\n        event_0.preventDefault(), debug$j(\"targetPath and myPath is the same, not moving\");\n        return;\n      }\n      debug$j(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(editor, {\n        at: myPath,\n        to: targetPath\n      }), editor.onChange();\n      return;\n    }\n    debug$j(\"No target element, not doing anything\");\n  }, $[16] = editor, $[17] = element, $[18] = t9) : t9 = $[18];\n  const handleDragEnd = t9;\n  let t10;\n  $[19] !== editor || $[20] !== element ? (t10 = (event_1) => {\n    IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$j(\"On drop (prevented)\", element), event_1.preventDefault(), event_1.stopPropagation(), setIsDragOver(!1));\n  }, $[19] = editor, $[20] = element, $[21] = t10) : t10 = $[21];\n  const handleDrop = t10;\n  let t11;\n  $[22] !== editor || $[23] !== element || $[24] !== isVoid ? (t11 = (event_2) => {\n    if (!isVoid) {\n      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n      return;\n    }\n    IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event_2.stopPropagation();\n    const target = event_2.target;\n    target instanceof HTMLElement && (target.style.opacity = \"1\");\n  }, $[22] = editor, $[23] = element, $[24] = isVoid, $[25] = t11) : t11 = $[25];\n  const handleDrag = t11;\n  let t12;\n  $[26] !== blockElement || $[27] !== editor || $[28] !== handleDrag || $[29] !== isInline || $[30] !== isVoid ? (t12 = (event_3) => {\n    if (!isVoid || isInline) {\n      debug$j(\"Not dragging block\"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);\n      return;\n    }\n    if (debug$j(\"Drag start\"), IS_DRAGGING.set(editor, !0), event_3.dataTransfer && (event_3.dataTransfer.setData(\"application/portable-text\", \"something\"), event_3.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n      let dragGhost = blockElement.cloneNode(!0);\n      const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n        dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n        const rect = blockElement.getBoundingClientRect(), x = event_3.clientX - rect.left, y = event_3.clientY - rect.top;\n        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_3.dataTransfer.setDragImage(dragGhost, x, y);\n      }\n    }\n    handleDrag(event_3);\n  }, $[26] = blockElement, $[27] = editor, $[28] = handleDrag, $[29] = isInline, $[30] = isVoid, $[31] = t12) : t12 = $[31];\n  const handleDragStart = t12;\n  let t13;\n  $[32] !== editor || $[33] !== isDragOver ? (t13 = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[32] = editor, $[33] = isDragOver, $[34] = t13) : t13 = $[34];\n  const isDraggingOverFirstBlock = t13;\n  let t14;\n  $[35] !== editor || $[36] !== isDragOver ? (t14 = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[35] = editor, $[36] = isDragOver, $[37] = t14) : t14 = $[37];\n  const isDraggingOverLastBlock = t14, dragPosition_0 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"bottom\";\n  let t15, t16;\n  $[38] === Symbol.for(\"react.memo_cache_sentinel\") ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  } }), $[38] = t16) : t16 = $[38], t15 = t16;\n  const dropIndicator = t15;\n  if (readOnly) {\n    let t172;\n    return $[39] !== children ? (t172 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children }), $[39] = children, $[40] = t172) : t172 = $[40], t172;\n  }\n  const t17 = isDraggingOverTop && dropIndicator, t18 = isDraggingOverBottom && dropIndicator;\n  let t19;\n  return $[41] !== children || $[42] !== handleDrag || $[43] !== handleDragEnd || $[44] !== handleDragOver || $[45] !== handleDragStart || $[46] !== handleDrop || $[47] !== isVoid || $[48] !== t17 || $[49] !== t18 ? (t19 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop, children: [\n    t17,\n    children,\n    t18\n  ] }), $[41] = children, $[42] = handleDrag, $[43] = handleDragEnd, $[44] = handleDragOver, $[45] = handleDragStart, $[46] = handleDrop, $[47] = isVoid, $[48] = t17, $[49] = t18, $[50] = t19) : t19 = $[50], t19;\n};\nDraggableBlock.displayName = \"DraggableBlock\";\ndebugWithName(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = {\n  display: \"inline-block\"\n}, Element = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck\n}) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);\n  let renderedBlock = children, className;\n  const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => [{\n    _key: element._key\n  }], [element]);\n  if (typeof element._type != \"string\")\n    throw new Error(\"Expected element to have a _type property\");\n  if (typeof element._key != \"string\")\n    throw new Error(\"Expected element to have a _key property\");\n  if (editor.isInline(element)) {\n    const path = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, element), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n      depth: 1\n    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);\n    if (!schemaType)\n      throw new Error(\"Could not find type for inline block element\");\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block)) {\n      const elmPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: element._key\n      }];\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { ...attributes, children: [\n        children,\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { draggable: !readOnly, className: \"pt-inline-object\", \"data-testid\": \"pt-inline-object\", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [\n          renderChild && renderChild({\n            annotations: EMPTY_ANNOTATIONS,\n            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }),\n            editorElementRef: inlineBlockObjectRef,\n            focused,\n            path: elmPath,\n            schemaType,\n            selected,\n            type: schemaType,\n            value\n          }),\n          !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value })\n        ] }, element._key)\n      ] });\n    }\n    throw new Error(\"Block not found!\");\n  }\n  if (element._type === schemaTypes.block.name) {\n    className = \"pt-block pt-text-block\";\n    const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n    className = `pt-block pt-text-block pt-text-block-style-${style}`;\n    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);\n    renderStyle && blockStyleType && (renderedBlock = renderStyle({\n      block: element,\n      children,\n      focused,\n      selected,\n      value: style,\n      path: blockPath,\n      schemaType: blockStyleType,\n      editorElementRef: blockRef\n    }));\n    let level;\n    if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);\n      renderListItem && listType && (renderedBlock = renderListItem({\n        block: value,\n        children: renderedBlock,\n        focused,\n        selected,\n        value: element.listItem,\n        path: blockPath,\n        schemaType: listType,\n        level: value.level || 1,\n        editorElementRef: blockRef\n      }));\n    }\n    const renderProps = Object.defineProperty({\n      children: renderedBlock,\n      editorElementRef: blockRef,\n      focused,\n      level,\n      listItem: isListItem ? element.listItem : void 0,\n      path: blockPath,\n      selected,\n      style,\n      schemaType: schemaTypes.block,\n      value\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n      }\n    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ...attributes, className, spellCheck, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);\n  }\n  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);\n  if (!schemaType_0)\n    throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n  className = \"pt-block pt-object-block\";\n  const block_0 = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n  let renderedBlockFromProps;\n  if (renderBlock) {\n    const _props = Object.defineProperty({\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }),\n      editorElementRef: blockRef,\n      focused,\n      path: blockPath,\n      schemaType: schemaType_0,\n      selected,\n      value: block_0\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n      }\n    });\n    renderedBlockFromProps = renderBlock(_props);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { ...attributes, className, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps || /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }) }) })\n  ] }, element._key);\n};\nElement.displayName = \"Element\";\nconst PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n};\nfunction DefaultAnnotation(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n  let t0;\n  $[0] !== props.annotation ? (t0 = () => alert(JSON.stringify(props.annotation)), $[0] = props.annotation, $[1] = t0) : t0 = $[1];\n  const handleClick = t0;\n  let t1;\n  $[2] === Symbol.for(\"react.memo_cache_sentinel\") ? (t1 = {\n    color: \"blue\"\n  }, $[2] = t1) : t1 = $[2];\n  let t2;\n  return $[3] !== handleClick || $[4] !== props.children ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: t1, onClick: handleClick, children: props.children }), $[3] = handleClick, $[4] = props.children, $[5] = t2) : t2 = $[5], t2;\n}\nDefaultAnnotation.displayName = \"DefaultAnnotation\";\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst FLUSH_PATCHES_THROTTLED_MS =  false ? 0 : 1e3, mutationMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_17__.setup)({\n  types: {\n    context: {},\n    events: {},\n    input: {},\n    emitted: {}\n  },\n  actions: {\n    \"emit has pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n      type: \"has pending patches\"\n    }),\n    \"emit mutation\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n      context\n    }) => ({\n      type: \"mutation\",\n      patches: context.pendingPatches,\n      snapshot: fromSlateValue(context.slateEditor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(context.slateEditor))\n    })),\n    \"clear pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingPatches: []\n    }),\n    \"defer patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingPatches: ({\n        context,\n        event\n      }) => [...context.pendingPatches, event.patch]\n    })\n  },\n  guards: {\n    \"slate is normalizing\": ({\n      context\n    }) => slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isNormalizing(context.slateEditor)\n  }\n}).createMachine({\n  id: \"mutation\",\n  context: ({\n    input\n  }) => ({\n    pendingPatches: [],\n    schema: input.schema,\n    slateEditor: input.slateEditor\n  }),\n  initial: \"idle\",\n  states: {\n    idle: {\n      on: {\n        patch: {\n          actions: [\"defer patch\", \"emit has pending patches\"],\n          target: \"has pending patches\"\n        }\n      }\n    },\n    \"has pending patches\": {\n      after: {\n        [FLUSH_PATCHES_THROTTLED_MS]: [{\n          guard: \"slate is normalizing\",\n          target: \"idle\",\n          actions: [\"emit mutation\", \"clear pending patches\"]\n        }, {\n          reenter: !0\n        }]\n      },\n      on: {\n        patch: {\n          actions: [\"defer patch\"],\n          reenter: !0\n        }\n      }\n    }\n  }\n});\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)({\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.value).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0) return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2) return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1) return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;\n      else if (y1 > text2Length) k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;\n      else if (y2 > text2Length) k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0) return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2) return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch) throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1) return [[DIFF_INSERT, text2]];\n  if (!text2) return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null) throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText2, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText2, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two) return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {\n    case DIFF_INSERT:\n      countInsert++, textInsert += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_DELETE:\n      countDelete++, textDelete += diffs[pointer][1], pointer++;\n      break;\n    case DIFF_EQUAL:\n      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n      break;\n    default:\n      throw new Error(\"Unknown diff operation\");\n  }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value\n}) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1) throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);\n        else break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold) break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null) throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern) return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern) return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++) lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\") throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\") return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches) adjusted.push({\n    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n    start1: advanceTo(patch.start1),\n    start2: advanceTo(patch.start2),\n    utf8Start1: patch.utf8Start1,\n    utf8Start2: patch.utf8Start2,\n    length1: patch.length1,\n    length2: patch.length2,\n    utf8Length1: patch.utf8Length1,\n    utf8Length2: patch.utf8Length2\n  });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);\n  for (const p of patches) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize) continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\") throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0) return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline) return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\") break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nconst debug$i = debugWithName(\"plugin:withUndoRedo\"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor,\n    blockSchemaType\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);\n    const remotePatches = getRemotePatches(editor);\n    options.subscriptions.push(() => {\n      debug$i(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$i(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$i(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);\n      let merge = !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$i(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      apply2(op);\n    }, editor.undo = () => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }))\n        return;\n      const {\n        undos\n      } = editor.history;\n      if (undos.length > 0) {\n        const step = undos[undos.length - 1];\n        if (debug$i(\"Undoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_15__.Operation.inverse).reverse();\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n              withUndoing(editor, () => {\n                withoutSaving(editor, () => {\n                  reversedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$i(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.redos.push(step), editor.history.undos.pop();\n        }\n      }\n    }, editor.redo = () => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      }))\n        return;\n      const {\n        redos\n      } = editor.history;\n      if (redos.length > 0) {\n        const step = redos[redos.length - 1];\n        if (debug$i(\"Redoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n              withRedoing(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$i(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.undos.push(step), editor.history.redos.pop();\n        }\n      }\n    }, editor;\n  };\n}\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$i(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$i(\"Skipping transformation that targeted removed block\"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$i(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst syncValueCallback = ({\n  sendBack,\n  input\n}) => {\n  updateValue({\n    context: input.context,\n    sendBack,\n    slateEditor: input.slateEditor,\n    value: input.value,\n    streamBlocks: input.streamBlocks\n  });\n}, syncValueLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_20__.fromCallback)(syncValueCallback), syncMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_17__.setup)({\n  types: {\n    context: {},\n    input: {},\n    events: {},\n    emitted: {}\n  },\n  actions: {\n    \"assign initial value synced\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      initialValueSynced: !0\n    }),\n    \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      readOnly: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"update readOnly\"), event.readOnly)\n    }),\n    \"assign pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"update value\"), event.value)\n    }),\n    \"clear pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingValue: void 0\n    }),\n    \"assign previous value\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      previousValue: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"done syncing\"), event.value)\n    }),\n    \"emit done syncing initial value\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n      type: \"done syncing initial value\"\n    })\n  },\n  guards: {\n    \"initial value synced\": ({\n      context\n    }) => context.initialValueSynced,\n    \"is busy\": ({\n      context\n    }) => !context.readOnly && (context.isProcessingLocalChanges || (isChangingRemotely(context.slateEditor) ?? !1)),\n    \"value changed while syncing\": ({\n      context,\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"done syncing\"), context.pendingValue !== event.value),\n    \"pending value equals previous value\": ({\n      context\n    }) => !(context.previousValue === void 0 && context.pendingValue === void 0) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(context.pendingValue, context.previousValue)\n  },\n  actors: {\n    \"sync value\": syncValueLogic\n  }\n}).createMachine({\n  id: \"sync\",\n  context: ({\n    input\n  }) => ({\n    initialValueSynced: !1,\n    isProcessingLocalChanges: !1,\n    keyGenerator: input.keyGenerator,\n    schema: input.schema,\n    readOnly: input.readOnly,\n    slateEditor: input.slateEditor,\n    pendingValue: void 0,\n    previousValue: void 0\n  }),\n  on: {\n    \"has pending patches\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n        isProcessingLocalChanges: !0\n      })\n    },\n    mutation: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n        isProcessingLocalChanges: !1\n      })\n    },\n    \"update readOnly\": {\n      actions: [\"assign readOnly\"]\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"setting up\": {\n      initial: \"syncing initial value\",\n      states: {\n        \"syncing initial value\": {\n          always: {\n            guard: \"initial value synced\",\n            target: \"done syncing initial value\"\n          }\n        },\n        \"done syncing initial value\": {\n          entry: [\"emit done syncing initial value\"],\n          type: \"final\"\n        }\n      }\n    },\n    syncing: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          on: {\n            \"update value\": [{\n              guard: \"is busy\",\n              target: \"busy\",\n              actions: [\"assign pending value\"]\n            }, {\n              target: \"syncing\",\n              actions: [\"assign pending value\"]\n            }]\n          }\n        },\n        busy: {\n          after: {\n            1e3: [{\n              guard: \"is busy\",\n              reenter: !0\n            }, {\n              target: \"syncing\"\n            }]\n          },\n          on: {\n            \"update value\": [{\n              actions: [\"assign pending value\"]\n            }]\n          }\n        },\n        syncing: {\n          always: {\n            guard: \"pending value equals previous value\",\n            target: \"idle\",\n            actions: [\"clear pending value\", \"assign initial value synced\"]\n          },\n          invoke: {\n            src: \"sync value\",\n            id: \"sync value\",\n            input: ({\n              context\n            }) => ({\n              context: {\n                keyGenerator: context.keyGenerator,\n                previousValue: context.previousValue,\n                readOnly: context.readOnly,\n                schema: context.schema\n              },\n              slateEditor: context.slateEditor,\n              streamBlocks: !context.initialValueSynced,\n              value: context.pendingValue\n            })\n          },\n          on: {\n            \"update value\": {\n              actions: [\"assign pending value\"]\n            },\n            patch: {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)]\n            },\n            \"invalid value\": {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)]\n            },\n            \"value changed\": {\n              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)]\n            },\n            \"done syncing\": [{\n              guard: \"value changed while syncing\",\n              actions: [\"assign previous value\", \"assign initial value synced\"],\n              reenter: !0\n            }, {\n              target: \"idle\",\n              actions: [\"clear pending value\", \"assign previous value\", \"assign initial value synced\"]\n            }]\n          }\n        }\n      }\n    }\n  }\n}), debug$h = debugWithName(\"hook:useSyncValue\");\nasync function updateValue({\n  context,\n  sendBack,\n  slateEditor,\n  streamBlocks,\n  value\n}) {\n  let isChanged = !1, isValid = !0;\n  const hadSelection = !!slateEditor.selection;\n  if ((!value || value.length === 0) && (debug$h(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n    withoutSaving(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor);\n        const childrenLength = slateEditor.children.length;\n        slateEditor.children.forEach((_, index) => {\n          slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n            at: [childrenLength - 1 - index]\n          });\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n          decorators: []\n        }), {\n          at: [0]\n        }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [0, 0]);\n      });\n    });\n  }), isChanged = !0), value && value.length > 0) {\n    const slateValueFromProps = toSlateValue(value, {\n      schemaTypes: context.schema\n    });\n    await new Promise((resolve) => {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n        withRemoteChanges(slateEditor, () => {\n          withoutPatching(slateEditor, async () => {\n            const childrenLength = slateEditor.children.length;\n            if (slateValueFromProps.length < childrenLength) {\n              for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                  at: [i]\n                });\n              isChanged = !0;\n            }\n            for await (const [currentBlock, currentBlockIndex] of getBlocks({\n              slateValue: slateValueFromProps,\n              streamBlocks\n            })) {\n              const {\n                blockChanged,\n                blockValid\n              } = syncBlock({\n                context,\n                sendBack,\n                block: currentBlock,\n                index: currentBlockIndex,\n                slateEditor,\n                value\n              });\n              isChanged = blockChanged || isChanged, isValid = isValid && blockValid;\n            }\n            resolve();\n          });\n        });\n      });\n    });\n  }\n  if (!isValid) {\n    debug$h(\"Invalid value, returning\"), sendBack({\n      type: \"done syncing\",\n      value\n    });\n    return;\n  }\n  if (isChanged) {\n    debug$h(\"Server value changed, syncing editor\");\n    try {\n      slateEditor.onChange();\n    } catch (err) {\n      console.error(err), sendBack({\n        type: \"invalid value\",\n        resolution: null,\n        value\n      }), sendBack({\n        type: \"done syncing\",\n        value\n      });\n      return;\n    }\n    hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), slateEditor.onChange()), sendBack({\n      type: \"value changed\",\n      value\n    });\n  } else\n    debug$h(\"Server value and editor value is equal, no need to sync.\");\n  sendBack({\n    type: \"done syncing\",\n    value\n  });\n}\nasync function* getBlocks({\n  slateValue,\n  streamBlocks\n}) {\n  let index = 0;\n  for await (const block of slateValue)\n    streamBlocks && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;\n}\nfunction syncBlock({\n  context,\n  sendBack,\n  block,\n  index,\n  slateEditor,\n  value\n}) {\n  let blockChanged = !1, blockValid = !0;\n  const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlock, oldBlock);\n  return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, () => {\n    withRemoteChanges(slateEditor, () => {\n      withoutPatching(slateEditor, () => {\n        if (hasChanges && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n            sendBack({\n              type: \"patch\",\n              patch\n            });\n          })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$h.enabled && debug$h(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$h.enabled && debug$h(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n        if (!oldBlock && blockValid) {\n          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n          debug$h.enabled && debug$h(\"Validating and inserting new block in the end of the value\", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n            at: [currentBlockIndex]\n          }) : (debug$h(\"Invalid\", validation), sendBack({\n            type: \"invalid value\",\n            resolution: validation.resolution,\n            value\n          }), blockValid = !1);\n        }\n      });\n    });\n  }), {\n    blockChanged,\n    blockValid\n  };\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {\n      const childIndex = oldBlockChildrenLength - 1 - index;\n      childIndex > 0 && (debug$h(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$h(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$h(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$h(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$h(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$g = debugWithName(\"component:PortableTextEditor:Synchronizer\");\nfunction Synchronizer(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(40), {\n    editorActor,\n    slateEditor\n  } = props, value = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(props.editorActor, _temp), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(props.editorActor, _temp2);\n  let t0;\n  $[0] !== props.editorActor ? (t0 = props.editorActor.getSnapshot(), $[0] = props.editorActor, $[1] = t0) : t0 = $[1];\n  const t1 = t0.context.keyGenerator;\n  let t2;\n  $[2] !== props.editorActor ? (t2 = props.editorActor.getSnapshot().matches({\n    \"edit mode\": \"read only\"\n  }), $[2] = props.editorActor, $[3] = t2) : t2 = $[3];\n  let t3;\n  $[4] !== props.editorActor ? (t3 = props.editorActor.getSnapshot(), $[4] = props.editorActor, $[5] = t3) : t3 = $[5];\n  let t4;\n  $[6] !== slateEditor || $[7] !== t0.context.keyGenerator || $[8] !== t2 || $[9] !== t3.context.schema ? (t4 = {\n    input: {\n      keyGenerator: t1,\n      readOnly: t2,\n      schema: t3.context.schema,\n      slateEditor\n    }\n  }, $[6] = slateEditor, $[7] = t0.context.keyGenerator, $[8] = t2, $[9] = t3.context.schema, $[10] = t4) : t4 = $[10];\n  const syncActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useActorRef)(syncMachine, t4);\n  let t5;\n  $[11] !== editorActor ? (t5 = editorActor.getSnapshot(), $[11] = editorActor, $[12] = t5) : t5 = $[12];\n  let t6;\n  $[13] !== slateEditor || $[14] !== t5.context.schema ? (t6 = {\n    input: {\n      schema: t5.context.schema,\n      slateEditor\n    }\n  }, $[13] = slateEditor, $[14] = t5.context.schema, $[15] = t6) : t6 = $[15];\n  const mutationActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useActorRef)(mutationMachine, t6);\n  let t7, t8;\n  $[16] !== editorActor || $[17] !== mutationActorRef || $[18] !== syncActorRef ? (t7 = () => {\n    const subscription = mutationActorRef.on(\"*\", (event) => {\n      event.type === \"has pending patches\" && syncActorRef.send({\n        type: \"has pending patches\"\n      }), event.type === \"mutation\" && (syncActorRef.send({\n        type: \"mutation\"\n      }), editorActor.send({\n        type: \"mutation\",\n        patches: event.patches,\n        snapshot: event.snapshot,\n        value: event.snapshot\n      }));\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t8 = [mutationActorRef, syncActorRef, editorActor], $[16] = editorActor, $[17] = mutationActorRef, $[18] = syncActorRef, $[19] = t7, $[20] = t8) : (t7 = $[19], t8 = $[20]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t7, t8);\n  let t10, t9;\n  $[21] !== props.editorActor || $[22] !== syncActorRef ? (t9 = () => {\n    const subscription_0 = syncActorRef.on(\"*\", (event_0) => {\n      props.editorActor.send(event_0);\n    });\n    return () => {\n      subscription_0.unsubscribe();\n    };\n  }, t10 = [props.editorActor, syncActorRef], $[21] = props.editorActor, $[22] = syncActorRef, $[23] = t10, $[24] = t9) : (t10 = $[23], t9 = $[24]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t9, t10);\n  let t11, t12;\n  $[25] !== readOnly || $[26] !== syncActorRef ? (t11 = () => {\n    syncActorRef.send({\n      type: \"update readOnly\",\n      readOnly\n    });\n  }, t12 = [syncActorRef, readOnly], $[25] = readOnly, $[26] = syncActorRef, $[27] = t11, $[28] = t12) : (t11 = $[27], t12 = $[28]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t11, t12);\n  let t13, t14;\n  $[29] !== syncActorRef || $[30] !== value ? (t13 = () => {\n    debug$g(\"Value from props changed, syncing new value\"), syncActorRef.send({\n      type: \"update value\",\n      value\n    });\n  }, t14 = [syncActorRef, value], $[29] = syncActorRef, $[30] = value, $[31] = t13, $[32] = t14) : (t13 = $[31], t14 = $[32]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t13, t14);\n  let t15;\n  $[33] !== editorActor || $[34] !== mutationActorRef ? (t15 = () => {\n    debug$g(\"Subscribing to patch events\");\n    const sub = editorActor.on(\"patch\", (event_1) => {\n      mutationActorRef.send(event_1);\n    });\n    return () => {\n      debug$g(\"Unsubscribing to patch events\"), sub.unsubscribe();\n    };\n  }, $[33] = editorActor, $[34] = mutationActorRef, $[35] = t15) : t15 = $[35];\n  let t16;\n  return $[36] !== editorActor || $[37] !== mutationActorRef || $[38] !== slateEditor ? (t16 = [editorActor, mutationActorRef, slateEditor], $[36] = editorActor, $[37] = mutationActorRef, $[38] = slateEditor, $[39] = t16) : t16 = $[39], (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t15, t16), null;\n}\nfunction _temp2(s_0) {\n  return s_0.matches({\n    \"edit mode\": \"read only\"\n  });\n}\nfunction _temp(s) {\n  return s.context.value;\n}\nSynchronizer.displayName = \"Synchronizer\";\nconst debug$f = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(types) {\n  const textBlockName = types.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$f.enabled && debug$f(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_12__({\n        ...editor.children[operation.path[0]],\n        ...operation.newProperties\n      }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_11__);\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(fromSlateValue([setNode], textBlockName)[0], [{\n        _key: block._key\n      }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_10__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(val, [{\n                _key: blockKey\n              }, \"children\", block.children.indexOf(child), keyName]));\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_10__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(val, [{\n                _key: blockKey\n              }, \"children\", {\n                _key: childKey\n              }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n      return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [{\n        _key: targetKey\n      }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [operation.path[0]])];\n    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n        ...operation.node\n      };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue([{\n        _key: \"bogus\",\n        _type: textBlockName,\n        children: [node]\n      }], textBlockName)[0].children[0];\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([child], position, [{\n        _key: block._key\n      }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n        _key: block.children[operation.path[1] - 1]._key\n      }])];\n    }\n    return debug$f(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([targetValue], \"after\", [{\n          _key: splitBlock._key\n        }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{\n            _key: oldBlock._key\n          }, \"children\", {\n            _key: span._key\n          }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue([{\n          ...splitBlock,\n          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n        }], textBlockName)[0].children;\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)(targetSpans, \"after\", [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(splitSpan.text, [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }, \"text\"]));\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: block._key\n        }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]];\n      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: spanToRemove._key\n      }])] : (debug$f(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$f(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block?._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(newBlock, [{\n          _key: newBlock._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n          _key: block._key\n        }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.set)(updatedSpan.text, [{\n        _key: block._key\n      }, \"children\", {\n        _key: updatedSpan._key\n      }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: removedSpan._key\n      }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n    } else\n      debug$f(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (!targetBlock)\n      return patches;\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{\n        _key: targetBlock._key\n      }]));\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: child._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)([childToInsert], position, [{\n        _key: targetBlock._key\n      }, \"children\", {\n        _key: targetChild._key\n      }]));\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nconst IS_APPLYING_BEHAVIOR_ACTIONS = /* @__PURE__ */ new WeakMap();\nfunction withApplyingBehaviorActions(editor, fn) {\n  const prev = isApplyingBehaviorActions(editor);\n  IS_APPLYING_BEHAVIOR_ACTIONS.set(editor, !0), fn(), IS_APPLYING_BEHAVIOR_ACTIONS.set(editor, prev);\n}\nfunction isApplyingBehaviorActions(editor) {\n  return IS_APPLYING_BEHAVIOR_ACTIONS.get(editor) ?? !1;\n}\nfunction createWithEventListeners(editorActor, subscriptions) {\n  return function(editor) {\n    if (editorActor.getSnapshot().context.maxBlocks !== void 0)\n      return editor;\n    subscriptions.push(() => {\n      const subscription = editorActor.on(\"*\", (event) => {\n        switch (event.type) {\n          case \"annotation.add\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"annotation.add\",\n                annotation: event.annotation\n              },\n              editor\n            });\n            break;\n          }\n          case \"annotation.remove\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"annotation.remove\",\n                annotation: event.annotation\n              },\n              editor\n            });\n            break;\n          }\n          case \"blur\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"blur\"\n              },\n              editor\n            });\n            break;\n          }\n          case \"custom.*\": {\n            editorActor.send({\n              type: \"custom behavior event\",\n              behaviorEvent: event.event,\n              editor\n            });\n            break;\n          }\n          case \"decorator.toggle\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"decorator.toggle\",\n                decorator: event.decorator\n              },\n              editor\n            });\n            break;\n          }\n          case \"focus\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"focus\"\n              },\n              editor\n            });\n            break;\n          }\n          case \"insert.block object\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"insert.block object\",\n                placement: event.placement,\n                blockObject: event.blockObject\n              },\n              editor\n            });\n            break;\n          }\n          case \"insert.inline object\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"insert.inline object\",\n                inlineObject: event.inlineObject\n              },\n              editor\n            });\n            break;\n          }\n          case \"list item.toggle\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"list item.toggle\",\n                listItem: event.listItem\n              },\n              editor\n            });\n            break;\n          }\n          case \"select\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"select\",\n                selection: event.selection\n              },\n              editor\n            });\n            break;\n          }\n          case \"style.toggle\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"style.toggle\",\n                style: event.style\n              },\n              editor\n            });\n            break;\n          }\n        }\n      });\n      return () => {\n        subscription.unsubscribe();\n      };\n    });\n    const {\n      deleteBackward: deleteBackward2,\n      deleteForward: deleteForward2,\n      insertBreak,\n      insertSoftBreak,\n      insertText: insertText2,\n      select\n    } = editor;\n    return editor.deleteBackward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteBackward2(unit);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      if (isApplyingBehaviorActions(editor)) {\n        deleteForward2(unit);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete.forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertBreak();\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.break\"\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertSoftBreak();\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text, options) => {\n      if (isApplyingBehaviorActions(editor)) {\n        insertText2(text, options);\n        return;\n      }\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert.text\",\n          text,\n          options\n        },\n        editor,\n        defaultActionCallback: () => {\n          insertText2(text, options);\n        }\n      });\n    }, editor.select = (location) => {\n      if (isApplyingBehaviorActions(editor)) {\n        select(location);\n        return;\n      }\n      const range = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.range(editor, location);\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"select\",\n          selection: toPortableTextRange(fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), range, editorActor.getSnapshot().context.schema)\n        },\n        editor,\n        defaultActionCallback: () => {\n          select(location);\n        }\n      });\n    }, editor;\n  };\n}\nfunction createWithMaxBlocks(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(operation);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor, schemaTypes) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(operation.node)) {\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$e = debugWithName(\"applyPatches\"), debugVerbose = debug$e.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n  return (editor, patch) => {\n    let changed = !1;\n    debugVerbose && (debug$e(`\n\nNEW PATCH =============================================================`), debug$e(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schemaTypes);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$e(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const {\n    block,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$e(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$e(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$e(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$e(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    return debug$e(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), debugState(editor, \"after\"), !0;\n  }\n  const {\n    items,\n    position\n  } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$e(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue([{\n    ...targetBlock,\n    children: items\n  }], {\n    schemaTypes\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$e(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$e(\"Block not found\"), !1;\n  const isTextBlock = editor.isTextBlock(block);\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$e(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$e(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$e(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$e(\"Setting block property\");\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: prevChildren,\n      ...prevRest\n    } = block || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    }), debug$e(\"Setting children\"), block.children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c2\n      });\n    }), Array.isArray(children) && children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c2\n      });\n    });\n  } else if (block && \"value\" in block) {\n    const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.applyAll)([block.value], [patch])[0];\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n      ...block,\n      value: newVal\n    }, {\n      at: blockPath\n    }), !0;\n  }\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    debug$e(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.children.forEach((_child, i) => {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n        at: [i]\n      });\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$e(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$e(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: [blockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$e(\"Child not found\"), !1) : (debug$e(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose && debug$e(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n    at: childPath\n  }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose && (debug$e(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$e(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  return block ? {\n    block,\n    path: [blockIndex]\n  } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const {\n    block,\n    path: blockPath\n  } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && path[1] === \"children\"))\n    return {\n      block,\n      blockPath,\n      child: void 0,\n      childPath: void 0\n    };\n  let childIndex = -1;\n  const child = block.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  return child ? {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex)\n  } : {\n    block,\n    blockPath,\n    child: void 0,\n    childPath: void 0\n  };\n}\nconst debug$d = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  patchFunctions,\n  schemaTypes,\n  subscriptions\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(schemaTypes);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              patches.forEach((patch) => {\n                debug$d.enabled && debug$d(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n              });\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return subscriptions.push(() => {\n      debug$d(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$d(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];\n          break;\n      }\n      return !editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.unset)([])], editorActor.send({\n        type: \"unset\",\n        previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_19__.setIfMissing)([], []), ...patches]), patches.length > 0 && patches.forEach((patch) => {\n        editorActor.send({\n          type: \"patch\",\n          patch: {\n            ...patch,\n            origin: \"local\"\n          }\n        });\n      }), editor;\n    }, editor;\n  };\n}\nconst debug$c = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n      })) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$c(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n            decorators: []\n          })));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor, types) {\n  const defaultStyle = types.styles[0].value;\n  return function(editor) {\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && child.text === \"\") {\n            debug$b(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              style: defaultStyle\n            }, {\n              at: [op.path[0] + 1],\n              voids: !1\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      normalizeNode(nodeEntry);\n    }, editor;\n  };\n}\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nconst debug$a = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor, types) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = types.decorators.map((t) => t.value);\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {\n            debug$a(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$a(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$a(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath), decorators2 = types.decorators.map((decorator) => decorator.value), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$a(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = types.decorators.map((decorator) => decorator.value);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$a(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = types.decorators.map((decorator) => decorator.value), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$a(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$a(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(newMarkDefs, node.markDefs)) {\n          debug$a(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          if (movedToNextSpan || movedToPreviousSpan)\n            return;\n        }\n      }\n      if (op.type === \"insert_node\") {\n        const {\n          selection\n        } = editor;\n        if (selection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path\n          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1]\n          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;\n          if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []\n            });\n            return;\n          }\n          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;\n          if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []\n            });\n            return;\n          }\n          const nextSpanDecorators = nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? [];\n          if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: nextSpanDecorators\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"insert_text\") {\n        const {\n          selection\n        } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) : !1;\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: selection.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotation) {\n                apply2(op);\n                return;\n              } else if (!previousSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n            if (atTheEndOfSpan) {\n              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? []\n                });\n                return;\n              }\n              if (!nextSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n          }\n          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n              _type: \"span\",\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const marksWithoutAnnotationMarks = ({\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n              }.marks || []).filter((mark) => decorators.includes(mark));\n              slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                  marks: marksWithoutAnnotationMarks\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...oldDefs, ...op.properties.markDefs]);\n          debug$a(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst addDecoratorActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator;\n  if (editor.selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0,\n        hanging: !0\n      });\n      const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(editor.selection) ? [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n      })] : [];\n      splitTextNodes.length > 1 && splitTextNodes.every((node) => node[0].marks?.includes(mark)) ? editor.removeMark(mark) : splitTextNodes.forEach(([node, path]) => {\n        const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks\n        }, {\n          at: path,\n          match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n          split: !0,\n          hanging: !0\n        });\n      });\n    } else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n          marks: [...existingMarks, mark]\n        };\n        editor.marks = marks;\n      }\n    }\n    if (editor.selection) {\n      const selection = editor.selection;\n      editor.selection = {\n        ...selection\n      };\n    }\n  }\n}, removeDecoratorActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator, {\n    selection\n  } = editor;\n  if (selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection))\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0,\n        hanging: !0\n      }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n      })].forEach(([node, path]) => {\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n          _type: \"span\"\n        }, {\n          at: path\n        });\n      });\n    else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n          marks: existingMarks.filter((eMark) => eMark !== mark)\n        };\n        editor.marks = {\n          marks: marks.marks,\n          _type: \"span\"\n        };\n      }\n    }\n    if (editor.selection) {\n      const selection2 = editor.selection;\n      editor.selection = {\n        ...selection2\n      };\n    }\n  }\n};\nfunction isDecoratorActive({\n  editor,\n  decorator\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedTextNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n    at: editor.selection\n  }));\n  return selectedTextNodes.length === 0 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n) => {\n    const [node] = n;\n    return node.marks?.includes(decorator);\n  }) : ({\n    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n  }.marks || []).includes(decorator);\n}\nconst toggleDecoratorActionImplementation = ({\n  context,\n  action\n}) => {\n  isDecoratorActive({\n    editor: action.editor,\n    decorator: action.decorator\n  }) ? removeDecoratorActionImplementation({\n    context,\n    action: {\n      type: \"decorator.remove\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  }) : addDecoratorActionImplementation({\n    context,\n    action: {\n      type: \"decorator.add\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  });\n};\ndebugWithName(\"plugin:withPortableTextSelections\");\nfunction createWithPortableTextSelections(editorActor, types) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            ptRange = existing;\n          else {\n            const value = editor.children;\n            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n          }\n        }\n        ptRange ? editorActor.send({\n          type: \"selection\",\n          selection: ptRange\n        }) : editorActor.send({\n          type: \"selection\",\n          selection: null\n        });\n      }\n      prevSelection = editor.selection;\n    }, {\n      onChange\n    } = editor;\n    return editor.onChange = () => {\n      onChange(), editorActor.getSnapshot().matches({\n        setup: \"setting up\"\n      }) || emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$9 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(value) && value._type === schemaTypes.span.name, editor.isListBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$9(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          ...span,\n          _type: schemaTypes.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$9(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$8 = debugWithName(\"plugin:withUtils\");\nfunction createWithUtils({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    return editor.pteExpandToWord = () => {\n      const {\n        selection\n      } = editor;\n      if (selection && !slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n        const [textNode] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection.focus, {\n          depth: 2\n        });\n        if (!textNode || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(textNode) || textNode.text.length === 0) {\n          debug$8(\"pteExpandToWord: Can't expand to word here\");\n          return;\n        }\n        const {\n          focus\n        } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str) => str.match(/\\s/g), whiteSpaceBeforeIndex = charsBefore.split(\"\").reverse().findIndex((str) => isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split(\"\").findIndex((obj) => isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);\n        if (!(newStartOffset === newEndOffset || Number.isNaN(newStartOffset) || Number.isNaN(newEndOffset))) {\n          debug$8(\"pteExpandToWord: Expanding to focused word\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n            anchor: {\n              ...selection.anchor,\n              offset: newStartOffset\n            },\n            focus: {\n              ...selection.focus,\n              offset: newEndOffset\n            }\n          });\n          return;\n        }\n        debug$8(\"pteExpandToWord: Can't expand to word here\");\n      }\n    }, editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: schemaTypes.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: schemaTypes.styles[0].value || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => schemaTypes.decorators.find(({\n          value\n        }) => value === decorator))\n      }]\n    }], {\n      schemaTypes\n    })[0], editor;\n  };\n}\nconst withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor\n  } = options, schemaTypes = editorActor.getSnapshot().context.schema, operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(editorActor, schemaTypes), withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n    schemaTypes\n  }), withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    schemaTypes,\n    subscriptions: options.subscriptions\n  }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    blockSchemaType: schemaTypes.block,\n    subscriptions: options.subscriptions\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor, schemaTypes), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor, schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n    editorActor,\n    schemaTypes\n  }), withPortableTextSelections = createWithPortableTextSelections(editorActor, schemaTypes);\n  return createWithEventListeners(editorActor, options.subscriptions)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e)))))))))));\n}, debug$7 = debugWithName(\"component:PortableTextEditor:SlateContainer\"), slateEditors = /* @__PURE__ */ new WeakMap();\nfunction createSlateEditor(config) {\n  const existingSlateEditor = slateEditors.get(config.editorActor);\n  if (existingSlateEditor)\n    return debug$7(\"Reusing existing Slate editor instance\", config.editorActor.id), existingSlateEditor;\n  debug$7(\"Creating new Slate editor instance\", config.editorActor.id);\n  const unsubscriptions = [], subscriptions = [], instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_16__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_15__.createEditor)()), {\n    editorActor: config.editorActor,\n    subscriptions\n  });\n  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});\n  for (const subscription of subscriptions)\n    unsubscriptions.push(subscription());\n  const initialValue = [instance.pteCreateTextBlock({\n    decorators: []\n  })], slateEditor = {\n    instance,\n    initialValue\n  };\n  return slateEditors.set(config.editorActor, slateEditor), slateEditor;\n}\nconst toggleListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  isListItemActive({\n    editor: action.editor,\n    listItem: action.listItem\n  }) ? removeListItemActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"list item.remove\"\n    }\n  }) : addListItemActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"list item.add\"\n    }\n  });\n}, removeListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_22__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isListBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, [\"listItem\", \"level\"], {\n      at\n    });\n}, addListItemActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_22__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      level: 1,\n      listItem: action.listItem\n    }, {\n      at\n    });\n};\nfunction isListItemActive({\n  editor,\n  listItem\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;\n}\nconst toggleStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  isStyleActive({\n    editor: action.editor,\n    style: action.style\n  }) ? removeStyleActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"style.remove\"\n    }\n  }) : addStyleActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"style.add\"\n    }\n  });\n}, removeStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const defaultStyle = context.schema.styles[0].value, guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_22__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      style: defaultStyle\n    }, {\n      at\n    });\n}, addStyleActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection)\n    return;\n  const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_22__.createGuards)(context), selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection,\n    match: (node) => guards.isTextBlock(node)\n  })];\n  for (const [, at] of selectedBlocks)\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n      style: action.style\n    }, {\n      at\n    });\n};\nfunction isStyleActive({\n  editor,\n  style\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    at: editor.selection,\n    match: (node) => editor.isTextBlock(node)\n  })];\n  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;\n}\nconst debug$6 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n  const types = editorActor.getSnapshot().context.schema;\n  return {\n    focus: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"focus\"\n        },\n        editor\n      });\n    },\n    blur: () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"blur\"\n        },\n        editor\n      });\n    },\n    toggleMark: (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.toggle\",\n          decorator: mark\n        },\n        editor\n      });\n    },\n    toggleList: (listItem) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"list item.toggle\",\n          listItem\n        },\n        editor\n      });\n    },\n    toggleBlockStyle: (style) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"style.toggle\",\n          style\n        },\n        editor\n      });\n    },\n    isMarkActive: (mark) => {\n      try {\n        return isDecoratorActive({\n          editor,\n          decorator: mark\n        });\n      } catch (err) {\n        return console.warn(err), !1;\n      }\n    },\n    marks: () => ({\n      ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n    }).marks || [],\n    undo: () => editor.undo(),\n    redo: () => editor.redo(),\n    select: (selection) => {\n      const slateSelection = toSlateRange(selection, editor);\n      slateSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.onChange();\n    },\n    focusBlock: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block)\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n      }\n    },\n    focusChild: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block && editor.isTextBlock(block))\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n      }\n    },\n    insertChild: (type, value) => {\n      if (type.name !== types.span.name)\n        return editorActor.send({\n          type: \"behavior event\",\n          behaviorEvent: {\n            type: \"insert.inline object\",\n            inlineObject: {\n              name: type.name,\n              value\n            }\n          },\n          editor\n        }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? [];\n      if (!editor.selection)\n        throw new Error(\"The editor has no selection\");\n      const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => n._type === types.block.name\n      }))[0] || [void 0];\n      if (!focusBlock)\n        throw new Error(\"No focused text block\");\n      if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n        throw new Error(\"This type cannot be inserted as a child to a text block\");\n      const child = toSlateValue([{\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        _type: types.block.name,\n        children: [{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }]\n      }], {\n        schemaTypes: editorActor.getSnapshot().context.schema\n      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_15__.Node.get(editor, focusChildPath);\n      return isSpanNode && focusNode._type !== types.span.name && (debug$6(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n        distance: 1,\n        unit: \"character\"\n      })), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, child, {\n        select: !0,\n        at: editor.selection\n      }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n    },\n    insertBlock: (type, value) => (editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"insert.block object\",\n        blockObject: {\n          name: type.name,\n          value\n        },\n        placement: \"auto\"\n      },\n      editor\n    }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? []),\n    hasBlockStyle: (style) => {\n      try {\n        return isStyleActive({\n          editor,\n          style\n        });\n      } catch {\n        return !1;\n      }\n    },\n    hasListStyle: (listItem) => {\n      try {\n        return isListItemActive({\n          editor,\n          listItem\n        });\n      } catch {\n        return !1;\n      }\n    },\n    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n    findByPath: (path) => {\n      const slatePath = toSlateRange({\n        focus: {\n          path,\n          offset: 0\n        },\n        anchor: {\n          path,\n          offset: 0\n        }\n      }, editor);\n      if (slatePath) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n        if (block && blockPath && typeof block._key == \"string\") {\n          if (path.length === 1 && slatePath.focus.path.length === 1)\n            return [fromSlateValue([block], types.block.name)[0], [{\n              _key: block._key\n            }]];\n          const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]];\n            if (ptChild)\n              return [ptChild, [{\n                _key: block._key\n              }, \"children\", {\n                _key: ptChild._key\n              }]];\n          }\n        }\n      }\n      return [void 0, void 0];\n    },\n    findDOMNode: (element) => {\n      let node;\n      try {\n        const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: [],\n          match: (n) => n._key === element._key\n        }) || [])[0] || [void 0];\n        node = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, item);\n      } catch {\n      }\n      return node;\n    },\n    activeAnnotations: () => {\n      if (!editor.selection || editor.selection.focus.path.length < 2)\n        return [];\n      try {\n        const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n        });\n        for (const [span, path] of spans) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n            depth: 1\n          });\n          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n          });\n        }\n        return activeAnnotations;\n      } catch {\n        return [];\n      }\n    },\n    isAnnotationActive: (annotationType) => isAnnotationActive({\n      editor,\n      annotation: {\n        name: annotationType\n      }\n    }),\n    addAnnotation: (type, value) => {\n      let paths;\n      return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationActionImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types\n          },\n          action: {\n            type: \"annotation.add\",\n            annotation: {\n              name: type.name,\n              value: value ?? {}\n            },\n            editor\n          }\n        });\n      }), editor.onChange(), paths;\n    },\n    delete: (selection, options) => {\n      if (selection) {\n        const range = toSlateRange(selection, editor);\n        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n          throw new Error(\"Invalid range\");\n        if (range) {\n          if (!options?.mode || options?.mode === \"selected\") {\n            debug$6(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(editor, {\n              at: range,\n              hanging: !0,\n              voids: !0\n            }), editor.onChange();\n            return;\n          }\n          options?.mode === \"blocks\" && (debug$6(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n          })), options?.mode === \"children\" && (debug$6(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => node._type === types.span.name || // Text children\n            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n          })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({\n            decorators: []\n          })]), editor.onChange();\n        }\n      }\n    },\n    removeAnnotation: (type) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.remove\",\n          annotation: {\n            name: type.name\n          }\n        },\n        editor\n      });\n    },\n    getSelection: () => {\n      let ptRange = null;\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n        if (existing)\n          return existing;\n        ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n      }\n      return ptRange;\n    },\n    getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n    isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection),\n    isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection),\n    insertBreak: () => {\n      editor.insertBreak(), editor.onChange();\n    },\n    getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n    isSelectionsOverlapping: (selectionA, selectionB) => {\n      const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n      return slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(rangeA, rangeB);\n    }\n  };\n}\nfunction isAnnotationActive({\n  editor,\n  annotation\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2)\n    return !1;\n  try {\n    const spans = [...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node)\n    })];\n    if (spans.length === 0 || spans.some(([span]) => !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n        depth: 1\n      });\n      return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n    }, []);\n    return spans.every(([span]) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotation.name) : !1);\n  } catch {\n    return !1;\n  }\n}\nconst addAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  const editor = action.editor, {\n    selection: originalSelection\n  } = editor;\n  let paths;\n  if (originalSelection && (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(originalSelection) && (editor.pteExpandToWord(), editor.onChange()), editor.selection)) {\n    let spanPath, markDefPath;\n    const markDefPaths = [];\n    if (!editor.selection)\n      return;\n    const selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n      reverse: slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection)\n    });\n    for (const [block, blockPath] of selectedBlocks) {\n      if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n        continue;\n      const annotationKey = context.keyGenerator(), markDefs = block.markDefs ?? [];\n      markDefs.find((markDef) => markDef._type === action.annotation.name && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        markDefs: [...markDefs, {\n          _type: action.annotation.name,\n          _key: annotationKey,\n          ...action.annotation.value\n        }]\n      }, {\n        at: blockPath\n      }), markDefPath = [{\n        _key: block._key\n      }, \"markDefs\", {\n        _key: annotationKey\n      }], slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0\n      });\n      const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n      for (const [span, path] of children) {\n        if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, path))\n          continue;\n        const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === action.annotation.name));\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]\n        }, {\n          at: path\n        }), spanPath = [{\n          _key: block._key\n        }, \"children\", {\n          _key: span._key\n        }];\n      }\n    }\n    markDefPath && spanPath && (paths = {\n      markDefPath,\n      markDefPaths,\n      spanPath\n    });\n  }\n  return paths;\n}, removeAnnotationActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor;\n  if (debug$6(\"Removing annotation\", action.annotation.name), !!editor.selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n        depth: 1\n      });\n      if (!editor.isTextBlock(block))\n        return;\n      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === action.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n        depth: 2\n      });\n      if (!editor.isTextSpan(selectedChild))\n        return;\n      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n      if (!annotationToRemove)\n        return;\n      const previousSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n        reverse: !0\n      }))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            previousSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      const nextSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            nextSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n        }, {\n          at: childPath\n        });\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: (node) => editor.isTextSpan(node),\n        split: !0,\n        hanging: !0\n      });\n      const blocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      });\n      for (const [block, blockPath] of blocks) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n        for (const [child, childPath] of children) {\n          if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, childPath))\n            continue;\n          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== action.annotation.name);\n          marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: marksWithoutAnnotation\n          }, {\n            at: childPath\n          });\n        }\n      }\n    }\n}, toggleAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  if (isAnnotationActive({\n    editor: action.editor,\n    annotation: {\n      name: action.annotation.name\n    }\n  }))\n    removeAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.remove\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n  else\n    return addAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.add\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n};\nfunction insertBlock({\n  block,\n  placement,\n  editor,\n  schema\n}) {\n  if (editor.selection) {\n    const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      at: editor.selection.focus.path.slice(0, 1),\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n)\n    }))[0] ?? [void 0, void 0];\n    if (placement === \"after\") {\n      const nextPath = [focusBlockPath[0] + 1];\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n        at: nextPath\n      }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n        anchor: {\n          path: [nextPath[0], 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextPath[0], 0],\n          offset: 0\n        }\n      });\n    } else placement === \"before\" ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n      at: focusBlockPath\n    }) : slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block);\n    focusBlock && isEqualToEmptyEditor([focusBlock], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: focusBlockPath\n    });\n  } else {\n    const lastBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n),\n      at: [],\n      reverse: !0\n    }))[0];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), lastBlock && isEqualToEmptyEditor([lastBlock[0]], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: lastBlock[1]\n    });\n  }\n}\nconst insertBlockObjectActionImplementation = ({\n  context,\n  action\n}) => {\n  const block = toSlateValue([{\n    _key: context.keyGenerator(),\n    _type: action.blockObject.name,\n    ...action.blockObject.value ? action.blockObject.value : {}\n  }], {\n    schemaTypes: context.schema\n  })[0];\n  insertBlock({\n    block,\n    placement: action.placement,\n    editor: action.editor,\n    schema: context.schema\n  });\n}, insertBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  const keyGenerator = context.keyGenerator, schema = context.schema, editor = action.editor;\n  if (!editor.selection)\n    return;\n  const [focusSpan] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n    mode: \"lowest\",\n    at: editor.selection.focus,\n    match: (n) => editor.isTextSpan(n),\n    voids: !1\n  }))[0] ?? [void 0], focusDecorators = focusSpan?.marks?.filter((mark) => schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusAnnotations = focusSpan?.marks?.filter((mark) => !schema.decorators.some((decorator) => decorator.value === mark)) ?? [], anchorBlockPath = editor.selection.anchor.path.slice(0, 1), focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, focusBlockPath);\n  if (editor.isTextBlock(focusBlock)) {\n    const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(editor.selection), lastFocusBlockChild = focusBlock.children[focusBlock.children.length - 1], atTheEndOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(start, {\n      path: [...focusBlockPath, focusBlock.children.length - 1],\n      offset: editor.isTextSpan(lastFocusBlockChild) ? lastFocusBlockChild.text.length : 0\n    }), atTheStartOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(end, {\n      path: [...focusBlockPath, 0],\n      offset: 0\n    });\n    if (atTheEndOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      return;\n    }\n    if (atTheStartOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: focusAnnotations.length === 0 ? focusDecorators : [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath);\n      slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n        anchor: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        }\n      });\n      return;\n    }\n    const selectionAcrossBlocks = anchorBlockPath[0] !== focusBlockPath[0];\n    if (!atTheStartOfBlock && !atTheEndOfBlock && !selectionAcrossBlocks) {\n      slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, () => {\n        if (!editor.selection)\n          return;\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n          at: editor.selection\n        });\n        const [nextNode, nextNodePath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath), {\n          depth: 1\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n          anchor: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          },\n          focus: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          }\n        }), editor.isTextBlock(nextNode) && nextNode.markDefs && nextNode.markDefs.length > 0) {\n          const newMarkDefKeys = /* @__PURE__ */ new Map(), prevNodeSpans = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, focusBlockPath)).map((entry) => entry[0]).filter((node) => editor.isTextSpan(node)), children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, nextNodePath);\n          for (const [child, childPath] of children) {\n            if (!editor.isTextSpan(child))\n              continue;\n            const marks = child.marks ?? [];\n            for (const mark of marks)\n              schema.decorators.some((decorator) => decorator.value === mark) || prevNodeSpans.some((prevNodeSpan) => prevNodeSpan.marks?.includes(mark)) && !newMarkDefKeys.has(mark) && newMarkDefKeys.set(mark, keyGenerator());\n            const newMarks = marks.map((mark) => newMarkDefKeys.get(mark) ?? mark);\n            lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(marks, newMarks) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n              marks: newMarks\n            }, {\n              at: childPath\n            });\n          }\n          const newMarkDefs = nextNode.markDefs.map((markDef) => ({\n            ...markDef,\n            _key: newMarkDefKeys.get(markDef._key) ?? markDef._key\n          }));\n          lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(nextNode.markDefs, newMarkDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: nextNodePath,\n            match: (node) => editor.isTextBlock(node)\n          });\n        }\n      }), editor.onChange();\n      return;\n    }\n  }\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n    always: !0\n  });\n}, insertSoftBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  insertBreakActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"insert.break\"\n    }\n  });\n}, insertInlineObjectActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!context.schema.inlineObjects.some((inlineObject) => inlineObject.name === action.inlineObject.name)) {\n    console.error(\"Unable to insert unknown inline object\");\n    return;\n  }\n  if (!action.editor.selection) {\n    console.error(\"Unable to insert inline object without selection\");\n    return;\n  }\n  const [focusTextBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection.focus.path,\n    match: (node) => action.editor.isTextBlock(node)\n  })).at(0) ?? [void 0, void 0];\n  if (!focusTextBlock) {\n    console.error(\"Unable to perform action without focus text block\");\n    return;\n  }\n  const child = toSlateValue([{\n    _type: context.schema.block.name,\n    _key: context.keyGenerator(),\n    children: [{\n      _type: action.inlineObject.name,\n      _key: context.keyGenerator(),\n      ...action.inlineObject.value ?? {}\n    }]\n  }], {\n    schemaTypes: context.schema\n  }).at(0)?.children.at(0);\n  if (!child) {\n    console.error(\"Unable to insert inline object\");\n    return;\n  }\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, child);\n}, insertSpanActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection) {\n    console.error(\"Unable to perform action without selection\", action);\n    return;\n  }\n  const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n    at: action.editor.selection.focus.path,\n    match: (node) => action.editor.isTextBlock(node)\n  }))[0] ?? [void 0, void 0];\n  if (!focusBlock || !focusBlockPath) {\n    console.error(\"Unable to perform action without focus block\", action);\n    return;\n  }\n  const markDefs = focusBlock.markDefs ?? [], annotations = action.annotations ? action.annotations.map((annotation) => ({\n    _type: annotation.name,\n    _key: context.keyGenerator(),\n    ...annotation.value\n  })) : void 0;\n  annotations && annotations.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n    markDefs: [...markDefs, ...annotations]\n  }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, {\n    _type: \"span\",\n    _key: context.keyGenerator(),\n    text: action.text,\n    marks: [...annotations?.map((annotation) => annotation._key) ?? [], ...action.decorators ?? []]\n  });\n}, textBlockSetActionImplementation = ({\n  action\n}) => {\n  const at = toSlateRange({\n    anchor: {\n      path: action.at,\n      offset: 0\n    },\n    focus: {\n      path: action.at,\n      offset: 0\n    }\n  }, action.editor);\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n    ...action.style ? {\n      style: action.style\n    } : {},\n    ...action.listItem ? {\n      listItem: action.listItem\n    } : {},\n    ...action.level ? {\n      level: action.level\n    } : {}\n  }, {\n    at\n  });\n}, textBlockUnsetActionImplementation = ({\n  action\n}) => {\n  const at = toSlateRange({\n    anchor: {\n      path: action.at,\n      offset: 0\n    },\n    focus: {\n      path: action.at,\n      offset: 0\n    }\n  }, action.editor);\n  slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, action.props, {\n    at\n  });\n}, behaviorActionImplementations = {\n  \"annotation.add\": addAnnotationActionImplementation,\n  \"annotation.remove\": removeAnnotationActionImplementation,\n  \"annotation.toggle\": toggleAnnotationActionImplementation,\n  blur: ({\n    action\n  }) => {\n    slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.blur(action.editor);\n  },\n  \"decorator.add\": addDecoratorActionImplementation,\n  \"decorator.remove\": removeDecoratorActionImplementation,\n  \"decorator.toggle\": toggleDecoratorActionImplementation,\n  focus: ({\n    action\n  }) => {\n    slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.focus(action.editor);\n  },\n  \"delete.backward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteBackward)(action.editor, action.unit);\n  },\n  \"delete.forward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteForward)(action.editor, action.unit);\n  },\n  \"delete.block\": ({\n    action\n  }) => {\n    const range = toSlateRange({\n      anchor: {\n        path: action.blockPath,\n        offset: 0\n      },\n      focus: {\n        path: action.blockPath,\n        offset: 0\n      }\n    }, action.editor);\n    if (!range) {\n      console.error(\"Unable to find Slate range from selection points\");\n      return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(action.editor, {\n      at: range\n    });\n  },\n  \"delete.text\": ({\n    context,\n    action\n  }) => {\n    const value = fromSlateValue(action.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)), anchor = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_23__.blockOffsetToSpanSelectionPoint)({\n      value,\n      blockOffset: action.anchor\n    }), focus = (0,_chunks_es_util_is_empty_text_block_js__WEBPACK_IMPORTED_MODULE_23__.blockOffsetToSpanSelectionPoint)({\n      value,\n      blockOffset: action.focus\n    });\n    if (!anchor || !focus) {\n      console.error(\"Unable to find anchor or focus selection point\");\n      return;\n    }\n    const range = toSlateRange({\n      anchor,\n      focus\n    }, action.editor);\n    if (!range) {\n      console.error(\"Unable to find Slate range from selection points\");\n      return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(action.editor, {\n      at: range\n    });\n  },\n  \"insert.block object\": insertBlockObjectActionImplementation,\n  \"insert.break\": insertBreakActionImplementation,\n  \"insert.inline object\": insertInlineObjectActionImplementation,\n  \"insert.soft break\": insertSoftBreakActionImplementation,\n  \"insert.span\": insertSpanActionImplementation,\n  \"insert.text\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_15__.insertText)(action.editor, action.text);\n  },\n  \"insert.text block\": ({\n    context,\n    action\n  }) => {\n    const block = toSlateValue([{\n      _key: context.keyGenerator(),\n      _type: context.schema.block.name,\n      style: context.schema.styles[0].value ?? \"normal\",\n      markDefs: [],\n      children: action.textBlock?.children?.map((child) => ({\n        ...child,\n        _key: context.keyGenerator()\n      })) ?? [{\n        _type: context.schema.span.name,\n        _key: context.keyGenerator(),\n        text: \"\"\n      }]\n    }], {\n      schemaTypes: context.schema\n    })[0];\n    insertBlock({\n      block,\n      editor: action.editor,\n      schema: context.schema,\n      placement: action.placement\n    });\n  },\n  effect: ({\n    action\n  }) => {\n    action.effect();\n  },\n  \"list item.add\": addListItemActionImplementation,\n  \"list item.remove\": removeListItemActionImplementation,\n  \"list item.toggle\": toggleListItemActionImplementation,\n  \"move.block\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]], to = [toSlatePath(action.to, action.editor)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  \"move.block down\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]], to = [slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(at)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  \"move.block up\": ({\n    action\n  }) => {\n    const at = [toSlatePath(action.at, action.editor)[0]];\n    if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(at))\n      return;\n    const to = [slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(at)[0]];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n      at,\n      to,\n      mode: \"highest\"\n    });\n  },\n  noop: () => {\n  },\n  select: ({\n    action\n  }) => {\n    const newSelection = toSlateRange(action.selection, action.editor);\n    newSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(action.editor);\n  },\n  \"select.previous block\": ({\n    action\n  }) => {\n    if (!action.editor.selection) {\n      console.error(\"Unable to select previous block without a selection\");\n      return;\n    }\n    const blockPath = action.editor.selection.focus.path.slice(0, 1);\n    if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(blockPath)) {\n      console.error(\"There's no previous block to select\");\n      return;\n    }\n    const previousBlockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(blockPath);\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, previousBlockPath);\n  },\n  \"select.next block\": ({\n    action\n  }) => {\n    if (!action.editor.selection) {\n      console.error(\"Unable to select next block without a selection\");\n      return;\n    }\n    const nextBlockPath = [action.editor.selection.focus.path.slice(0, 1)[0] + 1];\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, nextBlockPath);\n  },\n  \"style.toggle\": toggleStyleActionImplementation,\n  \"style.add\": addStyleActionImplementation,\n  \"style.remove\": removeStyleActionImplementation,\n  \"text block.set\": textBlockSetActionImplementation,\n  \"text block.unset\": textBlockUnsetActionImplementation\n};\nfunction performAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"annotation.toggle\": {\n      behaviorActionImplementations[\"annotation.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.add\": {\n      behaviorActionImplementations[\"decorator.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.remove\": {\n      behaviorActionImplementations[\"decorator.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.block\": {\n      behaviorActionImplementations[\"delete.block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.text\": {\n      behaviorActionImplementations[\"delete.text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.span\": {\n      behaviorActionImplementations[\"insert.span\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.text block\": {\n      behaviorActionImplementations[\"insert.text block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.add\": {\n      behaviorActionImplementations[\"list item.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.remove\": {\n      behaviorActionImplementations[\"list item.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block\": {\n      behaviorActionImplementations[\"move.block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block down\": {\n      behaviorActionImplementations[\"move.block down\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"move.block up\": {\n      behaviorActionImplementations[\"move.block up\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"noop\":\n      break;\n    case \"effect\": {\n      behaviorActionImplementations.effect({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select\": {\n      behaviorActionImplementations.select({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select.previous block\": {\n      behaviorActionImplementations[\"select.previous block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select.next block\": {\n      behaviorActionImplementations[\"select.next block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"style.add\": {\n      behaviorActionImplementations[\"style.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"style.remove\": {\n      behaviorActionImplementations[\"style.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"text block.set\": {\n      behaviorActionImplementations[\"text block.set\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"text block.unset\": {\n      behaviorActionImplementations[\"text block.unset\"]({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      performDefaultAction({\n        context,\n        action\n      });\n  }\n}\nfunction performDefaultAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"annotation.add\": {\n      behaviorActionImplementations[\"annotation.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"annotation.remove\": {\n      behaviorActionImplementations[\"annotation.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"blur\": {\n      behaviorActionImplementations.blur({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.toggle\": {\n      behaviorActionImplementations[\"decorator.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.backward\": {\n      behaviorActionImplementations[\"delete.backward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete.forward\": {\n      behaviorActionImplementations[\"delete.forward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"focus\": {\n      behaviorActionImplementations.focus({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.block object\": {\n      behaviorActionImplementations[\"insert.block object\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.inline object\": {\n      behaviorActionImplementations[\"insert.inline object\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.break\": {\n      behaviorActionImplementations[\"insert.break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.soft break\": {\n      behaviorActionImplementations[\"insert.soft break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert.text\": {\n      behaviorActionImplementations[\"insert.text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"list item.toggle\": {\n      behaviorActionImplementations[\"list item.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select\": {\n      behaviorActionImplementations.select({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      behaviorActionImplementations[\"style.toggle\"]({\n        context,\n        action\n      });\n  }\n}\nfunction getActiveDecorators({\n  schema,\n  slateEditorInstance\n}) {\n  const decorators = schema.decorators.map((decorator) => decorator.value);\n  return ({\n    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(slateEditorInstance) ?? {}\n  }.marks ?? []).filter((mark) => decorators.includes(mark));\n}\nfunction createEditorSnapshot({\n  editor,\n  keyGenerator,\n  schema\n}) {\n  const value = fromSlateValue(editor.children, schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), selection = toPortableTextRange(value, editor.selection, schema);\n  return {\n    context: {\n      activeDecorators: getActiveDecorators({\n        schema,\n        slateEditorInstance: editor\n      }),\n      keyGenerator,\n      schema,\n      selection,\n      value\n    }\n  };\n}\nconst editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_17__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {}\n  },\n  actions: {\n    \"add behavior to context\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"add behavior\"), /* @__PURE__ */ new Set([...context.behaviors, event.behavior]))\n    }),\n    \"remove behavior from context\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      behaviors: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"remove behavior\"), context.behaviors.delete(event.behavior), /* @__PURE__ */ new Set([...context.behaviors]))\n    }),\n    \"assign behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      behaviors: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"update behaviors\"), new Set(event.behaviors))\n    }),\n    \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      schema: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"update schema\"), event.schema)\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"patch\"), event)),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, \"mutation\"), event)),\n    \"emit read only\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n      type: \"read only\"\n    }),\n    \"emit editable\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n      type: \"editable\"\n    }),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, [\"patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        enqueue((0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(event));\n    }),\n    \"emit ready\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n      type: \"ready\"\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n      pendingEvents: []\n    }),\n    \"handle behavior event\": (0,xstate__WEBPACK_IMPORTED_MODULE_18__.b)(({\n      context,\n      event,\n      enqueue\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_17__.assertEvent)(event, [\"behavior event\", \"custom behavior event\"]);\n      const defaultAction = event.type === \"custom behavior event\" || event.behaviorEvent.type === \"copy\" || event.behaviorEvent.type === \"key.down\" || event.behaviorEvent.type === \"key.up\" || event.behaviorEvent.type === \"paste\" ? void 0 : {\n        ...event.behaviorEvent,\n        editor: event.editor\n      }, defaultActionCallback = event.type === \"behavior event\" ? event.defaultActionCallback : void 0, eventBehaviors = [...context.behaviors.values()].filter((behavior) => behavior.on === event.behaviorEvent.type);\n      if (eventBehaviors.length === 0) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n              try {\n                defaultActionCallback();\n              } catch (error) {\n                console.error(new Error(`Performing action \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n              }\n            });\n          });\n          return;\n        }\n        if (!defaultAction)\n          return;\n        withApplyingBehaviorActions(event.editor, () => {\n          slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n            try {\n              performAction({\n                context,\n                action: defaultAction\n              });\n            } catch (error) {\n              console.error(new Error(`Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n            }\n          });\n        }), event.editor.onChange();\n        return;\n      }\n      const editorSnapshot = createEditorSnapshot({\n        editor: event.editor,\n        keyGenerator: context.keyGenerator,\n        schema: context.schema\n      });\n      let behaviorOverwritten = !1;\n      for (const eventBehavior of eventBehaviors) {\n        const shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({\n          context: editorSnapshot.context,\n          event: event.behaviorEvent\n        });\n        if (!shouldRun)\n          continue;\n        const actionIntendSets = eventBehavior.actions.map((actionSet) => actionSet({\n          context: editorSnapshot.context,\n          event: event.behaviorEvent\n        }, shouldRun));\n        for (const actionIntends of actionIntendSets)\n          behaviorOverwritten = behaviorOverwritten || actionIntends.length > 0 && actionIntends.some((actionIntend) => actionIntend.type !== \"effect\"), withApplyingBehaviorActions(event.editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n              for (const actionIntend of actionIntends) {\n                if (actionIntend.type === \"raise\") {\n                  (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.isCustomBehaviorEvent)(actionIntend.event) ? enqueue.raise({\n                    type: \"custom behavior event\",\n                    behaviorEvent: actionIntend.event,\n                    editor: event.editor\n                  }) : enqueue.raise({\n                    type: \"behavior event\",\n                    behaviorEvent: actionIntend.event,\n                    editor: event.editor\n                  });\n                  continue;\n                }\n                const action = {\n                  ...actionIntend,\n                  editor: event.editor\n                };\n                try {\n                  performAction({\n                    context,\n                    action\n                  });\n                } catch (error) {\n                  console.error(new Error(`Performing action \"${action.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n                  break;\n                }\n              }\n            });\n          }), event.editor.onChange();\n        if (behaviorOverwritten) {\n          event.nativeEvent?.preventDefault();\n          break;\n        }\n      }\n      if (!behaviorOverwritten) {\n        if (defaultActionCallback) {\n          withApplyingBehaviorActions(event.editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n              try {\n                defaultActionCallback();\n              } catch (error) {\n                console.error(new Error(`Performing \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n              }\n            });\n          });\n          return;\n        }\n        if (!defaultAction)\n          return;\n        withApplyingBehaviorActions(event.editor, () => {\n          slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, () => {\n            try {\n              performAction({\n                context,\n                action: defaultAction\n              });\n            } catch (error) {\n              console.error(new Error(`Performing action \"${defaultAction.type}\" as a result of \"${event.behaviorEvent.type}\" failed due to: ${error.message}`));\n            }\n          });\n        }), event.editor.onChange();\n      }\n    })\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: new Set(input.behaviors ?? _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.coreBehaviors),\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    schema: input.schema,\n    selection: null,\n    initialReadOnly: input.readOnly ?? !1,\n    maxBlocks: input.maxBlocks,\n    value: input.value\n  }),\n  on: {\n    \"add behavior\": {\n      actions: \"add behavior to context\"\n    },\n    \"remove behavior\": {\n      actions: \"remove behavior from context\"\n    },\n    unset: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    \"value changed\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    \"invalid value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    error: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    selection: {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n        selection: ({\n          event\n        }) => event.selection\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)]\n    },\n    blurred: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    focused: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    loading: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n        type: \"loading\"\n      })\n    },\n    patches: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n        event\n      }) => event)\n    },\n    \"done loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)({\n        type: \"done loading\"\n      })\n    },\n    \"update behaviors\": {\n      actions: \"assign behaviors\"\n    },\n    \"update schema\": {\n      actions: \"assign schema\"\n    },\n    \"update value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n        value: ({\n          event\n        }) => event.value\n      })\n    },\n    \"update maxBlocks\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.a)({\n        maxBlocks: ({\n          event\n        }) => event.maxBlocks\n      })\n    }\n  },\n  type: \"parallel\",\n  states: {\n    \"edit mode\": {\n      initial: \"read only\",\n      states: {\n        \"read only\": {\n          initial: \"determine initial edit mode\",\n          states: {\n            \"determine initial edit mode\": {\n              on: {\n                \"done syncing initial value\": [{\n                  target: \"#editor.edit mode.read only.read only\",\n                  guard: ({\n                    context\n                  }) => context.initialReadOnly\n                }, {\n                  target: \"#editor.edit mode.editable\"\n                }]\n              }\n            },\n            \"read only\": {\n              on: {\n                \"update readOnly\": {\n                  guard: ({\n                    event\n                  }) => !event.readOnly,\n                  target: \"#editor.edit mode.editable\",\n                  actions: [\"emit editable\"]\n                }\n              }\n            }\n          }\n        },\n        editable: {\n          on: {\n            \"update readOnly\": {\n              guard: ({\n                event\n              }) => event.readOnly,\n              target: \"#editor.edit mode.read only.read only\",\n              actions: [\"emit read only\"]\n            },\n            \"behavior event\": {\n              actions: \"handle behavior event\"\n            },\n            \"custom behavior event\": {\n              actions: \"handle behavior event\"\n            },\n            \"annotation.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            blur: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            \"custom.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => ({\n                type: \"custom.*\",\n                event\n              }))\n            },\n            \"decorator.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            focus: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            \"insert.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            \"list item.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            select: {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            },\n            \"style.*\": {\n              actions: (0,xstate__WEBPACK_IMPORTED_MODULE_18__.e)(({\n                event\n              }) => event)\n            }\n          }\n        }\n      }\n    },\n    setup: {\n      initial: \"setting up\",\n      states: {\n        \"setting up\": {\n          exit: [\"emit ready\"],\n          on: {\n            patch: {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            },\n            \"done syncing initial value\": {\n              target: \"pristine\"\n            }\n          }\n        },\n        pristine: {\n          initial: \"idle\",\n          states: {\n            idle: {\n              on: {\n                normalizing: {\n                  target: \"normalizing\"\n                },\n                patch: {\n                  actions: \"defer event\",\n                  target: \"#editor.setup.dirty\"\n                },\n                mutation: {\n                  actions: \"defer event\",\n                  target: \"#editor.setup.dirty\"\n                }\n              }\n            },\n            normalizing: {\n              on: {\n                \"done normalizing\": {\n                  target: \"idle\"\n                },\n                patch: {\n                  actions: \"defer event\"\n                },\n                mutation: {\n                  actions: \"defer event\"\n                }\n              }\n            }\n          }\n        },\n        dirty: {\n          entry: [\"emit pending events\", \"clear pending events\"],\n          on: {\n            patch: {\n              actions: \"emit patch event\"\n            },\n            mutation: {\n              actions: \"emit mutation event\"\n            }\n          }\n        }\n      }\n    }\n  }\n});\nfunction getValue({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  return fromSlateValue(slateEditorInstance.children, editorActorSnapshot.context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditorInstance));\n}\nfunction defaultCompare(a, b) {\n  return a === b;\n}\nfunction useEditorSelector(editor, selector, t0) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(3), compare = t0 === void 0 ? defaultCompare : t0;\n  let t1;\n  return $[0] !== editor._internal.slateEditor.instance || $[1] !== selector ? (t1 = (editorActorSnapshot) => {\n    const snapshot = getEditorSnapshot({\n      editorActorSnapshot,\n      slateEditorInstance: editor._internal.slateEditor.instance\n    });\n    return selector(snapshot);\n  }, $[0] = editor._internal.slateEditor.instance, $[1] = selector, $[2] = t1) : t1 = $[2], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(editor._internal.editorActor, t1, compare);\n}\nfunction getEditorSnapshot({\n  editorActorSnapshot,\n  slateEditorInstance\n}) {\n  return {\n    context: {\n      activeDecorators: getActiveDecorators({\n        schema: editorActorSnapshot.context.schema,\n        slateEditorInstance\n      }),\n      keyGenerator: editorActorSnapshot.context.keyGenerator,\n      schema: editorActorSnapshot.context.schema,\n      selection: editorActorSnapshot.context.selection,\n      value: getValue({\n        editorActorSnapshot,\n        slateEditorInstance\n      })\n    }\n  };\n}\nconst defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nfunction createEditor(config) {\n  const editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_26__.A)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  });\n  return editorActor.start(), createEditorFromActor(editorActor);\n}\nfunction useCreateEditor(config) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n  let t0;\n  $[0] !== config ? (t0 = editorConfigToMachineInput(config), $[0] = config, $[1] = t0) : t0 = $[1];\n  let t1;\n  $[2] !== t0 ? (t1 = {\n    input: t0\n  }, $[2] = t0, $[3] = t1) : t1 = $[3];\n  const editorActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useActorRef)(editorMachine, t1);\n  let t2, t3;\n  return $[4] !== editorActor ? (t3 = createEditorFromActor(editorActor), $[4] = editorActor, $[5] = t3) : t3 = $[5], t2 = t3, t2;\n}\nfunction editorConfigToMachineInput(config) {\n  return {\n    behaviors: config.behaviors,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema: config.schemaDefinition ? compileSchemaDefinition(config.schemaDefinition) : createEditorSchema(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)),\n    value: config.initialValue\n  };\n}\nfunction createEditorFromActor(editorActor) {\n  const slateEditor = createSlateEditor({\n    editorActor\n  }), editable = createEditableAPI(slateEditor.instance, editorActor);\n  return {\n    getSnapshot: () => getEditorSnapshot({\n      editorActorSnapshot: editorActor.getSnapshot(),\n      slateEditorInstance: slateEditor.instance\n    }),\n    registerBehavior: (config) => (editorActor.send({\n      type: \"add behavior\",\n      behavior: config.behavior\n    }), () => {\n      editorActor.send({\n        type: \"remove behavior\",\n        behavior: config.behavior\n      });\n    }),\n    send: (event) => {\n      editorActor.send(event);\n    },\n    on: (event, listener) => editorActor.on(\n      event,\n      // @ts-expect-error\n      listener\n    ),\n    _internal: {\n      editable,\n      editorActor,\n      slateEditor\n    }\n  };\n}\nconst EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)({}), PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n  return selection;\n}, debug$5 = debugWithName(\"component:PortableTextEditor:SelectionProvider\");\nfunction PortableTextEditorSelectionProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n  let t0, t1;\n  $[0] !== props.editorActor ? (t0 = () => {\n    debug$5(\"Subscribing to selection changes\");\n    const subscription = props.editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(() => {\n        setSelection(event.selection);\n      });\n    });\n    return () => {\n      debug$5(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1);\n  let t2;\n  return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;\n}\nconst debug$4 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_4__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_27__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor instance\n   */\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  constructor(props) {\n    super(props), props.editor ? this.editor = props.editor : this.editor = createEditor({\n      keyGenerator: props.keyGenerator ?? defaultKeyGenerator,\n      schema: props.schemaType,\n      initialValue: props.value,\n      maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n      readOnly: props.readOnly\n    }), this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.schema, this.editable = this.editor._internal.editable;\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = createEditorSchema(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({\n      type: \"update schema\",\n      schema: this.schemaTypes\n    })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n      type: \"update readOnly\",\n      readOnly: this.props.readOnly ?? !1\n    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n      type: \"update maxBlocks\",\n      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n    }), this.props.value !== prevProps.value && this.editor._internal.editorActor.send({\n      type: \"update value\",\n      value: this.props.value\n    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n  }\n  setEditable = (editable) => {\n    this.editor._internal.editable = {\n      ...this.editor._internal.editable,\n      ...editable\n    };\n  };\n  render() {\n    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, { editorActor: this.editor._internal.editorActor, onChange: (change) => {\n        this.props.editor || this.props.onChange(change), this.change$.next(change);\n      } }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, { editorActor: this.editor._internal.editorActor, slateEditor: this.editor._internal.slateEditor.instance }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_16__.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, { editorActor: this.editor._internal.editorActor, children: this.props.children }) }) }) })\n    ] });\n  }\n  // Static API methods\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  static blur = (editor) => {\n    debug$4(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  static focus = (editor) => {\n    debug$4(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  static focusChild = (editor) => editor.editable?.focusChild();\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  static getValue = (editor) => editor.editable?.getValue();\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  static insertChild = (editor, type, value) => (debug$4(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  static select = (editor, selection) => {\n    debug$4(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  static toggleBlockStyle = (editor, blockStyle) => (debug$4(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  static toggleMark = (editor, mark) => {\n    debug$4(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  static getFragment = (editor) => (debug$4(\"Host getting fragment\"), editor.editable?.getFragment());\n  static undo = (editor) => {\n    debug$4(\"Host undoing\"), editor.editable?.undo();\n  };\n  static redo = (editor) => {\n    debug$4(\"Host redoing\"), editor.editable?.redo();\n  };\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n  let t0, t1;\n  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\nfunction RouteEventsToChanges(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n  let t0;\n  $[0] !== props ? (t0 = (change) => props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];\n  const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_28__.useEffectEvent)(t0);\n  let t1, t2;\n  return $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = () => {\n    debug$4(\"Subscribing to editor changes\");\n    const sub = props.editorActor.on(\"*\", (event) => {\n      bb5: switch (event.type) {\n        case \"blurred\": {\n          handleChange({\n            type: \"blur\",\n            event: event.event\n          });\n          break bb5;\n        }\n        case \"patch\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !0\n          });\n          break bb5;\n        }\n        case \"done loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !1\n          });\n          break bb5;\n        }\n        case \"focused\": {\n          handleChange({\n            type: \"focus\",\n            event: event.event\n          });\n          break bb5;\n        }\n        case \"value changed\": {\n          handleChange({\n            type: \"value\",\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"invalid value\": {\n          handleChange({\n            type: \"invalidValue\",\n            resolution: event.resolution,\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"error\": {\n          handleChange({\n            ...event,\n            level: \"warning\"\n          });\n          break bb5;\n        }\n        case \"mutation\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"ready\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"selection\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"unset\":\n          handleChange(event);\n      }\n    });\n    return () => {\n      debug$4(\"Unsubscribing to changes\"), sub.unsubscribe();\n    };\n  }, t2 = [props.editorActor, handleChange], $[2] = handleChange, $[3] = props.editorActor, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t1, t2), null;\n}\nconst debug$3 = debugWithName(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation\n  } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => block ? [{\n    _key: block?._key\n  }, \"children\", {\n    _key: leaf._key\n  }] : [], [block, leaf._key]), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    debug$3(\"Setting selection and focus from range\");\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const onBlur = editorActor.on(\"blur\", () => {\n      setFocused(!1), setSelected(!1);\n    }), onFocus = editorActor.on(\"focus\", () => {\n      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);\n      sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n    }), onSelection = editorActor.on(\"selection\", (event) => {\n      event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n    });\n    return () => {\n      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n    };\n  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  const content = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    let returnedChildren = children;\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {\n      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);\n      if (schemaType && renderDecorator) {\n        const _props = Object.defineProperty({\n          children: returnedChildren,\n          editorElementRef: spanRef,\n          focused,\n          path,\n          selected,\n          schemaType,\n          value: mark_1\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n          }\n        });\n        returnedChildren = renderDecorator(_props);\n      }\n    }), block && annotations.length > 0 && annotations.forEach((annotation) => {\n      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);\n      if (schemaType_0)\n        if (renderAnnotation) {\n          const _props_0 = Object.defineProperty({\n            block,\n            children: returnedChildren,\n            editorElementRef: spanRef,\n            focused,\n            path,\n            selected,\n            schemaType: schemaType_0,\n            value: annotation\n          }, \"type\", {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n            }\n          });\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ref: spanRef, children: renderAnnotation(_props_0) });\n        } else\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultAnnotation, { annotation, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ref: spanRef, children: returnedChildren }) });\n    }), block && renderChild)) {\n      const child = block.children.find((_child) => _child._key === leaf._key);\n      if (child) {\n        const _props_1 = Object.defineProperty({\n          annotations,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: returnedChildren }),\n          editorElementRef: spanRef,\n          focused,\n          path,\n          schemaType: schemaTypes.span,\n          selected,\n          value: child\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n          }\n        });\n        returnedChildren = renderChild(_props_1);\n      }\n    }\n    return returnedChildren;\n  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);\n};\nLeaf.displayName = \"Leaf\";\nconst debug$2 = debugWithName(\"plugin:withHotKeys\");\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions ?? {};\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.isHotkey)(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$2(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                  type: \"behavior event\",\n                  behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                  },\n                  editor\n                });\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.isHotkey)(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n    }, editor;\n  };\n}\nconst debug$1 = debugWithName(\"plugin:withInsertData\");\nfunction createWithInsertData(editorActor, schemaTypes) {\n  return function(editor) {\n    const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks) => blocks.map((block) => editor.isTextBlock(block) ? block.children.map((child) => child._type === spanTypeName ? child.text : `[${schemaTypes.inlineObjects.find((t) => t.name === child._type)?.title || \"Object\"}]`).join(\"\") : `[${schemaTypes.blockObjects.find((t) => t.name === block._type)?.title || \"Object\"}]`).join(`\n\n`);\n    return editor.setFragmentData = (data, originEvent) => {\n      const {\n        selection\n      } = editor;\n      if (!selection)\n        return;\n      const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(selection), startVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n        at: start.path\n      }), endVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n        at: end.path\n      });\n      if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) && !startVoid)\n        return;\n      const domRange = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMRange(editor, selection);\n      let contents = domRange.cloneContents();\n      if (endVoid) {\n        const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, voidNode);\n        r.setEndAfter(domNode), contents = r.cloneContents();\n      }\n      Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw) => {\n        const isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n        zw.textContent = isNewline ? `\n` : \"\";\n      }), Array.from(contents.querySelectorAll(\"*\")).forEach((elm) => {\n        elm.removeAttribute(\"contentEditable\"), elm.removeAttribute(\"data-slate-inline\"), elm.removeAttribute(\"data-slate-leaf\"), elm.removeAttribute(\"data-slate-node\"), elm.removeAttribute(\"data-slate-spacer\"), elm.removeAttribute(\"data-slate-string\"), elm.removeAttribute(\"data-slate-zero-width\"), elm.removeAttribute(\"draggable\");\n        for (const key in elm.attributes)\n          elm.hasAttribute(key) && elm.removeAttribute(key);\n      });\n      const div = contents.ownerDocument.createElement(\"div\");\n      div.appendChild(contents), div.setAttribute(\"hidden\", \"true\"), contents.ownerDocument.body.appendChild(div);\n      const asHTML = div.innerHTML;\n      contents.ownerDocument.body.removeChild(div);\n      const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);\n      data.clearData(), data.setData(\"text/plain\", asPlainText), data.setData(\"text/html\", asHTML), data.setData(\"application/json\", asJSON), data.setData(\"application/x-portable-text\", asJSON), debug$1(\"text\", asPlainText), data.setData(\"application/x-portable-text-event-origin\", originEvent || \"external\"), debug$1(\"Set fragment data\", asJSON, asHTML);\n    }, editor.insertPortableTextData = (data) => {\n      if (!editor.selection)\n        return !1;\n      const pText = data.getData(\"application/x-portable-text\"), origin = data.getData(\"application/x-portable-text-event-origin\");\n      if (debug$1(`Inserting portable text from ${origin} event`, pText), pText) {\n        const parsed = JSON.parse(pText);\n        if (Array.isArray(parsed) && parsed.length > 0) {\n          const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {\n            schemaTypes\n          }), editorActor.getSnapshot().context.keyGenerator, spanTypeName, schemaTypes), validation = validateValue(parsed, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n          if (!validation.valid && !validation.resolution?.autoResolve) {\n            const errorDescription = `${validation.resolution?.description}`;\n            return editorActor.send({\n              type: \"error\",\n              name: \"pasteError\",\n              description: errorDescription,\n              data: validation\n            }), debug$1(\"Invalid insert result\", validation), !1;\n          }\n          return _insertFragment(editor, slateValue, schemaTypes), !0;\n        }\n      }\n      return !1;\n    }, editor.insertTextOrHTMLData = (data) => {\n      if (!editor.selection)\n        return debug$1(\"No selection, not inserting\"), !1;\n      const html = data.getData(\"text/html\"), text = data.getData(\"text/plain\");\n      if (html || text) {\n        debug$1(\"Inserting data\", data);\n        let portableText, fragment, insertedType;\n        if (html) {\n          if (portableText = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(html, schemaTypes.portableText, {\n            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode,\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator\n          }), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"HTML\", portableText.length === 0)\n            return !1;\n        } else {\n          const textToHtml = `<html><body>${escapeHtml(text).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`;\n          portableText = (0,_portabletext_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(textToHtml, schemaTypes.portableText, {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator\n          }), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"text\";\n        }\n        const validation = validateValue(portableText, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n        if (!validation.valid) {\n          const errorDescription = `Could not validate the resulting portable text to insert.\n${validation.resolution?.description}\nTry to insert as plain text (shift-paste) instead.`;\n          return editorActor.send({\n            type: \"error\",\n            name: \"pasteError\",\n            description: errorDescription,\n            data: validation\n          }), debug$1(\"Invalid insert result\", validation), !1;\n        }\n        return debug$1(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), !0;\n      }\n      return !1;\n    }, editor.insertData = (data) => {\n      editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);\n    }, editor.insertFragmentData = (data) => {\n      const fragment = data.getData(\"application/x-portable-text\");\n      if (fragment) {\n        const parsed = JSON.parse(fragment);\n        return editor.insertFragment(parsed), !0;\n      }\n      return !1;\n    }, editor;\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction _regenerateKeys(editor, fragment, keyGenerator, spanTypeName, editorTypes) {\n  return fragment.map((node) => {\n    const newNode = {\n      ...node\n    };\n    if (editor.isTextBlock(newNode)) {\n      const annotations = editorTypes.annotations.map((t) => t.name);\n      if (annotations.length === 0) {\n        const {\n          markDefs,\n          ...NewNodeNoDefs\n        } = newNode;\n        return {\n          ...NewNodeNoDefs,\n          _key: keyGenerator()\n        };\n      }\n      if ((newNode.markDefs || []).some((def) => !annotations.includes(def._type))) {\n        const allowedAnnotations = (newNode.markDefs || []).filter((def) => annotations.includes(def._type));\n        return {\n          ...newNode,\n          markDefs: allowedAnnotations,\n          _key: keyGenerator()\n        };\n      }\n      newNode.markDefs = (newNode.markDefs || []).map((def) => {\n        const oldKey = def._key, newKey = keyGenerator();\n        return newNode.children = newNode.children.map((child) => child._type === spanTypeName && editor.isTextSpan(child) ? {\n          ...child,\n          marks: child.marks && child.marks.includes(oldKey) ? [...child.marks].filter((mark) => mark !== oldKey).concat(newKey) : child.marks\n        } : child), {\n          ...def,\n          _key: newKey\n        };\n      });\n    }\n    const nodeWithNewKeys = {\n      ...newNode,\n      _key: keyGenerator()\n    };\n    return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({\n      ...child,\n      _key: keyGenerator()\n    }))), nodeWithNewKeys;\n  });\n}\nfunction _insertFragment(editor, fragment, schemaTypes) {\n  editor.withoutNormalizing(() => {\n    if (!editor.selection)\n      return;\n    const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n      depth: 1\n    });\n    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n      const {\n        markDefs\n      } = focusBlock;\n      debug$1(\"Mixing markDefs of focusBlock and fragments[0] block\", markDefs, fragment[0].markDefs), lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n        markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...fragment[0].markDefs || [], ...markDefs || []])\n      }, {\n        at: focusPath,\n        mode: \"lowest\",\n        voids: !1\n      });\n    }\n    isEqualToEmptyEditor(editor.children, schemaTypes) ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n      at: [0, 0]\n    }), editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n      at: [0]\n    })) : editor.insertFragment(fragment);\n  }), editor.onChange();\n}\nfunction withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations\n}) {\n  const originalApply = slateEditor.apply;\n  return slateEditor.apply = (op) => {\n    originalApply(op), !editorActor.getSnapshot().matches({\n      \"edit mode\": \"read only\"\n    }) && op.type !== \"set_selection\" && syncRangeDecorations(op);\n  }, () => {\n    slateEditor.apply = originalApply;\n  };\n}\nconst debug = debugWithName(\"component:Editable\"), PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n}, PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_4__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = usePortableTextEditor(), ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(rangeDecorations), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(EditorActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(editorActor, (s) => s.matches({\n    \"edit mode\": \"read only\"\n  })), schemaTypes = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(editorActor, (s_0) => s_0.context.schema), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlate)(), blockTypeName = schemaTypes.block.name;\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    const withInsertData = createWithInsertData(editorActor, schemaTypes);\n    if (readOnly)\n      return debug(\"Editable is in read only mode\"), withInsertData(slateEditor);\n    const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);\n    return debug(\"Editable is in edit mode\"), withInsertData(withHotKeys(slateEditor));\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, schemaTypes, slateEditor]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((lProps) => {\n    if (lProps.leaf._type === \"span\") {\n      let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });\n      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\")\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),\n          rendered\n        ] });\n      const decoration = lProps.leaf.rangeDecoration;\n      return decoration && (rendered = decoration.component({\n        children: rendered\n      })), rendered;\n    }\n    return lProps.children;\n  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || editorActor.send({\n          type: \"selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((operation) => {\n    if (rangeDecorations && rangeDecorations.length > 0) {\n      const newSlateRanges = [];\n      if (rangeDecorations.forEach((rangeDecorationItem) => {\n        const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);\n        if (!slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(slateRange_0)) {\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: null,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n          return;\n        }\n        let newRange;\n        if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {\n          const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: newRangeSelection,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n        }\n        newRange !== null && newSlateRanges.push({\n          ...newRange || slateRange_0,\n          rangeDecoration: rangeDecorationItem\n        });\n      }), newSlateRanges.length > 0) {\n        setRangeDecorationsState(newSlateRanges);\n        return;\n      }\n    }\n    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);\n  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    const onReady = editorActor.on(\"ready\", () => {\n      syncRangeDecorations(), restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n  }, [syncRangeDecorations, syncedRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n  }, [rangeDecorations, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations\n    });\n    return () => teardown();\n  }, [editorActor, slateEditor, syncRangeDecorations]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event) => {\n    onCopy ? onCopy(event) !== void 0 && event.preventDefault() : event.nativeEvent.clipboardData && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"copy\",\n        data: event.nativeEvent.clipboardData\n      },\n      editor: slateEditor,\n      nativeEvent: event\n    });\n  }, [onCopy, editorActor, slateEditor]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_0) => {\n    const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({\n      event: event_0,\n      value: value_0,\n      path,\n      schemaTypes\n    });\n    onPasteResult || !slateEditor.selection ? (event_0.preventDefault(), editorActor.send({\n      type: \"loading\"\n    }), Promise.resolve(onPasteResult).then((result_0) => {\n      debug(\"Custom paste function from client resolved\", result_0), !result_0 || !result_0.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment(toSlateValue(result_0.insert, {\n        schemaTypes\n      })) : console.warn(\"Your onPaste function returned something unexpected:\", result_0);\n    }).catch((error) => (console.error(error), error)).finally(() => {\n      editorActor.send({\n        type: \"done loading\"\n      });\n    })) : event_0.nativeEvent.clipboardData && editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"paste\",\n        data: event_0.nativeEvent.clipboardData\n      },\n      editor: slateEditor,\n      nativeEvent: event_0\n    }), debug(\"No result from custom paste handler, pasting normally\");\n  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_1) => {\n    if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {\n      const selection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === null && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_15__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n        type: \"focused\",\n        event: event_1\n      });\n      const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === newSelection && editorActor.send({\n        type: \"selection\",\n        selection\n      });\n    }\n  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_2) => {\n    onClick && onClick(event_2);\n    const focusBlockPath = slateEditor.selection ? slateEditor.selection.focus.path.slice(0, 1) : void 0, focusBlock = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(slateEditor, focusBlockPath) : void 0, [_, lastNodePath] = slate__WEBPACK_IMPORTED_MODULE_15__.Node.last(slateEditor, []), lastBlockPath = lastNodePath.slice(0, 1), lastNodeFocused = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(lastBlockPath, focusBlockPath) : !1, lastBlockIsVoid = focusBlock ? !slateEditor.isTextBlock(focusBlock) : !1;\n    slateEditor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(slateEditor.selection) && lastNodeFocused && lastBlockIsVoid && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n      decorators: []\n    })), slateEditor.onChange());\n  }, [onClick, slateEditor]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_3) => {\n    onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({\n      type: \"blurred\",\n      event: event_3\n    });\n  }, [editorActor, onBlur]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_4) => {\n    onBeforeInput && onBeforeInput(event_4);\n  }, [onBeforeInput]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findDocumentOrShadowRoot(slateEditor), {\n      activeElement\n    } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_5) => {\n    props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5), event_5.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"key.down\",\n        keyboardEvent: {\n          key: event_5.key,\n          code: event_5.code,\n          altKey: event_5.altKey,\n          ctrlKey: event_5.ctrlKey,\n          metaKey: event_5.metaKey,\n          shiftKey: event_5.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_5\n    });\n  }, [props, editorActor, slateEditor]), handleKeyUp = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_6) => {\n    props.onKeyUp && props.onKeyUp(event_6), event_6.isDefaultPrevented() || editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"key.up\",\n        keyboardEvent: {\n          key: event_6.key,\n          code: event_6.code,\n          altKey: event_6.altKey,\n          ctrlKey: event_6.ctrlKey,\n          metaKey: event_6.metaKey,\n          shiftKey: event_6.shiftKey\n        }\n      },\n      editor: slateEditor,\n      nativeEvent: event_6\n    });\n  }, [props, editorActor, slateEditor]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ : (_editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(([, path_0]) => {\n    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path_0.length === 0)\n      return [];\n    const result_1 = rangeDecorationState.filter((item) => slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.focus.path, path_0) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.anchor.path, path_0) : slate__WEBPACK_IMPORTED_MODULE_15__.Range.intersection(item, {\n      anchor: {\n        path: path_0,\n        offset: 0\n      },\n      focus: {\n        path: path_0,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(item, path_0));\n    return result_1.length > 0 ? result_1 : [];\n  }, [slateEditor, schemaTypes, rangeDecorationState]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_16__.Editable,\n    {\n      ...restProps,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nconst EditorContext = react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction EditorProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(28), editor = useCreateEditor(props.initialConfig), editorActor = editor._internal.editorActor, slateEditor = editor._internal.slateEditor;\n  let t0, t1;\n  $[0] !== editor ? (t1 = new PortableTextEditor({\n    editor\n  }), $[0] = editor, $[1] = t1) : t1 = $[1], t0 = t1;\n  const portableTextEditor = t0;\n  let t2;\n  $[2] !== portableTextEditor.change$ ? (t2 = (change) => {\n    portableTextEditor.change$.next(change);\n  }, $[2] = portableTextEditor.change$, $[3] = t2) : t2 = $[3];\n  let t3;\n  $[4] !== editorActor || $[5] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, { editorActor, onChange: t2 }), $[4] = editorActor, $[5] = t2, $[6] = t3) : t3 = $[6];\n  let t4;\n  $[7] !== editorActor || $[8] !== slateEditor.instance ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, { editorActor, slateEditor: slateEditor.instance }), $[7] = editorActor, $[8] = slateEditor.instance, $[9] = t4) : t4 = $[9];\n  let t5;\n  $[10] !== editorActor || $[11] !== props.children ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, { editorActor, children: props.children }), $[10] = editorActor, $[11] = props.children, $[12] = t5) : t5 = $[12];\n  let t6;\n  $[13] !== portableTextEditor || $[14] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor, children: t5 }), $[13] = portableTextEditor, $[14] = t5, $[15] = t6) : t6 = $[15];\n  let t7;\n  $[16] !== slateEditor.initialValue || $[17] !== slateEditor.instance || $[18] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_16__.Slate, { editor: slateEditor.instance, initialValue: slateEditor.initialValue, children: t6 }), $[16] = slateEditor.initialValue, $[17] = slateEditor.instance, $[18] = t6, $[19] = t7) : t7 = $[19];\n  let t8;\n  $[20] !== editorActor || $[21] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, { value: editorActor, children: t7 }), $[20] = editorActor, $[21] = t7, $[22] = t8) : t8 = $[22];\n  let t9;\n  return $[23] !== editor || $[24] !== t3 || $[25] !== t4 || $[26] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(EditorContext.Provider, { value: editor, children: [\n    t3,\n    t4,\n    t8\n  ] }), $[23] = editor, $[24] = t3, $[25] = t4, $[26] = t8, $[27] = t9) : t9 = $[27], t9;\n}\nfunction useEditor() {\n  const editor = react__WEBPACK_IMPORTED_MODULE_4__.useContext(EditorContext);\n  if (!editor)\n    throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n  return editor;\n}\nfunction EditorEventListener(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4), editor = useEditor(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_28__.useEffectEvent)(props.on);\n  let t0, t1;\n  return $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [editor, on], $[0] = editor, $[1] = on, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzRIO0FBQzNIO0FBQ2U7QUFDQztBQUNqQjtBQUNOO0FBQ3VJO0FBQ2M7QUFDMUU7QUFDakY7QUFDZTtBQUNUO0FBQ0g7QUFDbUI7QUFDbUQ7QUFDa0I7QUFDL0U7QUFDWTtBQUNwQjtBQUNnQjtBQUNWO0FBQ3lDO0FBQ1k7QUFDSTtBQUMzQztBQUNLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlDQUFpQztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMERBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyRUFBMkUsMERBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQiwyREFBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0NBQW9DLDZDQUFTO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCLDZDQUFTO0FBQ3RDLE9BQU87QUFDUDtBQUNBO0FBQ0EsOEJBQThC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Q2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxP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QyxrQ0FBa0M7QUFDckk7QUFDQSxrR0FBa0csdURBQUksMkJBQTJCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQyxnQ0FBZ0MsaUVBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywrRkFBK0YsZ0RBQVM7QUFDM0c7QUFhRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvaW5kZXguanM/MmQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tIFwiQHNhbml0eS9zY2hlbWFcIjtcbmltcG9ydCB7IGRlZmluZVR5cGUsIGRlZmluZUZpZWxkLCBpc0tleVNlZ21lbnQsIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4gYXMgaXNQb3J0YWJsZVRleHRTcGFuJDEsIGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCBzdGFydENhc2UgZnJvbSBcImxvZGFzaC5zdGFydGNhc2VcIjtcbmltcG9ydCB7IGpzeHMsIGpzeCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZVNlbGVjdG9yLCB1c2VBY3RvclJlZiB9IGZyb20gXCJAeHN0YXRlL3JlYWN0XCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCBub29wIGZyb20gXCJsb2Rhc2gvbm9vcC5qc1wiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbywgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgc3RhcnRUcmFuc2l0aW9uLCBDb21wb25lbnQsIHVzZUNhbGxiYWNrLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBFZGl0b3IsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBSYW5nZSwgUG9pbnQsIFRleHQsIFBhdGgsIFRyYW5zZm9ybXMsIE9wZXJhdGlvbiwgTm9kZSwgY3JlYXRlRWRpdG9yIGFzIGNyZWF0ZUVkaXRvciQxLCBkZWxldGVCYWNrd2FyZCwgZGVsZXRlRm9yd2FyZCwgaW5zZXJ0VGV4dCB9IGZyb20gXCJzbGF0ZVwiO1xuaW1wb3J0IHsgdXNlU2xhdGVTdGF0aWMsIFJlYWN0RWRpdG9yLCB1c2VTZWxlY3RlZCwgd2l0aFJlYWN0LCBTbGF0ZSwgdXNlU2xhdGUsIEVkaXRhYmxlIH0gZnJvbSBcInNsYXRlLXJlYWN0XCI7XG5pbXBvcnQgZGVidWckayBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IGMgfSBmcm9tIFwicmVhY3QtY29tcGlsZXItcnVudGltZVwiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdEV2ZW50IH0gZnJvbSBcInVzZS1lZmZlY3QtZXZlbnRcIjtcbmltcG9ydCB7IHNldHVwLCBlbWl0LCBhc3NpZ24sIGZyb21DYWxsYmFjaywgYXNzZXJ0RXZlbnQsIGVucXVldWVBY3Rpb25zLCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IHVuc2V0LCBzZXQsIHNldElmTWlzc2luZywgaW5zZXJ0LCBkaWZmTWF0Y2hQYXRjaCBhcyBkaWZmTWF0Y2hQYXRjaCQxLCBhcHBseUFsbCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3BhdGNoZXNcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSBcImxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI7XG5pbXBvcnQgZ2V0IGZyb20gXCJsb2Rhc2gvZ2V0LmpzXCI7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSBcImxvZGFzaC9pc1VuZGVmaW5lZC5qc1wiO1xuaW1wb3J0IG9taXRCeSBmcm9tIFwibG9kYXNoL29taXRCeS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlR3VhcmRzIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9zZWxlY3Rvci5pcy1zZWxlY3Rpb24tY29sbGFwc2VkLmpzXCI7XG5pbXBvcnQgeyBibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50IH0gZnJvbSBcIi4vX2NodW5rcy1lcy91dGlsLmlzLWVtcHR5LXRleHQtYmxvY2suanNcIjtcbmltcG9ydCB7IGNvcmVCZWhhdmlvcnMsIGlzQ3VzdG9tQmVoYXZpb3JFdmVudCwgaXNIb3RrZXkgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanNcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuaW1wb3J0IHsgaHRtbFRvQmxvY2tzIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvYmxvY2stdG9vbHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvclNjaGVtYShwb3J0YWJsZVRleHRUeXBlKSB7XG4gIGlmICghcG9ydGFibGVUZXh0VHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgJ3BvcnRhYmxldGV4dFR5cGUnIG1pc3NpbmcgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgYmxvY2tUeXBlID0gcG9ydGFibGVUZXh0VHlwZS5vZj8uZmluZChmaW5kQmxvY2tUeXBlKTtcbiAgaWYgKCFibG9ja1R5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgdHlwZSBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBjaGlsZHJlbkZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IFwiY2hpbGRyZW5cIik7XG4gIGlmICghY2hpbGRyZW5GaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZHJlbiBmaWVsZCBmb3IgYmxvY2sgdHlwZSBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3Qgb2ZUeXBlID0gY2hpbGRyZW5GaWVsZC50eXBlLm9mO1xuICBpZiAoIW9mVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZCB0eXBlcyBmb3IgYmxvY2sgY2hpbGRyZW4gbm90IGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBzcGFuVHlwZSA9IG9mVHlwZS5maW5kKChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgPT09IFwic3BhblwiKTtcbiAgaWYgKCFzcGFuVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGFuIHR5cGUgbm90IGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBpbmxpbmVPYmplY3RUeXBlcyA9IG9mVHlwZS5maWx0ZXIoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSAhPT0gXCJzcGFuXCIpIHx8IFtdLCBibG9ja09iamVjdFR5cGVzID0gcG9ydGFibGVUZXh0VHlwZS5vZj8uZmlsdGVyKChmaWVsZCkgPT4gZmllbGQubmFtZSAhPT0gYmxvY2tUeXBlLm5hbWUpIHx8IFtdO1xuICByZXR1cm4ge1xuICAgIHN0eWxlczogcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSxcbiAgICBkZWNvcmF0b3JzOiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpLFxuICAgIGxpc3RzOiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpLFxuICAgIGJsb2NrOiBibG9ja1R5cGUsXG4gICAgc3Bhbjogc3BhblR5cGUsXG4gICAgcG9ydGFibGVUZXh0OiBwb3J0YWJsZVRleHRUeXBlLFxuICAgIGlubGluZU9iamVjdHM6IGlubGluZU9iamVjdFR5cGVzLFxuICAgIGJsb2NrT2JqZWN0czogYmxvY2tPYmplY3RUeXBlcyxcbiAgICBhbm5vdGF0aW9uczogc3BhblR5cGUuYW5ub3RhdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSkge1xuICBjb25zdCBzdHlsZUZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoYnRGaWVsZCkgPT4gYnRGaWVsZC5uYW1lID09PSBcInN0eWxlXCIpO1xuICBpZiAoIXN0eWxlRmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmaWVsZCB3aXRoIG5hbWUgJ3N0eWxlJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3QgdGV4dFN0eWxlcyA9IHN0eWxlRmllbGQudHlwZS5vcHRpb25zPy5saXN0ICYmIHN0eWxlRmllbGQudHlwZS5vcHRpb25zLmxpc3Q/LmZpbHRlcigoc3R5bGUpID0+IHN0eWxlLnZhbHVlKTtcbiAgaWYgKCF0ZXh0U3R5bGVzIHx8IHRleHRTdHlsZXMubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZSBmaWVsZHMgbmVlZCBhdCBsZWFzdCBvbmUgc3R5bGUgZGVmaW5lZC4gSS5lOiB7dGl0bGU6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCd9LlwiKTtcbiAgcmV0dXJuIHRleHRTdHlsZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpIHtcbiAgcmV0dXJuIHNwYW5UeXBlLmRlY29yYXRvcnM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpIHtcbiAgY29uc3QgbGlzdEZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcz8uZmluZCgoYnRGaWVsZCkgPT4gYnRGaWVsZC5uYW1lID09PSBcImxpc3RJdGVtXCIpO1xuICBpZiAoIWxpc3RGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGZpZWxkIHdpdGggbmFtZSAnbGlzdEl0ZW0nIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCIpO1xuICBjb25zdCBsaXN0SXRlbXMgPSBsaXN0RmllbGQudHlwZS5vcHRpb25zPy5saXN0ICYmIGxpc3RGaWVsZC50eXBlLm9wdGlvbnMubGlzdC5maWx0ZXIoKGxpc3QpID0+IGxpc3QudmFsdWUpO1xuICBpZiAoIWxpc3RJdGVtcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGlzdCBmaWVsZCBuZWVkIGF0IGxlYXN0IHRvIGJlIGFuIGVtcHR5IGFycmF5XCIpO1xuICByZXR1cm4gbGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPyBmaW5kQmxvY2tUeXBlKHR5cGUudHlwZSkgOiB0eXBlLm5hbWUgPT09IFwiYmxvY2tcIiA/IHR5cGUgOiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGRlZmluaXRpb247XG59XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gIGNvbnN0IGJsb2NrT2JqZWN0cyA9IGRlZmluaXRpb24/LmJsb2NrT2JqZWN0cz8ubWFwKChibG9ja09iamVjdCkgPT4gZGVmaW5lVHlwZSh7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAvLyBWZXJ5IG5haXZlIHdheSB0byB3b3JrIGFyb3VuZCBgU2FuaXR5U2NoZW1hLmNvbXBpbGVgIGFkZGluZyBkZWZhdWx0XG4gICAgLy8gZmllbGRzIHRvIG9iamVjdHMgd2l0aCB0aGUgbmFtZSBgaW1hZ2VgXG4gICAgbmFtZTogYmxvY2tPYmplY3QubmFtZSA9PT0gXCJpbWFnZVwiID8gXCJ0bXAtaW1hZ2VcIiA6IGJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgdGl0bGU6IGJsb2NrT2JqZWN0Lm5hbWUgPT09IFwiaW1hZ2VcIiAmJiBibG9ja09iamVjdC50aXRsZSA9PT0gdm9pZCAwID8gXCJJbWFnZVwiIDogYmxvY2tPYmplY3QudGl0bGUsXG4gICAgZmllbGRzOiBbXVxuICB9KSkgPz8gW10sIGlubGluZU9iamVjdHMgPSBkZWZpbml0aW9uPy5pbmxpbmVPYmplY3RzPy5tYXAoKGlubGluZU9iamVjdCkgPT4gZGVmaW5lVHlwZSh7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBuYW1lOiBpbmxpbmVPYmplY3QubmFtZSxcbiAgICB0aXRsZTogaW5saW5lT2JqZWN0LnRpdGxlLFxuICAgIGZpZWxkczogW11cbiAgfSkpID8/IFtdLCBwb3J0YWJsZVRleHRTY2hlbWEgPSBkZWZpbmVGaWVsZCh7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG5hbWU6IFwicG9ydGFibGUtdGV4dFwiLFxuICAgIG9mOiBbLi4uYmxvY2tPYmplY3RzLm1hcCgoYmxvY2tPYmplY3QpID0+ICh7XG4gICAgICB0eXBlOiBibG9ja09iamVjdC5uYW1lXG4gICAgfSkpLCB7XG4gICAgICB0eXBlOiBcImJsb2NrXCIsXG4gICAgICBuYW1lOiBcImJsb2NrXCIsXG4gICAgICBvZjogaW5saW5lT2JqZWN0cy5tYXAoKGlubGluZU9iamVjdCkgPT4gKHtcbiAgICAgICAgdHlwZTogaW5saW5lT2JqZWN0Lm5hbWVcbiAgICAgIH0pKSxcbiAgICAgIG1hcmtzOiB7XG4gICAgICAgIGRlY29yYXRvcnM6IGRlZmluaXRpb24/LmRlY29yYXRvcnM/Lm1hcCgoZGVjb3JhdG9yKSA9PiAoe1xuICAgICAgICAgIHRpdGxlOiBkZWNvcmF0b3IudGl0bGUgPz8gc3RhcnRDYXNlKGRlY29yYXRvci5uYW1lKSxcbiAgICAgICAgICB2YWx1ZTogZGVjb3JhdG9yLm5hbWVcbiAgICAgICAgfSkpID8/IFtdLFxuICAgICAgICBhbm5vdGF0aW9uczogZGVmaW5pdGlvbj8uYW5ub3RhdGlvbnM/Lm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICAgICAgICBuYW1lOiBhbm5vdGF0aW9uLm5hbWUsXG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICB0aXRsZTogYW5ub3RhdGlvbi50aXRsZVxuICAgICAgICB9KSkgPz8gW11cbiAgICAgIH0sXG4gICAgICBsaXN0czogZGVmaW5pdGlvbj8ubGlzdHM/Lm1hcCgobGlzdCkgPT4gKHtcbiAgICAgICAgdmFsdWU6IGxpc3QubmFtZSxcbiAgICAgICAgdGl0bGU6IGxpc3QudGl0bGUgPz8gc3RhcnRDYXNlKGxpc3QubmFtZSlcbiAgICAgIH0pKSA/PyBbXSxcbiAgICAgIHN0eWxlczogZGVmaW5pdGlvbj8uc3R5bGVzPy5tYXAoKHN0eWxlKSA9PiAoe1xuICAgICAgICB2YWx1ZTogc3R5bGUubmFtZSxcbiAgICAgICAgdGl0bGU6IHN0eWxlLnRpdGxlID8/IHN0YXJ0Q2FzZShzdHlsZS5uYW1lKVxuICAgICAgfSkpID8/IFtdXG4gICAgfV1cbiAgfSksIHNjaGVtYSA9IFNjaGVtYS5jb21waWxlKHtcbiAgICB0eXBlczogW3BvcnRhYmxlVGV4dFNjaGVtYSwgLi4uYmxvY2tPYmplY3RzLCAuLi5pbmxpbmVPYmplY3RzXVxuICB9KS5nZXQoXCJwb3J0YWJsZS10ZXh0XCIpLCBwdGVTY2hlbWEgPSBjcmVhdGVFZGl0b3JTY2hlbWEoc2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5wdGVTY2hlbWEsXG4gICAgYmxvY2tPYmplY3RzOiBwdGVTY2hlbWEuYmxvY2tPYmplY3RzLm1hcCgoYmxvY2tPYmplY3QpID0+IGJsb2NrT2JqZWN0Lm5hbWUgPT09IFwidG1wLWltYWdlXCIgPyB7XG4gICAgICAuLi5ibG9ja09iamVjdCxcbiAgICAgIG5hbWU6IFwiaW1hZ2VcIixcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgLi4uYmxvY2tPYmplY3QudHlwZSxcbiAgICAgICAgbmFtZTogXCJpbWFnZVwiXG4gICAgICB9XG4gICAgfSA6IGJsb2NrT2JqZWN0KVxuICB9O1xufVxuY29uc3Qgcm9vdE5hbWUgPSBcInNhbml0eS1wdGU6XCI7XG5kZWJ1ZyRrKHJvb3ROYW1lKTtcbmZ1bmN0aW9uIGRlYnVnV2l0aE5hbWUobmFtZSkge1xuICBjb25zdCBuYW1lc3BhY2UgPSBgJHtyb290TmFtZX0ke25hbWV9YDtcbiAgcmV0dXJuIGRlYnVnJGsgJiYgZGVidWckay5lbmFibGVkKG5hbWVzcGFjZSkgPyBkZWJ1ZyRrKG5hbWVzcGFjZSkgOiBkZWJ1ZyRrKHJvb3ROYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleWVkUGF0aChwb2ludCwgdmFsdWUsIHR5cGVzKSB7XG4gIGNvbnN0IGJsb2NrUGF0aCA9IFtwb2ludC5wYXRoWzBdXTtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgYmxvY2sgPSB2YWx1ZVtibG9ja1BhdGhbMF1dO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBrZXllZEJsb2NrUGF0aCA9IFt7XG4gICAgX2tleTogYmxvY2suX2tleVxuICB9XTtcbiAgaWYgKGJsb2NrLl90eXBlICE9PSB0eXBlcy5ibG9jay5uYW1lKVxuICAgIHJldHVybiBrZXllZEJsb2NrUGF0aDtcbiAgbGV0IGtleWVkQ2hpbGRQYXRoO1xuICBjb25zdCBjaGlsZFBhdGggPSBwb2ludC5wYXRoLnNsaWNlKDAsIDIpLCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuW2NoaWxkUGF0aFsxXV07XG4gIHJldHVybiBjaGlsZCAmJiAoa2V5ZWRDaGlsZFBhdGggPSBbXCJjaGlsZHJlblwiLCB7XG4gICAgX2tleTogY2hpbGQuX2tleVxuICB9XSksIGtleWVkQ2hpbGRQYXRoID8gWy4uLmtleWVkQmxvY2tQYXRoLCAuLi5rZXllZENoaWxkUGF0aF0gOiBrZXllZEJsb2NrUGF0aDtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVQYXRoKHBhdGgsIGVkaXRvcikge1xuICBpZiAoIWVkaXRvcilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBbXSxcbiAgICBtYXRjaDogKG4pID0+IGlzS2V5U2VnbWVudChwYXRoWzBdKSAmJiBuLl9rZXkgPT09IHBhdGhbMF0uX2tleVxuICB9KSlbMF0gfHwgW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFibG9jayB8fCAhRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZWRpdG9yLmlzVm9pZChibG9jaykpXG4gICAgcmV0dXJuIFtibG9ja1BhdGhbMF0sIDBdO1xuICBjb25zdCBjaGlsZFBhdGggPSBbcGF0aFsyXV0sIGNoaWxkSW5kZXggPSBibG9jay5jaGlsZHJlbi5maW5kSW5kZXgoKGNoaWxkKSA9PiBpc0VxdWFsKFt7XG4gICAgX2tleTogY2hpbGQuX2tleVxuICB9XSwgY2hpbGRQYXRoKSk7XG4gIGlmIChjaGlsZEluZGV4ID49IDAgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF0pIHtcbiAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2NoaWxkSW5kZXhdO1xuICAgIHJldHVybiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkKSAmJiBlZGl0b3IuaXNWb2lkKGNoaWxkKSA/IGJsb2NrUGF0aC5jb25jYXQoY2hpbGRJbmRleCkuY29uY2F0KDApIDogYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KTtcbiAgfVxuICByZXR1cm4gW2Jsb2NrUGF0aFswXSwgMF07XG59XG5mdW5jdGlvbiB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCByYW5nZSwgdHlwZXMpIHtcbiAgaWYgKCFyYW5nZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGFuY2hvciA9IG51bGwsIGZvY3VzID0gbnVsbDtcbiAgY29uc3QgYW5jaG9yUGF0aCA9IHJhbmdlLmFuY2hvciAmJiBjcmVhdGVLZXllZFBhdGgocmFuZ2UuYW5jaG9yLCB2YWx1ZSwgdHlwZXMpO1xuICBhbmNob3JQYXRoICYmIHJhbmdlLmFuY2hvciAmJiAoYW5jaG9yID0ge1xuICAgIHBhdGg6IGFuY2hvclBhdGgsXG4gICAgb2Zmc2V0OiByYW5nZS5hbmNob3Iub2Zmc2V0XG4gIH0pO1xuICBjb25zdCBmb2N1c1BhdGggPSByYW5nZS5mb2N1cyAmJiBjcmVhdGVLZXllZFBhdGgocmFuZ2UuZm9jdXMsIHZhbHVlLCB0eXBlcyk7XG4gIGZvY3VzUGF0aCAmJiByYW5nZS5mb2N1cyAmJiAoZm9jdXMgPSB7XG4gICAgcGF0aDogZm9jdXNQYXRoLFxuICAgIG9mZnNldDogcmFuZ2UuZm9jdXMub2Zmc2V0XG4gIH0pO1xuICBjb25zdCBiYWNrd2FyZCA9ICEhKFJhbmdlLmlzUmFuZ2UocmFuZ2UpICYmIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpKTtcbiAgcmV0dXJuIGFuY2hvciAmJiBmb2N1cyA/IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXMsXG4gICAgYmFja3dhcmRcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIWVkaXRvcilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgYW5jaG9yID0ge1xuICAgIHBhdGg6IHRvU2xhdGVQYXRoKHNlbGVjdGlvbi5hbmNob3IucGF0aCwgZWRpdG9yKSxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0XG4gIH0sIGZvY3VzID0ge1xuICAgIHBhdGg6IHRvU2xhdGVQYXRoKHNlbGVjdGlvbi5mb2N1cy5wYXRoLCBlZGl0b3IpLFxuICAgIG9mZnNldDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldFxuICB9O1xuICByZXR1cm4gZm9jdXMucGF0aC5sZW5ndGggPT09IDAgfHwgYW5jaG9yLnBhdGgubGVuZ3RoID09PSAwID8gbnVsbCA6IGZvY3VzID8ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHJhbmdlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmFuY2hvciwgb3BlcmF0aW9uKSwgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuZm9jdXMsIG9wZXJhdGlvbik7XG4gIHJldHVybiBhbmNob3IgPT09IG51bGwgfHwgZm9jdXMgPT09IG51bGwgPyBudWxsIDogUG9pbnQuZXF1YWxzKGFuY2hvciwgcmFuZ2UuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMoZm9jdXMsIHJhbmdlLmZvY3VzKSA/IHJhbmdlIDoge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHtcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfSksIG5ld09mZnNldCA9IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggPj0gcG9pbnQub2Zmc2V0ID8gcG9pbnQub2Zmc2V0IDogY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCB8fCAwO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG5ld0FuY2hvciA9IG51bGwsIG5ld0ZvY3VzID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgX2tleTogYmxrLl9rZXlcbiAgfSwgYW5jaG9yLnBhdGhbMF0pKSAmJiAobmV3QW5jaG9yID0gbm9ybWFsaXplUG9pbnQoYW5jaG9yLCB2YWx1ZSkpLCBmb2N1cyAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGZvY3VzLnBhdGhbMF0pKSAmJiAobmV3Rm9jdXMgPSBub3JtYWxpemVQb2ludChmb2N1cywgdmFsdWUpKSwgbmV3QW5jaG9yICYmIG5ld0ZvY3VzID8ge1xuICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuY29uc3QgVk9JRF9DSElMRF9LRVkgPSBcInZvaWQtY2hpbGRcIjtcbmZ1bmN0aW9uIGtlZXBPYmplY3RFcXVhbGl0eShvYmplY3QsIGtleU1hcCkge1xuICBjb25zdCB2YWx1ZSA9IGtleU1hcFtvYmplY3QuX2tleV07XG4gIHJldHVybiB2YWx1ZSAmJiBpc0VxdWFsKG9iamVjdCwgdmFsdWUpID8gdmFsdWUgOiAoa2V5TWFwW29iamVjdC5fa2V5XSA9IG9iamVjdCwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICBzY2hlbWFUeXBlc1xufSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gYmxvY2ssIHZvaWRDaGlsZHJlbiA9IFt7XG4gICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWSxcbiAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBtYXJrczogW11cbiAgICB9XTtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGJsb2NrO1xuICAgICAgbGV0IGhhc0lubGluZXMgPSAhMTtcbiAgICAgIGNvbnN0IGhhc01pc3NpbmdTdHlsZSA9IHR5cGVvZiB0ZXh0QmxvY2suc3R5bGUgPiBcInVcIiwgaGFzTWlzc2luZ01hcmtEZWZzID0gdHlwZW9mIHRleHRCbG9jay5tYXJrRGVmcyA+IFwidVwiLCBoYXNNaXNzaW5nQ2hpbGRyZW4gPSB0eXBlb2YgdGV4dEJsb2NrLmNoaWxkcmVuID4gXCJ1XCIsIGNoaWxkcmVuID0gKHRleHRCbG9jay5jaGlsZHJlbiB8fCBbXSkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgLi4uY1Jlc3RcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gY1R5cGUgIT09IFwic3BhblwiID8gKGhhc0lubGluZXMgPSAhMCwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICBfdHlwZTogY1R5cGUsXG4gICAgICAgICAgX2tleTogY0tleSxcbiAgICAgICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgICAgIHZhbHVlOiBjUmVzdCxcbiAgICAgICAgICBfX2lubGluZTogITBcbiAgICAgICAgfSwga2V5TWFwKSkgOiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFoYXNNaXNzaW5nU3R5bGUgJiYgIWhhc01pc3NpbmdNYXJrRGVmcyAmJiAhaGFzTWlzc2luZ0NoaWxkcmVuICYmICFoYXNJbmxpbmVzICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spID8gYmxvY2sgOiAoaGFzTWlzc2luZ1N0eWxlICYmIChyZXN0LnN0eWxlID0gc2NoZW1hVHlwZXMuc3R5bGVzWzBdLnZhbHVlKSwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIF9rZXksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9LCBrZXlNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgdmFsdWU6IHJlc3RcbiAgICB9LCBrZXlNYXApO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZnJvbVNsYXRlVmFsdWUodmFsdWUsIHRleHRCbG9ja1R5cGUsIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlXG4gICAgfSA9IGJsb2NrO1xuICAgIGlmICghX2tleSB8fCAhX3R5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBibG9ja1wiKTtcbiAgICBpZiAoX3R5cGUgPT09IHRleHRCbG9ja1R5cGUgJiYgXCJjaGlsZHJlblwiIGluIGJsb2NrICYmIEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIF9rZXkpIHtcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBfY1R5cGVcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGNoaWxkICYmIF9jVHlwZSAhPT0gXCJzcGFuXCIpIHtcbiAgICAgICAgICBoYXNJbmxpbmVzID0gITA7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHQsXG4gICAgICAgICAgICBfX2lubGluZTogX2ksXG4gICAgICAgICAgICBjaGlsZHJlbjogX2MsXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIC4uLnYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHRcbiAgICAgICAgICB9LCBrZXlNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhc0lubGluZXMgPyBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIF9rZXksXG4gICAgICAgIF90eXBlXG4gICAgICB9LCBrZXlNYXApIDogYmxvY2s7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrVmFsdWUgPSBcInZhbHVlXCIgaW4gYmxvY2sgJiYgYmxvY2sudmFsdWU7XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGUsXG4gICAgICAuLi50eXBlb2YgYmxvY2tWYWx1ZSA9PSBcIm9iamVjdFwiID8gYmxvY2tWYWx1ZSA6IHt9XG4gICAgfSwga2V5TWFwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0VxdWFsVG9FbXB0eUVkaXRvcihjaGlsZHJlbiwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGNoaWxkcmVuID09PSB2b2lkIDAgfHwgY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSAmJiBcInN0eWxlXCIgaW4gY2hpbGRyZW5bMF0gJiYgY2hpbGRyZW5bMF0uc3R5bGUgPT09IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSAmJiAhKFwibGlzdEl0ZW1cIiBpbiBjaGlsZHJlblswXSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlblswXS5jaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgIWNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLm1hcmtzPy5qb2luKFwiXCIpICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5jb25zdCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19TTEFURV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19WQUxVRV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgRGVmYXVsdE9iamVjdCA9IChwcm9wcykgPT4ge1xuICBjb25zdCAkID0gYyg0KTtcbiAgbGV0IHQwO1xuICAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IHtcbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIlxuICB9LCAkWzBdID0gdDApIDogdDAgPSAkWzBdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzFdICE9PSBwcm9wcy52YWx1ZS5fa2V5IHx8ICRbMl0gIT09IHByb3BzLnZhbHVlLl90eXBlID8gKHQxID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBzdHlsZTogdDAsIGNoaWxkcmVuOiBbXG4gICAgXCJbXCIsXG4gICAgcHJvcHMudmFsdWUuX3R5cGUsXG4gICAgXCI6IFwiLFxuICAgIHByb3BzLnZhbHVlLl9rZXksXG4gICAgXCJdXCJcbiAgXSB9KSwgJFsxXSA9IHByb3BzLnZhbHVlLl9rZXksICRbMl0gPSBwcm9wcy52YWx1ZS5fdHlwZSwgJFszXSA9IHQxKSA6IHQxID0gJFszXSwgdDE7XG59O1xuRGVmYXVsdE9iamVjdC5kaXNwbGF5TmFtZSA9IFwiRGVmYXVsdE9iamVjdFwiO1xuY29uc3QgZGVidWckaiA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkRyYWdnYWJsZUJsb2NrXCIpLCBEcmFnZ2FibGVCbG9jayA9ICh0MCkgPT4ge1xuICBjb25zdCAkID0gYyg1MSksIHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50LFxuICAgIHJlYWRPbmx5LFxuICAgIGJsb2NrUmVmXG4gIH0gPSB0MCwgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgZHJhZ0dob3N0UmVmID0gdXNlUmVmKHZvaWQgMCksIFtpc0RyYWdPdmVyLCBzZXRJc0RyYWdPdmVyXSA9IHVzZVN0YXRlKCExKTtcbiAgbGV0IHQxLCB0MjtcbiAgJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IGVsZW1lbnQgPyAodDIgPSBFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCksICRbMF0gPSBlZGl0b3IsICRbMV0gPSBlbGVtZW50LCAkWzJdID0gdDIpIDogdDIgPSAkWzJdLCB0MSA9IHQyO1xuICBjb25zdCBpc1ZvaWQgPSB0MTtcbiAgbGV0IHQzLCB0NDtcbiAgJFszXSAhPT0gZWRpdG9yIHx8ICRbNF0gIT09IGVsZW1lbnQgPyAodDQgPSBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBlbGVtZW50KSwgJFszXSA9IGVkaXRvciwgJFs0XSA9IGVsZW1lbnQsICRbNV0gPSB0NCkgOiB0NCA9ICRbNV0sIHQzID0gdDQ7XG4gIGNvbnN0IGlzSW5saW5lID0gdDMsIFtibG9ja0VsZW1lbnQsIHNldEJsb2NrRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgbGV0IHQ1LCB0NjtcbiAgJFs2XSAhPT0gYmxvY2tSZWYgfHwgJFs3XSAhPT0gZWRpdG9yIHx8ICRbOF0gIT09IGVsZW1lbnQgPyAodDUgPSAoKSA9PiBzZXRCbG9ja0VsZW1lbnQoYmxvY2tSZWYgPyBibG9ja1JlZi5jdXJyZW50IDogUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWxlbWVudCkpLCB0NiA9IFtlZGl0b3IsIGVsZW1lbnQsIGJsb2NrUmVmXSwgJFs2XSA9IGJsb2NrUmVmLCAkWzddID0gZWRpdG9yLCAkWzhdID0gZWxlbWVudCwgJFs5XSA9IHQ1LCAkWzEwXSA9IHQ2KSA6ICh0NSA9ICRbOV0sIHQ2ID0gJFsxMF0pLCB1c2VFZmZlY3QodDUsIHQ2KTtcbiAgbGV0IHQ3O1xuICAkWzExXSAhPT0gYmxvY2tFbGVtZW50IHx8ICRbMTJdICE9PSBlZGl0b3IgfHwgJFsxM10gIT09IGVsZW1lbnQgPyAodDcgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc015RHJhZ092ZXIgPSBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIGlmICghaXNNeURyYWdPdmVyIHx8ICFibG9ja0VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKSwgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIiwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuc2V0KGVkaXRvciwgZWxlbWVudCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBibG9ja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG9mZnNldCA9IGVsZW1lbnRSZWN0LnRvcCwgaGVpZ2h0ID0gZWxlbWVudFJlY3QuaGVpZ2h0LCBZID0gZXZlbnQucGFnZVksIGxvYyA9IE1hdGguYWJzKG9mZnNldCAtIFkpO1xuICAgIGlmIChlbGVtZW50ID09PSBlZGl0b3IuY2hpbGRyZW5bMF0gfHwgKGxvYyA8IGhlaWdodCAvIDIgPyBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uc2V0KGVkaXRvciwgXCJ0b3BcIikgOiBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uc2V0KGVkaXRvciwgXCJib3R0b21cIikpLCBpc015RHJhZ092ZXIgPT09IGVsZW1lbnQpIHtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldElzRHJhZ092ZXIoITApO1xuICB9LCAkWzExXSA9IGJsb2NrRWxlbWVudCwgJFsxMl0gPSBlZGl0b3IsICRbMTNdID0gZWxlbWVudCwgJFsxNF0gPSB0NykgOiB0NyA9ICRbMTRdO1xuICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IHQ3O1xuICBsZXQgdDg7XG4gICRbMTVdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0OCA9ICgpID0+IHtcbiAgICBzZXRJc0RyYWdPdmVyKCExKTtcbiAgfSwgJFsxNV0gPSB0OCkgOiB0OCA9ICRbMTVdO1xuICBjb25zdCBoYW5kbGVEcmFnTGVhdmUgPSB0ODtcbiAgbGV0IHQ5O1xuICAkWzE2XSAhPT0gZWRpdG9yIHx8ICRbMTddICE9PSBlbGVtZW50ID8gKHQ5ID0gKGV2ZW50XzApID0+IHtcbiAgICBjb25zdCB0YXJnZXRCbG9jayA9IElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmdldChlZGl0b3IpO1xuICAgIGlmICh0YXJnZXRCbG9jaykge1xuICAgICAgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITEpLCBldmVudF8wLnByZXZlbnREZWZhdWx0KCksIGV2ZW50XzAuc3RvcFByb3BhZ2F0aW9uKCksIElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmRlbGV0ZShlZGl0b3IpLCBkcmFnR2hvc3RSZWYuY3VycmVudCAmJiAoZGVidWckaihcIlJlbW92aW5nIGRyYWcgZ2hvc3RcIiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZHJhZ0dob3N0UmVmLmN1cnJlbnQpKTtcbiAgICAgIGNvbnN0IGRyYWdQb3NpdGlvbiA9IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5nZXQoZWRpdG9yKTtcbiAgICAgIElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGxldCB0YXJnZXRQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0YXJnZXRCbG9jayk7XG4gICAgICBjb25zdCBteVBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpLCBpc0JlZm9yZSA9IFBhdGguaXNCZWZvcmUobXlQYXRoLCB0YXJnZXRQYXRoKTtcbiAgICAgIGlmIChkcmFnUG9zaXRpb24gPT09IFwiYm90dG9tXCIgJiYgIWlzQmVmb3JlKSB7XG4gICAgICAgIGlmICh0YXJnZXRQYXRoWzBdID49IGVkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgZGVidWckaihcInRhcmdldCBpcyBhbHJlYWR5IGF0IHRoZSBib3R0b20sIG5vdCBtb3ZpbmdcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IHRhcmdldFBhdGg7XG4gICAgICAgIHRhcmdldFBhdGggPSBQYXRoLm5leHQodGFyZ2V0UGF0aCksIGRlYnVnJGooYEFkanVzdGluZyB0YXJnZXRQYXRoIGZyb20gJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFBhdGgpfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfWApO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdQb3NpdGlvbiA9PT0gXCJ0b3BcIiAmJiBpc0JlZm9yZSAmJiB0YXJnZXRQYXRoWzBdICE9PSBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhfMCA9IHRhcmdldFBhdGg7XG4gICAgICAgIHRhcmdldFBhdGggPSBQYXRoLnByZXZpb3VzKHRhcmdldFBhdGgpLCBkZWJ1ZyRqKGBBZGp1c3RpbmcgdGFyZ2V0UGF0aCBmcm9tICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxQYXRoXzApfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfWApO1xuICAgICAgfVxuICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFBhdGgsIG15UGF0aCkpIHtcbiAgICAgICAgZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBkZWJ1ZyRqKFwidGFyZ2V0UGF0aCBhbmQgbXlQYXRoIGlzIHRoZSBzYW1lLCBub3QgbW92aW5nXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWJ1ZyRqKGBNb3ZpbmcgZWxlbWVudCAke2VsZW1lbnQuX2tleX0gZnJvbSBwYXRoICR7SlNPTi5zdHJpbmdpZnkobXlQYXRoKX0gdG8gJHtKU09OLnN0cmluZ2lmeSh0YXJnZXRQYXRoKX0gKCR7ZHJhZ1Bvc2l0aW9ufSlgKSwgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBteVBhdGgsXG4gICAgICAgIHRvOiB0YXJnZXRQYXRoXG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnJGooXCJObyB0YXJnZXQgZWxlbWVudCwgbm90IGRvaW5nIGFueXRoaW5nXCIpO1xuICB9LCAkWzE2XSA9IGVkaXRvciwgJFsxN10gPSBlbGVtZW50LCAkWzE4XSA9IHQ5KSA6IHQ5ID0gJFsxOF07XG4gIGNvbnN0IGhhbmRsZURyYWdFbmQgPSB0OTtcbiAgbGV0IHQxMDtcbiAgJFsxOV0gIT09IGVkaXRvciB8fCAkWzIwXSAhPT0gZWxlbWVudCA/ICh0MTAgPSAoZXZlbnRfMSkgPT4ge1xuICAgIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZ2V0KGVkaXRvcikgJiYgKGRlYnVnJGooXCJPbiBkcm9wIChwcmV2ZW50ZWQpXCIsIGVsZW1lbnQpLCBldmVudF8xLnByZXZlbnREZWZhdWx0KCksIGV2ZW50XzEuc3RvcFByb3BhZ2F0aW9uKCksIHNldElzRHJhZ092ZXIoITEpKTtcbiAgfSwgJFsxOV0gPSBlZGl0b3IsICRbMjBdID0gZWxlbWVudCwgJFsyMV0gPSB0MTApIDogdDEwID0gJFsyMV07XG4gIGNvbnN0IGhhbmRsZURyb3AgPSB0MTA7XG4gIGxldCB0MTE7XG4gICRbMjJdICE9PSBlZGl0b3IgfHwgJFsyM10gIT09IGVsZW1lbnQgfHwgJFsyNF0gIT09IGlzVm9pZCA/ICh0MTEgPSAoZXZlbnRfMikgPT4ge1xuICAgIGlmICghaXNWb2lkKSB7XG4gICAgICBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuc2V0KGVkaXRvciwgZWxlbWVudCksIGV2ZW50XzIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRfMi50YXJnZXQ7XG4gICAgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIxXCIpO1xuICB9LCAkWzIyXSA9IGVkaXRvciwgJFsyM10gPSBlbGVtZW50LCAkWzI0XSA9IGlzVm9pZCwgJFsyNV0gPSB0MTEpIDogdDExID0gJFsyNV07XG4gIGNvbnN0IGhhbmRsZURyYWcgPSB0MTE7XG4gIGxldCB0MTI7XG4gICRbMjZdICE9PSBibG9ja0VsZW1lbnQgfHwgJFsyN10gIT09IGVkaXRvciB8fCAkWzI4XSAhPT0gaGFuZGxlRHJhZyB8fCAkWzI5XSAhPT0gaXNJbmxpbmUgfHwgJFszMF0gIT09IGlzVm9pZCA/ICh0MTIgPSAoZXZlbnRfMykgPT4ge1xuICAgIGlmICghaXNWb2lkIHx8IGlzSW5saW5lKSB7XG4gICAgICBkZWJ1ZyRqKFwiTm90IGRyYWdnaW5nIGJsb2NrXCIpLCBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpLCBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWJ1ZyRqKFwiRHJhZyBzdGFydFwiKSwgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITApLCBldmVudF8zLmRhdGFUcmFuc2ZlciAmJiAoZXZlbnRfMy5kYXRhVHJhbnNmZXIuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BvcnRhYmxlLXRleHRcIiwgXCJzb21ldGhpbmdcIiksIGV2ZW50XzMuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIiksIGJsb2NrRWxlbWVudCAmJiBibG9ja0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbGV0IGRyYWdHaG9zdCA9IGJsb2NrRWxlbWVudC5jbG9uZU5vZGUoITApO1xuICAgICAgY29uc3QgY3VzdG9tR2hvc3QgPSBkcmFnR2hvc3QucXVlcnlTZWxlY3RvcihcIltkYXRhLXB0LWRyYWctZ2hvc3QtZWxlbWVudF1cIik7XG4gICAgICBpZiAoY3VzdG9tR2hvc3QgJiYgKGRyYWdHaG9zdCA9IGN1c3RvbUdob3N0KSwgZHJhZ0dob3N0LnNldEF0dHJpYnV0ZShcImRhdGEtZHJhZ2dlZFwiLCBcIlwiKSwgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBkcmFnR2hvc3RSZWYuY3VycmVudCA9IGRyYWdHaG9zdCwgZHJhZ0dob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBkcmFnR2hvc3Quc3R5bGUubGVmdCA9IFwiLTk5OTk5cHhcIiwgZHJhZ0dob3N0LnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdHaG9zdCk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBibG9ja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSBldmVudF8zLmNsaWVudFggLSByZWN0LmxlZnQsIHkgPSBldmVudF8zLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgZHJhZ0dob3N0LnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGAsIGV2ZW50XzMuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnR2hvc3QsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEcmFnKGV2ZW50XzMpO1xuICB9LCAkWzI2XSA9IGJsb2NrRWxlbWVudCwgJFsyN10gPSBlZGl0b3IsICRbMjhdID0gaGFuZGxlRHJhZywgJFsyOV0gPSBpc0lubGluZSwgJFszMF0gPSBpc1ZvaWQsICRbMzFdID0gdDEyKSA6IHQxMiA9ICRbMzFdO1xuICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSB0MTI7XG4gIGxldCB0MTM7XG4gICRbMzJdICE9PSBlZGl0b3IgfHwgJFszM10gIT09IGlzRHJhZ092ZXIgPyAodDEzID0gaXNEcmFnT3ZlciAmJiBlZGl0b3IuY2hpbGRyZW5bMF0gPT09IElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmdldChlZGl0b3IpLCAkWzMyXSA9IGVkaXRvciwgJFszM10gPSBpc0RyYWdPdmVyLCAkWzM0XSA9IHQxMykgOiB0MTMgPSAkWzM0XTtcbiAgY29uc3QgaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrID0gdDEzO1xuICBsZXQgdDE0O1xuICAkWzM1XSAhPT0gZWRpdG9yIHx8ICRbMzZdICE9PSBpc0RyYWdPdmVyID8gKHQxNCA9IGlzRHJhZ092ZXIgJiYgZWRpdG9yLmNoaWxkcmVuW2VkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvciksICRbMzVdID0gZWRpdG9yLCAkWzM2XSA9IGlzRHJhZ092ZXIsICRbMzddID0gdDE0KSA6IHQxNCA9ICRbMzddO1xuICBjb25zdCBpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayA9IHQxNCwgZHJhZ1Bvc2l0aW9uXzAgPSBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uZ2V0KGVkaXRvciksIGlzRHJhZ2dpbmdPdmVyVG9wID0gaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrIHx8IGlzRHJhZ092ZXIgJiYgIWlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayAmJiAhaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgJiYgZHJhZ1Bvc2l0aW9uXzAgPT09IFwidG9wXCIsIGlzRHJhZ2dpbmdPdmVyQm90dG9tID0gaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgfHwgaXNEcmFnT3ZlciAmJiAhaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrICYmICFpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayAmJiBkcmFnUG9zaXRpb25fMCA9PT0gXCJib3R0b21cIjtcbiAgbGV0IHQxNSwgdDE2O1xuICAkWzM4XSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDE2ID0gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJwdC1kcm9wLWluZGljYXRvclwiLCBzdHlsZToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogMSxcbiAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIGN1cnJlbnRDb2xvclwiLFxuICAgIHpJbmRleDogNVxuICB9IH0pLCAkWzM4XSA9IHQxNikgOiB0MTYgPSAkWzM4XSwgdDE1ID0gdDE2O1xuICBjb25zdCBkcm9wSW5kaWNhdG9yID0gdDE1O1xuICBpZiAocmVhZE9ubHkpIHtcbiAgICBsZXQgdDE3MjtcbiAgICByZXR1cm4gJFszOV0gIT09IGNoaWxkcmVuID8gKHQxNzIgPSAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuIH0pLCAkWzM5XSA9IGNoaWxkcmVuLCAkWzQwXSA9IHQxNzIpIDogdDE3MiA9ICRbNDBdLCB0MTcyO1xuICB9XG4gIGNvbnN0IHQxNyA9IGlzRHJhZ2dpbmdPdmVyVG9wICYmIGRyb3BJbmRpY2F0b3IsIHQxOCA9IGlzRHJhZ2dpbmdPdmVyQm90dG9tICYmIGRyb3BJbmRpY2F0b3I7XG4gIGxldCB0MTk7XG4gIHJldHVybiAkWzQxXSAhPT0gY2hpbGRyZW4gfHwgJFs0Ml0gIT09IGhhbmRsZURyYWcgfHwgJFs0M10gIT09IGhhbmRsZURyYWdFbmQgfHwgJFs0NF0gIT09IGhhbmRsZURyYWdPdmVyIHx8ICRbNDVdICE9PSBoYW5kbGVEcmFnU3RhcnQgfHwgJFs0Nl0gIT09IGhhbmRsZURyb3AgfHwgJFs0N10gIT09IGlzVm9pZCB8fCAkWzQ4XSAhPT0gdDE3IHx8ICRbNDldICE9PSB0MTggPyAodDE5ID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBkcmFnZ2FibGU6IGlzVm9pZCwgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCwgb25EcmFnOiBoYW5kbGVEcmFnLCBvbkRyYWdPdmVyOiBoYW5kbGVEcmFnT3Zlciwgb25EcmFnTGVhdmU6IGhhbmRsZURyYWdMZWF2ZSwgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCBvbkRyb3A6IGhhbmRsZURyb3AsIGNoaWxkcmVuOiBbXG4gICAgdDE3LFxuICAgIGNoaWxkcmVuLFxuICAgIHQxOFxuICBdIH0pLCAkWzQxXSA9IGNoaWxkcmVuLCAkWzQyXSA9IGhhbmRsZURyYWcsICRbNDNdID0gaGFuZGxlRHJhZ0VuZCwgJFs0NF0gPSBoYW5kbGVEcmFnT3ZlciwgJFs0NV0gPSBoYW5kbGVEcmFnU3RhcnQsICRbNDZdID0gaGFuZGxlRHJvcCwgJFs0N10gPSBpc1ZvaWQsICRbNDhdID0gdDE3LCAkWzQ5XSA9IHQxOCwgJFs1MF0gPSB0MTkpIDogdDE5ID0gJFs1MF0sIHQxOTtcbn07XG5EcmFnZ2FibGVCbG9jay5kaXNwbGF5TmFtZSA9IFwiRHJhZ2dhYmxlQmxvY2tcIjtcbmRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkVsZW1lbnRcIik7XG5jb25zdCBFTVBUWV9BTk5PVEFUSU9OUyA9IFtdLCBpbmxpbmVCbG9ja1N0eWxlID0ge1xuICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG59LCBFbGVtZW50ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG4gIGVsZW1lbnQsXG4gIHNjaGVtYVR5cGVzLFxuICByZWFkT25seSxcbiAgcmVuZGVyQmxvY2ssXG4gIHJlbmRlckNoaWxkLFxuICByZW5kZXJMaXN0SXRlbSxcbiAgcmVuZGVyU3R5bGUsXG4gIHNwZWxsQ2hlY2tcbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBibG9ja1JlZiA9IHVzZVJlZihudWxsKSwgaW5saW5lQmxvY2tPYmplY3RSZWYgPSB1c2VSZWYobnVsbCksIGZvY3VzZWQgPSBzZWxlY3RlZCAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pIHx8ICExLCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0sIFtlZGl0b3IsIGVsZW1lbnQsIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWVdKTtcbiAgbGV0IHJlbmRlcmVkQmxvY2sgPSBjaGlsZHJlbiwgY2xhc3NOYW1lO1xuICBjb25zdCBibG9ja1BhdGggPSB1c2VNZW1vKCgpID0+IFt7XG4gICAgX2tleTogZWxlbWVudC5fa2V5XG4gIH1dLCBbZWxlbWVudF0pO1xuICBpZiAodHlwZW9mIGVsZW1lbnQuX3R5cGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGhhdmUgYSBfdHlwZSBwcm9wZXJ0eVwiKTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Ll9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGhhdmUgYSBfa2V5IHByb3BlcnR5XCIpO1xuICBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgY29uc3QgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgIGRlcHRoOiAxXG4gICAgfSksIHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKF90eXBlKSA9PiBfdHlwZS5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0eXBlIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudFwiKTtcbiAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykpIHtcbiAgICAgIGNvbnN0IGVsbVBhdGggPSBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogZWxlbWVudC5fa2V5XG4gICAgICB9XTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyAuLi5hdHRyaWJ1dGVzLCBjaGlsZHJlbjogW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgZHJhZ2dhYmxlOiAhcmVhZE9ubHksIGNsYXNzTmFtZTogXCJwdC1pbmxpbmUtb2JqZWN0XCIsIFwiZGF0YS10ZXN0aWRcIjogXCJwdC1pbmxpbmUtb2JqZWN0XCIsIHJlZjogaW5saW5lQmxvY2tPYmplY3RSZWYsIHN0eWxlOiBpbmxpbmVCbG9ja1N0eWxlLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogW1xuICAgICAgICAgIHJlbmRlckNoaWxkICYmIHJlbmRlckNoaWxkKHtcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBFTVBUWV9BTk5PVEFUSU9OUyxcbiAgICAgICAgICAgIC8vIFRoZXNlIGlubGluZSBvYmplY3RzIGN1cnJlbnRseSBkb2Vzbid0IHN1cHBvcnQgYW5ub3RhdGlvbnMuIFRoaXMgaXMgYSBsaW1pdGF0aW9uIG9mIHRoZSBjdXJyZW50IFBUIHNwZWMvbW9kZWwuXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pLFxuICAgICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogaW5saW5lQmxvY2tPYmplY3RSZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aDogZWxtUGF0aCxcbiAgICAgICAgICAgIHNjaGVtYVR5cGUsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHR5cGU6IHNjaGVtYVR5cGUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgICFyZW5kZXJDaGlsZCAmJiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSlcbiAgICAgICAgXSB9LCBlbGVtZW50Ll9rZXkpXG4gICAgICBdIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmQhXCIpO1xuICB9XG4gIGlmIChlbGVtZW50Ll90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgY2xhc3NOYW1lID0gXCJwdC1ibG9jayBwdC10ZXh0LWJsb2NrXCI7XG4gICAgY29uc3QgaXNMaXN0SXRlbSA9IFwibGlzdEl0ZW1cIiBpbiBlbGVtZW50LCBzdHlsZSA9IFwic3R5bGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQuc3R5bGUgfHwgXCJub3JtYWxcIjtcbiAgICBjbGFzc05hbWUgPSBgcHQtYmxvY2sgcHQtdGV4dC1ibG9jayBwdC10ZXh0LWJsb2NrLXN0eWxlLSR7c3R5bGV9YDtcbiAgICBjb25zdCBibG9ja1N0eWxlVHlwZSA9IHNjaGVtYVR5cGVzLnN0eWxlcy5maW5kKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSBzdHlsZSk7XG4gICAgcmVuZGVyU3R5bGUgJiYgYmxvY2tTdHlsZVR5cGUgJiYgKHJlbmRlcmVkQmxvY2sgPSByZW5kZXJTdHlsZSh7XG4gICAgICBibG9jazogZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgc2NoZW1hVHlwZTogYmxvY2tTdHlsZVR5cGUsXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZlxuICAgIH0pKTtcbiAgICBsZXQgbGV2ZWw7XG4gICAgaWYgKGlzTGlzdEl0ZW0gJiYgKHR5cGVvZiBlbGVtZW50LmxldmVsID09IFwibnVtYmVyXCIgJiYgKGxldmVsID0gZWxlbWVudC5sZXZlbCksIGNsYXNzTmFtZSArPSBgIHB0LWxpc3QtaXRlbSBwdC1saXN0LWl0ZW0tJHtlbGVtZW50Lmxpc3RJdGVtfSBwdC1saXN0LWl0ZW0tbGV2ZWwtJHtsZXZlbCB8fCAxfWApLCBlZGl0b3IuaXNMaXN0QmxvY2sodmFsdWUpICYmIGlzTGlzdEl0ZW0gJiYgZWxlbWVudC5saXN0SXRlbSkge1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBzY2hlbWFUeXBlcy5saXN0cy5maW5kKChpdGVtXzApID0+IGl0ZW1fMC52YWx1ZSA9PT0gZWxlbWVudC5saXN0SXRlbSk7XG4gICAgICByZW5kZXJMaXN0SXRlbSAmJiBsaXN0VHlwZSAmJiAocmVuZGVyZWRCbG9jayA9IHJlbmRlckxpc3RJdGVtKHtcbiAgICAgICAgYmxvY2s6IHZhbHVlLFxuICAgICAgICBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayxcbiAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHZhbHVlOiBlbGVtZW50Lmxpc3RJdGVtLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICAgIHNjaGVtYVR5cGU6IGxpc3RUeXBlLFxuICAgICAgICBsZXZlbDogdmFsdWUubGV2ZWwgfHwgMSxcbiAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWZcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2ssXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBsZXZlbCxcbiAgICAgIGxpc3RJdGVtOiBpc0xpc3RJdGVtID8gZWxlbWVudC5saXN0SXRlbSA6IHZvaWQgMCxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgc3R5bGUsXG4gICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlcy5ibG9jayxcbiAgICAgIHZhbHVlXG4gICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVzLmJsb2NrO1xuICAgICAgfVxuICAgIH0pLCBwcm9wc09yRGVmYXVsdFJlbmRlcmVkID0gcmVuZGVyQmxvY2sgPyByZW5kZXJCbG9jayhyZW5kZXJQcm9wcykgOiBjaGlsZHJlbjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgc3BlbGxDaGVjaywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRHJhZ2dhYmxlQmxvY2ssIHsgZWxlbWVudCwgcmVhZE9ubHksIGJsb2NrUmVmLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogYmxvY2tSZWYsIGNoaWxkcmVuOiBwcm9wc09yRGVmYXVsdFJlbmRlcmVkIH0pIH0pIH0sIGVsZW1lbnQuX2tleSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZV8wID0gc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLmZpbmQoKF90eXBlXzApID0+IF90eXBlXzAubmFtZSA9PT0gZWxlbWVudC5fdHlwZSk7XG4gIGlmICghc2NoZW1hVHlwZV8wKVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc2NoZW1hIHR5cGUgZm9yIGJsb2NrIGVsZW1lbnQgb2YgX3R5cGUgJHtlbGVtZW50Ll90eXBlfWApO1xuICBjbGFzc05hbWUgPSBcInB0LWJsb2NrIHB0LW9iamVjdC1ibG9ja1wiO1xuICBjb25zdCBibG9ja18wID0gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gIGxldCByZW5kZXJlZEJsb2NrRnJvbVByb3BzO1xuICBpZiAocmVuZGVyQmxvY2spIHtcbiAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdE9iamVjdCwgeyB2YWx1ZSB9KSxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVfMCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgdmFsdWU6IGJsb2NrXzBcbiAgICB9LCBcInR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZV8wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgPSByZW5kZXJCbG9jayhfcHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgY2hpbGRyZW46IFtcbiAgICBjaGlsZHJlbixcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KERyYWdnYWJsZUJsb2NrLCB7IGVsZW1lbnQsIHJlYWRPbmx5LCBibG9ja1JlZiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IGJsb2NrUmVmLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyB8fCAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSkgfSkgfSlcbiAgXSB9LCBlbGVtZW50Ll9rZXkpO1xufTtcbkVsZW1lbnQuZGlzcGxheU5hbWUgPSBcIkVsZW1lbnRcIjtcbmNvbnN0IFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpLCB1c2VQb3J0YWJsZVRleHRFZGl0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZUNvbnRleHQoUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufTtcbmZ1bmN0aW9uIERlZmF1bHRBbm5vdGF0aW9uKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDYpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzLmFubm90YXRpb24gPyAodDAgPSAoKSA9PiBhbGVydChKU09OLnN0cmluZ2lmeShwcm9wcy5hbm5vdGF0aW9uKSksICRbMF0gPSBwcm9wcy5hbm5vdGF0aW9uLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBoYW5kbGVDbGljayA9IHQwO1xuICBsZXQgdDE7XG4gICRbMl0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQxID0ge1xuICAgIGNvbG9yOiBcImJsdWVcIlxuICB9LCAkWzJdID0gdDEpIDogdDEgPSAkWzJdO1xuICBsZXQgdDI7XG4gIHJldHVybiAkWzNdICE9PSBoYW5kbGVDbGljayB8fCAkWzRdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IHQxLCBvbkNsaWNrOiBoYW5kbGVDbGljaywgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzNdID0gaGFuZGxlQ2xpY2ssICRbNF0gPSBwcm9wcy5jaGlsZHJlbiwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XSwgdDI7XG59XG5EZWZhdWx0QW5ub3RhdGlvbi5kaXNwbGF5TmFtZSA9IFwiRGVmYXVsdEFubm90YXRpb25cIjtcbmZ1bmN0aW9uIGNvbXBpbGVUeXBlKHJhd1R5cGUpIHtcbiAgcmV0dXJuIFNjaGVtYS5jb21waWxlKHtcbiAgICBuYW1lOiBcImJsb2NrVHlwZVNjaGVtYVwiLFxuICAgIHR5cGVzOiBbcmF3VHlwZV1cbiAgfSkuZ2V0KHJhd1R5cGUubmFtZSk7XG59XG5jb25zdCBGTFVTSF9QQVRDSEVTX1RIUk9UVExFRF9NUyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IDUwMCA6IDFlMywgbXV0YXRpb25NYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGV2ZW50czoge30sXG4gICAgaW5wdXQ6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImVtaXQgaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXG4gICAgfSksXG4gICAgXCJlbWl0IG11dGF0aW9uXCI6IGVtaXQoKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiAoe1xuICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgcGF0Y2hlczogY29udGV4dC5wZW5kaW5nUGF0Y2hlcyxcbiAgICAgIHNuYXBzaG90OiBmcm9tU2xhdGVWYWx1ZShjb250ZXh0LnNsYXRlRWRpdG9yLmNoaWxkcmVuLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoY29udGV4dC5zbGF0ZUVkaXRvcikpXG4gICAgfSkpLFxuICAgIFwiY2xlYXIgcGVuZGluZyBwYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUGF0Y2hlczogW11cbiAgICB9KSxcbiAgICBcImRlZmVyIHBhdGNoXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUGF0Y2hlczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IFsuLi5jb250ZXh0LnBlbmRpbmdQYXRjaGVzLCBldmVudC5wYXRjaF1cbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gRWRpdG9yLmlzTm9ybWFsaXppbmcoY29udGV4dC5zbGF0ZUVkaXRvcilcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcIm11dGF0aW9uXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBwZW5kaW5nUGF0Y2hlczogW10sXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2xhdGVFZGl0b3I6IGlucHV0LnNsYXRlRWRpdG9yXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgc3RhdGVzOiB7XG4gICAgaWRsZToge1xuICAgICAgb246IHtcbiAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiLCBcImVtaXQgaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXSxcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiB7XG4gICAgICBhZnRlcjoge1xuICAgICAgICBbRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVNdOiBbe1xuICAgICAgICAgIGd1YXJkOiBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCIsXG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJlbWl0IG11dGF0aW9uXCIsIFwiY2xlYXIgcGVuZGluZyBwYXRjaGVzXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgYWN0aW9uczogW1wiZGVmZXIgcGF0Y2hcIl0sXG4gICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlLCB0eXBlcywga2V5R2VuZXJhdG9yKSB7XG4gIGxldCByZXNvbHV0aW9uID0gbnVsbCwgdmFsaWQgPSAhMDtcbiAgY29uc3QgdmFsaWRDaGlsZFR5cGVzID0gW3R5cGVzLnNwYW4ubmFtZSwgLi4udHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldLCB2YWxpZEJsb2NrVHlwZXMgPSBbdHlwZXMuYmxvY2submFtZSwgLi4udHlwZXMuYmxvY2tPYmplY3RzLm1hcCgodCkgPT4gdC5uYW1lKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgIHZhbGlkOiAhMCxcbiAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgIHZhbHVlXG4gIH0gOiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwID8ge1xuICAgIHZhbGlkOiAhMSxcbiAgICByZXNvbHV0aW9uOiB7XG4gICAgICBwYXRjaGVzOiBbdW5zZXQoW10pXSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkVkaXRvciB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIFBvcnRhYmxlIFRleHQgYmxvY2tzLCBvciB1bmRlZmluZWQuXCIsXG4gICAgICBhY3Rpb246IFwiVW5zZXQgdGhlIHZhbHVlXCIsXG4gICAgICBpdGVtOiB2YWx1ZSxcbiAgICAgIGkxOG46IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tYXJyYXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmFjdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZVxuICB9IDogKHZhbHVlLnNvbWUoKGJsaywgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYmxrKSlcbiAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW2luZGV4XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJHtTdHJpbmcoYmxrKX1gLFxuICAgICAgICBhY3Rpb246IFwiVW5zZXQgaW52YWxpZCBpdGVtXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLW9iamVjdC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBpbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITA7XG4gICAgaWYgKCFibGsuX2tleSB8fCB0eXBlb2YgYmxrLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfSwgW2luZGV4XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGF0IGluZGV4ICR7aW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleS5gLFxuICAgICAgICBhY3Rpb246IFwiU2V0IHRoZSBibG9jayB3aXRoIGEgcmFuZG9tIF9rZXkgdmFsdWVcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmcta2V5LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl90eXBlIHx8ICF2YWxpZEJsb2NrVHlwZXMuaW5jbHVkZXMoYmxrLl90eXBlKSkge1xuICAgICAgaWYgKGJsay5fdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja1R5cGVOYW1lID0gdHlwZXMuYmxvY2submFtZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgICBfdHlwZTogY3VycmVudEJsb2NrVHlwZU5hbWVcbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaGFzIGludmFsaWQgdHlwZSBuYW1lICcke2Jsay5fdHlwZX0nLiBBY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSwgdGhlIGJsb2NrIHR5cGUgbmFtZSBpcyAnJHtjdXJyZW50QmxvY2tUeXBlTmFtZX0nYCxcbiAgICAgICAgICBhY3Rpb246IGBVc2UgdHlwZSAnJHtjdXJyZW50QmxvY2tUeXBlTmFtZX0nYCxcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbmNvcnJlY3QtYmxvY2stdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlTmFtZTogY3VycmVudEJsb2NrVHlwZU5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFibGsuX3R5cGUgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soe1xuICAgICAgICAuLi5ibGssXG4gICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICB9KSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgfSwgW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWUuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IGJsay5fdHlwZSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIF90eXBlICcke2Jsay5fdHlwZX0nYCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgdHlwZU5hbWU6IGJsay5fdHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhbiBfdHlwZSBwcm9wZXJ0eWAsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApO1xuICAgIH1cbiAgICBpZiAoYmxrLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibGs7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuICYmICFBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFRleHQgYmxvY2sgd2l0aCBfa2V5ICcke3RleHRCbG9jay5fa2V5fScgaGFzIGEgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnY2hpbGRyZW4nLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlc2V0IHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVwiLFxuICAgICAgICAgIGl0ZW06IHRleHRCbG9jayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogdGV4dEJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkodGV4dEJsb2NrLmNoaWxkcmVuKSAmJiB0ZXh0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1NwYW4gPSB7XG4gICAgICAgICAgX3R5cGU6IHR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgcGF0Y2hlczogW3NldElmTWlzc2luZyhbXSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiXSksIGluc2VydChbbmV3U3Bhbl0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCAwXSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGRyZW4gZm9yIHRleHQgYmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgZW1wdHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiSW5zZXJ0IGFuIGVtcHR5IHRleHRcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxVc2VkTWFya3MgPSB1bmlxKGZsYXR0ZW4odGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSkubWFwKChjbGQpID0+IGNsZC5tYXJrcyB8fCBbXSkpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsay5tYXJrRGVmcykgJiYgYmxrLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW51c2VkTWFya0RlZnMgPSB1bmlxKGJsay5tYXJrRGVmcy5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmZpbHRlcigoa2V5KSA9PiAhYWxsVXNlZE1hcmtzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgaWYgKHVudXNlZE1hcmtEZWZzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiB1bnVzZWRNYXJrRGVmcy5tYXAoKG1hcmtEZWZLZXkpID0+IHVuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogbWFya0RlZktleVxuICAgICAgICAgICAgfV0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgY29udGFpbnMgb3JwaGFuZWQgZGF0YSAodW51c2VkIG1hcmsgZGVmaW5pdGlvbnMpOiAke3VudXNlZE1hcmtEZWZzLmpvaW4oXCIsIFwiKX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdW51c2VkIG1hcmsgZGVmaW5pdGlvbiBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFyay1kZWZzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICB1bnVzZWRNYXJrRGVmczogdW51c2VkTWFya0RlZnMubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ycGhhbmVkTWFya3MgPSBhbGxVc2VkTWFya3MuZmlsdGVyKChtYXJrKSA9PiAhdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLnZhbHVlKS5pbmNsdWRlcyhtYXJrKSkuZmlsdGVyKChtYXJrKSA9PiB0ZXh0QmxvY2subWFya0RlZnMgPT09IHZvaWQgMCB8fCAhdGV4dEJsb2NrLm1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgIGlmIChvcnBoYW5lZE1hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbkNoaWxkcmVuID0gdGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSAmJiBBcnJheS5pc0FycmF5KGNsZC5tYXJrcykgJiYgY2xkLm1hcmtzLnNvbWUoKG1hcmspID0+IG9ycGhhbmVkTWFya3MuaW5jbHVkZXMobWFyaykpKTtcbiAgICAgICAgaWYgKHNwYW5DaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG9ycGhhbmVkID0gb3JwaGFuZWRNYXJrcy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiBzcGFuQ2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gc2V0KChjaGlsZC5tYXJrcyB8fCBbXSkuZmlsdGVyKChjTXJrKSA9PiAhb3JwaGFuZWRNYXJrcy5pbmNsdWRlcyhjTXJrKSksIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfSwgXCJtYXJrc1wiXSkpLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBjb250YWlucyBtYXJrcyAoJHtvcnBoYW5lZH0pIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgY29udGVudCBtb2RlbC5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSBpbnZhbGlkIG1hcmtzXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFya3MuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFya3MuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgb3JwaGFuZWRNYXJrczogb3JwaGFuZWRNYXJrcy5tYXAoKG0pID0+IG0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0QmxvY2suY2hpbGRyZW4uc29tZSgoY2hpbGQsIGNJbmRleCkgPT4ge1xuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoY2hpbGQpKVxuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJyR7Y0luZGV4fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm9uLW9iamVjdC1jaGlsZC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBjSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICBpZiAoIWNoaWxkLl9rZXkgfHwgdHlwZW9mIGNoaWxkLl9rZXkgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiBbc2V0KG5ld0NoaWxkLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCBjSW5kZXhdKV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIGF0IGluZGV4ICR7Y0luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkgaW4gYmxvY2sgd2l0aCBfa2V5ICR7YmxrLl9rZXl9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiU2V0IGEgbmV3IHJhbmRvbSBfa2V5IG9uIHRoZSBvYmplY3RcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBpbmRleDogY0luZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQuX3R5cGUgPyB2YWxpZENoaWxkVHlwZXMuaW5jbHVkZXMoY2hpbGQuX3R5cGUpID8gY2hpbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSAmJiB0eXBlb2YgY2hpbGQudGV4dCAhPSBcInN0cmluZ1wiID8gKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGhhcyBtaXNzaW5nIG9yIGludmFsaWQgdGV4dCBwcm9wZXJ0eSFgLFxuICAgICAgICAgIGFjdGlvbjogXCJXcml0ZSBhbiBlbXB0eSB0ZXh0IHByb3BlcnR5IHRvIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW52YWxpZC1zcGFuLXRleHQuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKSA6ICExIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaGFzIGludmFsaWQgJ190eXBlJyBwcm9wZXJ0eSAoJHtjaGlsZC5fdHlwZX0pLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC1jaGlsZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkVHlwZTogY2hpbGQuX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgJ190eXBlJyBwcm9wZXJ0eS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQtdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCk7XG4gICAgICB9KSAmJiAodmFsaWQgPSAhMSk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSkgJiYgKHZhbGlkID0gITEpLCB7XG4gICAgdmFsaWQsXG4gICAgcmVzb2x1dGlvbixcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHx8ICExO1xuICBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuZ2V0KGVkaXRvcik7XG59XG5jb25zdCBQQVRDSElORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUGF0Y2hpbmcoZWRpdG9yKTtcbiAgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBQQVRDSElORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hpbmcoZWRpdG9yKSB7XG4gIHJldHVybiBQQVRDSElORy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGlmZihkaWZmMikge1xuICBjb25zdCBbdHlwZSwgcGF0Y2hdID0gZGlmZjI7XG4gIHJldHVybiBbdHlwZSwgcGF0Y2hdO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uT3ZlcmxhcCh0ZXh0QSwgdGV4dEIpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgdGV4dDFMZW5ndGggPiB0ZXh0Mkxlbmd0aCA/IHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgpIDogdGV4dDFMZW5ndGggPCB0ZXh0Mkxlbmd0aCAmJiAodGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFMZW5ndGgpKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IE1hdGgubWluKHRleHQxTGVuZ3RoLCB0ZXh0Mkxlbmd0aCk7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpIHJldHVybiB0ZXh0TGVuZ3RoO1xuICBsZXQgYmVzdCA9IDAsIGxlbmd0aCA9IDE7XG4gIGZvciAobGV0IGZvdW5kID0gMDsgZm91bmQgIT09IC0xOyApIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpO1xuICAgIGlmIChmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybiksIGZvdW5kID09PSAtMSkgcmV0dXJuIGJlc3Q7XG4gICAgbGVuZ3RoICs9IGZvdW5kLCAoZm91bmQgPT09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpID09PSB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkgJiYgKGJlc3QgPSBsZW5ndGgsIGxlbmd0aCsrKTtcbiAgfVxuICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDFbMF0gIT09IHRleHQyWzBdKSByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlclN0YXJ0ID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApIHRleHQxLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlclN0YXJ0ID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxW3RleHQxLmxlbmd0aCAtIDFdICE9PSB0ZXh0Mlt0ZXh0Mi5sZW5ndGggLSAxXSkgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJFbmQgPSAwO1xuICBmb3IgKDsgcG9pbnRlck1pbiA8IHBvaW50ZXJNaWQ7ICkgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJFbmQpID09PSB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlck1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlckVuZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJFbmQgPSBwb2ludGVyTWluKSA6IHBvaW50ZXJNYXggPSBwb2ludGVyTWlkLCBwb2ludGVyTWlkID0gTWF0aC5mbG9vcigocG9pbnRlck1heCAtIHBvaW50ZXJNaW4pIC8gMiArIHBvaW50ZXJNaW4pO1xuICByZXR1cm4gcG9pbnRlck1pZDtcbn1cbmZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTUyOTYgJiYgY2hhckNvZGUgPD0gNTYzMTk7XG59XG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTYzMjAgJiYgY2hhckNvZGUgPD0gNTczNDM7XG59XG5mdW5jdGlvbiBiaXNlY3QodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGgsIG1heEQgPSBNYXRoLmNlaWwoKHRleHQxTGVuZ3RoICsgdGV4dDJMZW5ndGgpIC8gMiksIHZPZmZzZXQgPSBtYXhELCB2TGVuZ3RoID0gMiAqIG1heEQsIHYxID0gbmV3IEFycmF5KHZMZW5ndGgpLCB2MiA9IG5ldyBBcnJheSh2TGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB2TGVuZ3RoOyB4KyspIHYxW3hdID0gLTEsIHYyW3hdID0gLTE7XG4gIHYxW3ZPZmZzZXQgKyAxXSA9IDAsIHYyW3ZPZmZzZXQgKyAxXSA9IDA7XG4gIGNvbnN0IGRlbHRhID0gdGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCwgZnJvbnQgPSBkZWx0YSAlIDIgIT09IDA7XG4gIGxldCBrMXN0YXJ0ID0gMCwgazFlbmQgPSAwLCBrMnN0YXJ0ID0gMCwgazJlbmQgPSAwO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IG1heEQgJiYgIShEYXRlLm5vdygpID4gZGVhZGxpbmUpOyBkKyspIHtcbiAgICBmb3IgKGxldCBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICBjb25zdCBrMU9mZnNldCA9IHZPZmZzZXQgKyBrMTtcbiAgICAgIGxldCB4MTtcbiAgICAgIGsxID09PSAtZCB8fCBrMSAhPT0gZCAmJiB2MVtrMU9mZnNldCAtIDFdIDwgdjFbazFPZmZzZXQgKyAxXSA/IHgxID0gdjFbazFPZmZzZXQgKyAxXSA6IHgxID0gdjFbazFPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTEgPSB4MSAtIGsxO1xuICAgICAgZm9yICg7IHgxIDwgdGV4dDFMZW5ndGggJiYgeTEgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQoeDEpID09PSB0ZXh0Mi5jaGFyQXQoeTEpOyApIHgxKyssIHkxKys7XG4gICAgICBpZiAodjFbazFPZmZzZXRdID0geDEsIHgxID4gdGV4dDFMZW5ndGgpIGsxZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MSA+IHRleHQyTGVuZ3RoKSBrMXN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJPZmZzZXQgPj0gMCAmJiBrMk9mZnNldCA8IHZMZW5ndGggJiYgdjJbazJPZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgyID0gdGV4dDFMZW5ndGggLSB2MltrMk9mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSByZXR1cm4gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBrMjtcbiAgICAgIGxldCB4MjtcbiAgICAgIGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMk9mZnNldCAtIDFdIDwgdjJbazJPZmZzZXQgKyAxXSA/IHgyID0gdjJbazJPZmZzZXQgKyAxXSA6IHgyID0gdjJbazJPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTIgPSB4MiAtIGsyO1xuICAgICAgZm9yICg7IHgyIDwgdGV4dDFMZW5ndGggJiYgeTIgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFMZW5ndGggLSB4MiAtIDEpID09PSB0ZXh0Mi5jaGFyQXQodGV4dDJMZW5ndGggLSB5MiAtIDEpOyApIHgyKyssIHkyKys7XG4gICAgICBpZiAodjJbazJPZmZzZXRdID0geDIsIHgyID4gdGV4dDFMZW5ndGgpIGsyZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MiA+IHRleHQyTGVuZ3RoKSBrMnN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxT2Zmc2V0ID49IDAgJiYgazFPZmZzZXQgPCB2TGVuZ3RoICYmIHYxW2sxT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxT2Zmc2V0XSwgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDtcbiAgICAgICAgICBpZiAoeDIgPSB0ZXh0MUxlbmd0aCAtIHgyLCB4MSA+PSB4MikgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufVxuZnVuY3Rpb24gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4LCB5LCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KSwgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpLCB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSksIGRpZmZzID0gZG9EaWZmKHRleHQxYSwgdGV4dDJhLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmVcbiAgfSksIGRpZmZzYiA9IGRvRGlmZih0ZXh0MWIsIHRleHQyYiwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0MiwgdGltZW91dCA9IDEpIHtcbiAgaWYgKHRpbWVvdXQgPD0gMCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxvbmdUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnRUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmdUZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnRUZXh0Lmxlbmd0aCAqIDIgPCBsb25nVGV4dC5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCBoYWxmTWF0Y2gxID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gNCkpLCBoYWxmTWF0Y2gyID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gMikpO1xuICBsZXQgaGFsZk1hdGNoO1xuICBpZiAoaGFsZk1hdGNoMSAmJiBoYWxmTWF0Y2gyKSBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxWzRdLmxlbmd0aCA+IGhhbGZNYXRjaDJbNF0ubGVuZ3RoID8gaGFsZk1hdGNoMSA6IGhhbGZNYXRjaDI7XG4gIGVsc2Uge1xuICAgIGlmICghaGFsZk1hdGNoMSAmJiAhaGFsZk1hdGNoMikgcmV0dXJuIG51bGw7XG4gICAgaGFsZk1hdGNoMiA/IGhhbGZNYXRjaDEgfHwgKGhhbGZNYXRjaCA9IGhhbGZNYXRjaDIpIDogaGFsZk1hdGNoID0gaGFsZk1hdGNoMTtcbiAgfVxuICBpZiAoIWhhbGZNYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBoYWxmIG1hdGNoLlwiKTtcbiAgbGV0IHRleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQjtcbiAgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gKHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSkgOiAodGV4dDJBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbMV0sIHRleHQxQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDFCID0gaGFsZk1hdGNoWzNdKTtcbiAgY29uc3QgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdO1xuICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcbn1cbmZ1bmN0aW9uIGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgaSkge1xuICBjb25zdCBzZWVkID0gbG9uZ1RleHQuc2xpY2UoaSwgaSArIE1hdGguZmxvb3IobG9uZ1RleHQubGVuZ3RoIC8gNCkpO1xuICBsZXQgaiA9IC0xLCBiZXN0Q29tbW9uID0gXCJcIiwgYmVzdExvbmdUZXh0QSwgYmVzdExvbmdUZXh0QiwgYmVzdFNob3J0VGV4dEEsIGJlc3RTaG9ydFRleHRCO1xuICBmb3IgKDsgKGogPSBzaG9ydFRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KGxvbmdUZXh0LnNsaWNlKGkpLCBzaG9ydFRleHQuc2xpY2UoaikpLCBzdWZmaXhMZW5ndGggPSBnZXRDb21tb25TdWZmaXgobG9uZ1RleHQuc2xpY2UoMCwgaSksIHNob3J0VGV4dC5zbGljZSgwLCBqKSk7XG4gICAgYmVzdENvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGggJiYgKGJlc3RDb21tb24gPSBzaG9ydFRleHQuc2xpY2UoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydFRleHQuc2xpY2UoaiwgaiArIHByZWZpeExlbmd0aCksIGJlc3RMb25nVGV4dEEgPSBsb25nVGV4dC5zbGljZSgwLCBpIC0gc3VmZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QiA9IGxvbmdUZXh0LnNsaWNlKGkgKyBwcmVmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QSA9IHNob3J0VGV4dC5zbGljZSgwLCBqIC0gc3VmZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEIgPSBzaG9ydFRleHQuc2xpY2UoaiArIHByZWZpeExlbmd0aCkpO1xuICB9XG4gIHJldHVybiBiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ1RleHQubGVuZ3RoID8gW2Jlc3RMb25nVGV4dEEgfHwgXCJcIiwgYmVzdExvbmdUZXh0QiB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QSB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QiB8fCBcIlwiLCBiZXN0Q29tbW9uIHx8IFwiXCJdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjaGFycyA9IGRpZmZzW3hdWzFdLCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICBkaWZmc1t4XVsxXSA9IHRleHQuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbGluZXNUb0NoYXJzKHRleHRBLCB0ZXh0Qikge1xuICBjb25zdCBsaW5lQXJyYXkgPSBbXSwgbGluZUhhc2ggPSB7fTtcbiAgbGluZUFycmF5WzBdID0gXCJcIjtcbiAgZnVuY3Rpb24gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0KSB7XG4gICAgbGV0IGNoYXJzID0gXCJcIiwgbGluZVN0YXJ0ID0gMCwgbGluZUVuZCA9IC0xLCBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIGZvciAoOyBsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxOyApIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoYFxuYCwgbGluZVN0YXJ0KSwgbGluZUVuZCA9PT0gLTEgJiYgKGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuICAgICAgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOiBsaW5lSGFzaFtsaW5lXSAhPT0gdm9pZCAwKSA/IGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pIDogKGxpbmVBcnJheUxlbmd0aCA9PT0gbWF4TGluZXMgJiYgKGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCksIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCksIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKSwgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGgsIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lKSwgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuICBsZXQgbWF4TGluZXMgPSA0ZTQ7XG4gIGNvbnN0IGNoYXJzMSA9IGRpZmZMaW5lc1RvTXVuZ2UodGV4dEEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICBjb25zdCBjaGFyczIgPSBkaWZmTGluZXNUb011bmdlKHRleHRCKTtcbiAgcmV0dXJuIHtcbiAgICBjaGFyczEsXG4gICAgY2hhcnMyLFxuICAgIGxpbmVBcnJheVxuICB9O1xufVxuZnVuY3Rpb24gZG9MaW5lTW9kZURpZmYodGV4dEEsIHRleHRCLCBvcHRzKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCBhID0gbGluZXNUb0NoYXJzKHRleHQxLCB0ZXh0Mik7XG4gIHRleHQxID0gYS5jaGFyczEsIHRleHQyID0gYS5jaGFyczI7XG4gIGNvbnN0IGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xuICBsZXQgZGlmZnMgPSBkb0RpZmYodGV4dDEsIHRleHQyLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgfSk7XG4gIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KSwgZGlmZnMgPSBjbGVhbnVwU2VtYW50aWMoZGlmZnMpLCBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChjb3VudERlbGV0ZSA+PSAxICYmIGNvdW50SW5zZXJ0ID49IDEpIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQpLCBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQ7XG4gICAgICAgICAgY29uc3QgYWEgPSBkb0RpZmYodGV4dERlbGV0ZSwgdGV4dEluc2VydCwge1xuICAgICAgICAgICAgY2hlY2tMaW5lczogITEsXG4gICAgICAgICAgICBkZWFkbGluZTogb3B0cy5kZWFkbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAobGV0IGogPSBhYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGFhW2pdKTtcbiAgICAgICAgICBwb2ludGVyICs9IGFhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb3VudEluc2VydCA9IDAsIGNvdW50RGVsZXRlID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb24uXCIpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnBvcCgpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykge1xuICBsZXQgZGlmZnM7XG4gIGlmICghdGV4dDEpIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBpZiAoIXRleHQyKSByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxLCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpIHJldHVybiBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLCBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXSwgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoICYmIChkaWZmc1swXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFKSwgZGlmZnM7XG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKSByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIGNvbnN0IGhhbGZNYXRjaCA9IGZpbmRIYWxmTWF0Y2godGV4dDEsIHRleHQyKTtcbiAgaWYgKGhhbGZNYXRjaCkge1xuICAgIGNvbnN0IHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSwgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdLCBkaWZmc0EgPSBkb0RpZmYodGV4dDFBLCB0ZXh0MkEsIG9wdHMpLCBkaWZmc0IgPSBkb0RpZmYodGV4dDFCLCB0ZXh0MkIsIG9wdHMpO1xuICAgIHJldHVybiBkaWZmc0EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkQ29tbW9uXV0sIGRpZmZzQik7XG4gIH1cbiAgcmV0dXJuIG9wdHMuY2hlY2tMaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwID8gZG9MaW5lTW9kZURpZmYodGV4dDEsIHRleHQyLCBvcHRzKSA6IGJpc2VjdCh0ZXh0MSwgdGV4dDIsIG9wdHMuZGVhZGxpbmUpO1xufVxudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2dldE93blByb3BTeW1ib2xzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSQyID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMiA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSkgX19oYXNPd25Qcm9wJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMikgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDIoYikpIF9fcHJvcElzRW51bSQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERJRkZfREVMRVRFID0gLTEsIERJRkZfSU5TRVJUID0gMSwgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBkaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBpZiAodGV4dEEgPT09IG51bGwgfHwgdGV4dEIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChkaWZmKVwiKTtcbiAgY29uc3QgZGlmZnMgPSBkb0RpZmYodGV4dEEsIHRleHRCLCBjcmVhdGVJbnRlcm5hbE9wdHMob3B0cyB8fCB7fSkpO1xuICByZXR1cm4gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBkb0RpZmYodGV4dEEsIHRleHRCLCBvcHRpb25zKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBpZiAodGV4dDEgPT09IHRleHQyKSByZXR1cm4gdGV4dDEgPyBbW0RJRkZfRVFVQUwsIHRleHQxXV0gOiBbXTtcbiAgbGV0IGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpLCB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICBsZXQgZGlmZnMgPSBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tbW9ucHJlZml4ICYmIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pLCBjb21tb25zdWZmaXggJiYgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSksIGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWFkTGluZSh0aW1lb3V0KSB7XG4gIGxldCB0ID0gMTtcbiAgcmV0dXJuIHR5cGVvZiB0aW1lb3V0IDwgXCJ1XCIgJiYgKHQgPSB0aW1lb3V0IDw9IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogdGltZW91dCksIERhdGUubm93KCkgKyB0ICogMWUzO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDIoe1xuICAgIGNoZWNrTGluZXM6ICEwLFxuICAgIGRlYWRsaW5lOiBjcmVhdGVEZWFkTGluZShvcHRzLnRpbWVvdXQgfHwgMSlcbiAgfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBjb21iaW5lQ2hhcihkYXRhLCBjaGFyLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRhdGEgKyBjaGFyIDogY2hhciArIGRhdGE7XG59XG5mdW5jdGlvbiBzcGxpdENoYXIoZGF0YSwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBbZGF0YS5zdWJzdHJpbmcoMCwgZGF0YS5sZW5ndGggLSAxKSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdXSA6IFtkYXRhLnN1YnN0cmluZygxKSwgZGF0YVswXV07XG59XG5mdW5jdGlvbiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpLCBqLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRpZmZzW2ldWzFdW2RpZmZzW2ldWzFdLmxlbmd0aCAtIDFdID09PSBkaWZmc1tqXVsxXVtkaWZmc1tqXVsxXS5sZW5ndGggLSAxXSA6IGRpZmZzW2ldWzFdWzBdID09PSBkaWZmc1tqXVsxXVswXTtcbn1cbmZ1bmN0aW9uIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIGRpcikge1xuICBjb25zdCBpbnYgPSBkaXIgPT09IDEgPyAtMSA6IDE7XG4gIGxldCBpbnNlcnRJZHggPSBudWxsLCBkZWxldGVJZHggPSBudWxsLCBqID0gaSArIGRpcjtcbiAgZm9yICg7IGogPj0gMCAmJiBqIDwgZGlmZnMubGVuZ3RoICYmIChpbnNlcnRJZHggPT09IG51bGwgfHwgZGVsZXRlSWR4ID09PSBudWxsKTsgaiArPSBkaXIpIHtcbiAgICBjb25zdCBbb3AsIHRleHQyXSA9IGRpZmZzW2pdO1xuICAgIGlmICh0ZXh0Mi5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChvcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgaW5zZXJ0SWR4ID09PSBudWxsICYmIChpbnNlcnRJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICBkZWxldGVJZHggPT09IG51bGwgJiYgKGRlbGV0ZUlkeCA9IGopO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgaWYgKGluc2VydElkeCA9PT0gbnVsbCAmJiBkZWxldGVJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbcmVzdCwgY2hhcjJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICAgICAgICAgIGRpZmZzW2ldWzFdID0gcmVzdCwgZGlmZnNbal1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tqXVsxXSwgY2hhcjIsIGludik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5zZXJ0SWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpbnNlcnRJZHgsIGRlbGV0ZUlkeCwgZGlyKSkge1xuICAgIGNvbnN0IFtpbnNlcnRUZXh0MiwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHRdID0gc3BsaXRDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGludik7XG4gICAgZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGluc2VydFRleHQyLCBkaWZmc1tkZWxldGVJZHhdWzFdID0gZGVsZXRlVGV4dCwgZGlmZnNbaV1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tpXVsxXSwgaW5zZXJ0Q2hhciwgZGlyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW3RleHQsIGNoYXJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICBkaWZmc1tpXVsxXSA9IHRleHQsIGluc2VydElkeCA9PT0gbnVsbCA/IChkaWZmcy5zcGxpY2UoaiwgMCwgW0RJRkZfSU5TRVJULCBjaGFyXSksIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggPj0gaiAmJiBkZWxldGVJZHgrKykgOiBkaWZmc1tpbnNlcnRJZHhdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgY2hhciwgaW52KSwgZGVsZXRlSWR4ID09PSBudWxsID8gZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0RFTEVURSwgY2hhcl0pIDogZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGNoYXIsIGludik7XG59XG5mdW5jdGlvbiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtkaWZmVHlwZSwgZGlmZlRleHRdID0gZGlmZnNbaV07XG4gICAgaWYgKGRpZmZUZXh0Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgY29uc3QgZmlyc3RDaGFyID0gZGlmZlRleHRbMF0sIGxhc3RDaGFyID0gZGlmZlRleHRbZGlmZlRleHQubGVuZ3RoIC0gMV07XG4gICAgaXNIaWdoU3Vycm9nYXRlKGxhc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAxKSwgaXNMb3dTdXJyb2dhdGUoZmlyc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAtMSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykgZGlmZnNbaV1bMV0ubGVuZ3RoID09PSAwICYmIGRpZmZzLnNwbGljZShpLCAxKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBTZW1hbnRpYyhyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIGxlbmd0aEluc2VydGlvbnMxID0gMCwgbGVuZ3RoRGVsZXRpb25zMSA9IDAsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDA7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMxID0gbGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUID8gbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDogbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGgsIGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICBmb3IgKGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpLCBwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV0sIG92ZXJsYXBMZW5ndGgxID0gZ2V0Q29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKSwgb3ZlcmxhcExlbmd0aDIgPSBnZXRDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgb3ZlcmxhcExlbmd0aDEgPj0gb3ZlcmxhcExlbmd0aDIgPyAob3ZlcmxhcExlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKSwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSksIHBvaW50ZXIrKykgOiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVCwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDIpLCBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgyKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXggPSAvW15hLXpBLVowLTldLywgd2hpdGVzcGFjZVJlZ2V4ID0gL1xccy8sIGxpbmVicmVha1JlZ2V4ID0gL1tcXHJcXG5dLywgYmxhbmtsaW5lRW5kUmVnZXggPSAvXFxuXFxyP1xcbiQvLCBibGFua2xpbmVTdGFydFJlZ2V4ID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhyYXdEaWZmcykge1xuICBjb25zdCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSByZXR1cm4gNjtcbiAgICBjb25zdCBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLCBjaGFyMiA9IHR3by5jaGFyQXQoMCksIG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJiBjaGFyMS5tYXRjaCh3aGl0ZXNwYWNlUmVnZXgpLCB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmIGNoYXIyLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKGJsYW5rbGluZUVuZFJlZ2V4KSwgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXgpO1xuICAgIHJldHVybiBibGFua0xpbmUxIHx8IGJsYW5rTGluZTIgPyA1IDogbGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyID8gNCA6IG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyID8gMyA6IHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyID8gMiA6IG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMiA/IDEgOiAwO1xuICB9XG4gIGxldCBwb2ludGVyID0gMTtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxOyApIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgbGV0IGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdLCBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICBjb25zdCBjb21tb25PZmZzZXQgPSBnZXRDb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG4gICAgICBsZXQgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MSwgYmVzdEVkaXQgPSBlZGl0LCBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyLCBiZXN0U2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgZm9yICg7IGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApOyApIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApLCBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApLCBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBzY29yZSA9IGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICsgZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIHNjb3JlID49IGJlc3RTY29yZSAmJiAoYmVzdFNjb3JlID0gc2NvcmUsIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5Mik7XG4gICAgICB9XG4gICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEgJiYgKGJlc3RFcXVhbGl0eTEgPyBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxIDogKGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIHBvaW50ZXItLSksIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQsIGJlc3RFcXVhbGl0eTIgPyBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyIDogKGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIHBvaW50ZXItLSkpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gY2xlYW51cE1lcmdlKHJhd0RpZmZzKSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIiwgY29tbW9ubGVuZ3RoO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV0sIHBvaW50ZXIrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICBjb3VudERlbGV0ZSsrLCB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0ID4gMSA/IChjb3VudERlbGV0ZSAhPT0gMCAmJiBjb3VudEluc2VydCAhPT0gMCAmJiAoY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0ID4gMCAmJiBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVsxXSArPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpIDogKGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCwgdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pLCBwb2ludGVyKyspLCB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCkpLCBjb21tb25sZW5ndGggPSBnZXRDb21tb25TdWZmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSksIGNvbW1vbmxlbmd0aCAhPT0gMCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyh0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRJbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKDAsIHRleHREZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSkpLCBwb2ludGVyIC09IGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQsIGRpZmZzLnNwbGljZShwb2ludGVyLCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgdGV4dERlbGV0ZS5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9ERUxFVEUsIHRleHREZWxldGVdKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydC5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9JTlNFUlQsIHRleHRJbnNlcnRdKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrKSA6IHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpKSA6IHBvaW50ZXIrKywgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uXCIpO1xuICB9XG4gIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiICYmIGRpZmZzLnBvcCgpO1xuICBsZXQgaGFzQ2hhbmdlcyA9ICExO1xuICBmb3IgKHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMICYmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA/IChkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApIDogZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyICsgMV1bMV0gJiYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG5mdW5jdGlvbiB0cnVlQ291bnQoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5yZWR1Y2UoKG4sIGJvb2wpID0+IG4gKyAoYm9vbCA/IDEgOiAwKSwgMCk7XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmaWNpZW5jeShyYXdEaWZmcywgZWRpdENvc3QgPSA0KSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLCBoYXNDaGFuZ2VzID0gITE7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwb2ludGVyID0gMCwgcHJlSW5zID0gITEsIHByZURlbCA9ICExLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMTtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZWRpdENvc3QgJiYgKHBvc3RJbnMgfHwgcG9zdERlbCkgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgcHJlSW5zID0gcG9zdElucywgcHJlRGVsID0gcG9zdERlbCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsKSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSA/IHBvc3REZWwgPSAhMCA6IHBvc3RJbnMgPSAhMCwgbGFzdEVxdWFsaXR5ICYmIChwcmVJbnMgJiYgcHJlRGVsICYmIHBvc3RJbnMgJiYgcG9zdERlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZWRpdENvc3QgLyAyICYmIHRydWVDb3VudChwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbCkgPT09IDMpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwcmVJbnMgJiYgcHJlRGVsID8gKHBvc3RJbnMgPSAhMCwgcG9zdERlbCA9ICEwLCBlcXVhbGl0aWVzTGVuZ3RoID0gMCkgOiAoZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpIF9faGFzT3duUHJvcCQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDEpIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQxKGIpKSBfX3Byb3BJc0VudW0kMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIC8qKlxuICAgKiBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgICovXG4gIHRocmVzaG9sZDogMC41LFxuICAvKipcbiAgICogSG93IGZhciB0byBzZWFyY2ggZm9yIGEgbWF0Y2ggKDAgPSBleGFjdCBsb2NhdGlvbiwgMTAwMCsgPSBicm9hZCBtYXRjaCkuXG4gICAqIEEgbWF0Y2ggdGhpcyBtYW55IGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBleHBlY3RlZCBsb2NhdGlvbiB3aWxsIGFkZFxuICAgKiAxLjAgdG8gdGhlIHNjb3JlICgwLjAgaXMgYSBwZXJmZWN0IG1hdGNoKS5cbiAgICovXG4gIGRpc3RhbmNlOiAxZTNcbn07XG5mdW5jdGlvbiBhcHBseURlZmF1bHRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDEoX19zcHJlYWRWYWx1ZXMkMSh7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG59XG5jb25zdCBNQVhfQklUUyQxID0gMzI7XG5mdW5jdGlvbiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdHMgPSB7fSkge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUyQxKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuXCIpO1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhvcHRzKSwgcyA9IGdldEFscGhhYmV0RnJvbVBhdHRlcm4ocGF0dGVybik7XG4gIGZ1bmN0aW9uIGdldEJpdGFwU2NvcmUoZSwgeCkge1xuICAgIGNvbnN0IGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoLCBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICByZXR1cm4gb3B0aW9ucy5kaXN0YW5jZSA/IGFjY3VyYWN5ICsgcHJveGltaXR5IC8gb3B0aW9ucy5kaXN0YW5jZSA6IHByb3hpbWl0eSA/IDEgOiBhY2N1cmFjeTtcbiAgfVxuICBsZXQgc2NvcmVUaHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCwgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCksIGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSwgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpKSk7XG4gIGNvbnN0IG1hdGNobWFzayA9IDEgPDwgcGF0dGVybi5sZW5ndGggLSAxO1xuICBiZXN0TG9jID0gLTE7XG4gIGxldCBiaW5NaW4sIGJpbk1pZCwgYmluTWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCwgbGFzdFJkID0gW107XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIGZvciAoYmluTWluID0gMCwgYmluTWlkID0gYmluTWF4OyBiaW5NaW4gPCBiaW5NaWQ7ICkgZ2V0Qml0YXBTY29yZShkLCBsb2MgKyBiaW5NaWQpIDw9IHNjb3JlVGhyZXNob2xkID8gYmluTWluID0gYmluTWlkIDogYmluTWF4ID0gYmluTWlkLCBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgYmluTWF4ID0gYmluTWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbk1pZCArIDEpO1xuICAgIGNvbnN0IGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbk1pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGgsIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDAgPyByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIDogcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCB8ICgobGFzdFJkW2ogKyAxXSB8IGxhc3RSZFtqXSkgPDwgMSB8IDEpIHwgbGFzdFJkW2ogKyAxXSwgcmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRCaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSBpZiAoc2NvcmVUaHJlc2hvbGQgPSBzY29yZSwgYmVzdExvYyA9IGogLSAxLCBiZXN0TG9jID4gbG9jKSBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0TG9jKTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZVRocmVzaG9sZCkgYnJlYWs7XG4gICAgbGFzdFJkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RMb2M7XG59XG5mdW5jdGlvbiBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pIHtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gaSAtIDE7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbWF0Y2godGV4dCwgcGF0dGVybiwgc2VhcmNoTG9jYXRpb24pIHtcbiAgaWYgKHRleHQgPT09IG51bGwgfHwgcGF0dGVybiA9PT0gbnVsbCB8fCBzZWFyY2hMb2NhdGlvbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2MpIHtcbiAgbGV0IGNoYXJzMSA9IDAsIGNoYXJzMiA9IDAsIGxhc3RDaGFyczEgPSAwLCBsYXN0Q2hhcnMyID0gMCwgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aCAmJiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmIChjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmIChjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgIShjaGFyczEgPiBsb2MpKTsgeCsrKSBsYXN0Q2hhcnMxID0gY2hhcnMxLCBsYXN0Q2hhcnMyID0gY2hhcnMyO1xuICByZXR1cm4gZGlmZnMubGVuZ3RoICE9PSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSA/IGxhc3RDaGFyczIgOiBsYXN0Q2hhcnMyICsgKGxvYyAtIGxhc3RDaGFyczEpO1xufVxuZnVuY3Rpb24gY291bnRVdGY4Qnl0ZXMoc3RyKSB7XG4gIGxldCBieXRlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSAwLCBpZHggPSAwO1xuICBmdW5jdGlvbiBhZHZhbmNlVG8odGFyZ2V0KSB7XG4gICAgZm9yICg7IGJ5dGVPZmZzZXQgPCB0YXJnZXQ7ICkge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gYmFzZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIikgcmV0dXJuIGlkeDtcbiAgICAgIGJ5dGVPZmZzZXQgKz0gdXRmOGxlbihjb2RlUG9pbnQpLCBjb2RlUG9pbnQgPiA2NTUzNSA/IGlkeCArPSAyIDogaWR4ICs9IDE7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0V4Y2VlZGluZ0luZGljZXMgJiYgYnl0ZU9mZnNldCAhPT0gdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSBhZGp1c3RlZC5wdXNoKHtcbiAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICBzdGFydDI6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDIpLFxuICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICBsZW5ndGgxOiBwYXRjaC5sZW5ndGgxLFxuICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgIHV0ZjhMZW5ndGgyOiBwYXRjaC51dGY4TGVuZ3RoMlxuICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBtYXJnaW47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGNoZXMpIHAuc3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAuc3RhcnQyICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgbGV0IHBhdGNoID0gcGF0Y2hlc1swXSwgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCksIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEsIHN0YXJ0Mikge1xuICByZXR1cm4ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDEsXG4gICAgc3RhcnQyLFxuICAgIHV0ZjhTdGFydDE6IHN0YXJ0MSxcbiAgICB1dGY4U3RhcnQyOiBzdGFydDIsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwLFxuICAgIHV0ZjhMZW5ndGgxOiAwLFxuICAgIHV0ZjhMZW5ndGgyOiAwXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdE1heChwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYXRjaFNpemUgPSBNQVhfQklUUztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiUGF0Y2hlcyBtdXN0IGJlIGFuIGFycmF5IC0gcGFzcyB0aGUgcGF0Y2ggdG8gYHBhcnNlUGF0Y2goKWAgZmlyc3RcIik7XG4gIGxldCB0ZXh0ID0gb3JpZ2luYWxUZXh0O1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHJldHVybiBbdGV4dCwgW11dO1xuICBjb25zdCBwYXJzZWQgPSBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCB0ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiBvcHRzLmFsbG93RXhjZWVkaW5nSW5kaWNlc1xuICB9KSwgbWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgREVGQVVMVF9NQVJHSU4sIGRlbGV0ZVRocmVzaG9sZCA9IG9wdHMuZGVsZXRlVGhyZXNob2xkIHx8IDAuNCwgbnVsbFBhZGRpbmcgPSBhZGRQYWRkaW5nKHBhcnNlZCwgbWFyZ2luKTtcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nLCBzcGxpdE1heChwYXJzZWQsIG1hcmdpbik7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJzZWQubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBleHBlY3RlZExvYyA9IHBhcnNlZFt4XS5zdGFydDIgKyBkZWx0YSwgdGV4dDEgPSBkaWZmVGV4dDEocGFyc2VkW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRMb2MsIGVuZExvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyA/IChzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCBNQVhfQklUUyksIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgIT09IC0xICYmIChlbmRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gTUFYX0JJVFMpLCBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKSByZXN1bHRzW3hdID0gITEsIGRlbHRhIC09IHBhcnNlZFt4XS5sZW5ndGgyIC0gcGFyc2VkW3hdLmxlbmd0aDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHRzW3hdID0gITAsIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRMb2MgPT09IC0xID8gdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpIDogdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgTUFYX0JJVFMpLCB0ZXh0MSA9PT0gdGV4dDIpIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYykgKyBkaWZmVGV4dDIocGFyc2VkW3hdLmRpZmZzKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGlmZnMgPSBkaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgICAgICAgIGNoZWNrTGluZXM6ICExXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgJiYgbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gZGVsZXRlVGhyZXNob2xkKSByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIHN0cmluZzogJHtsaW5lc1t0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIikgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBwYXJzZTogJHtjdXJyZW50TGluZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHV0ZjhEaWZmID0gY291bnRVdGY4Qnl0ZXMobGluZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGlmIChzaWduID09PSBcIi1cIikgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIgXCIpIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZiwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IElTX1VET0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19SRURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoVW5kb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1VuZG9pbmcoZWRpdG9yKTtcbiAgSVNfVURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfVURPSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNVbmRvaW5nKGVkaXRvcikge1xuICByZXR1cm4gSVNfVURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNVbmRvaW5nKGVkaXRvciwgaXNVbmRvaW5nMikge1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgaXNVbmRvaW5nMik7XG59XG5mdW5jdGlvbiB3aXRoUmVkb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1JlZG9pbmcoZWRpdG9yKTtcbiAgSVNfUkVET0lORy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1JlZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19SRURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNSZWRvaW5nKGVkaXRvciwgaXNSZWRvaW5nMikge1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsIGlzUmVkb2luZzIpO1xufVxuY29uc3QgZGVidWckaSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFVuZG9SZWRvXCIpLCBTQVZJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgUkVNT1RFX1BBVENIRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVU5ET19TVEVQX0xJTUlUID0gMWUzLCBpc1NhdmluZyA9IChlZGl0b3IpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBTQVZJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBzdGF0ZSA9PT0gdm9pZCAwID8gITAgOiBzdGF0ZTtcbn0sIGdldFJlbW90ZVBhdGNoZXMgPSAoZWRpdG9yKSA9PiAoUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgUkVNT1RFX1BBVENIRVMuc2V0KGVkaXRvciwgW10pLCBSRU1PVEVfUEFUQ0hFUy5nZXQoZWRpdG9yKSB8fCBbXSk7XG5mdW5jdGlvbiBjcmVhdGVXaXRoVW5kb1JlZG8ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgYmxvY2tTY2hlbWFUeXBlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKGVkaXRvcikgPT4ge1xuICAgIGxldCBwcmV2aW91c1NuYXBzaG90ID0gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCBibG9ja1NjaGVtYVR5cGUubmFtZSk7XG4gICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IGdldFJlbW90ZVBhdGNoZXMoZWRpdG9yKTtcbiAgICBvcHRpb25zLnN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICBkZWJ1ZyRpKFwiU3Vic2NyaWJpbmcgdG8gcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCAoe1xuICAgICAgICBwYXRjaGVzLFxuICAgICAgICBzbmFwc2hvdFxuICAgICAgfSkgPT4ge1xuICAgICAgICBsZXQgcmVzZXQgPSAhMTtcbiAgICAgICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICAgIGlmICghcmVzZXQgJiYgcGF0Y2gub3JpZ2luICE9PSBcImxvY2FsXCIgJiYgcmVtb3RlUGF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkZWJ1ZyRpKFwiU29tZW9uZSBlbHNlIGNsZWFyZWQgdGhlIGNvbnRlbnQsIHJlc2V0dGluZyB1bmRvL3JlZG8gaGlzdG9yeVwiKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICAgICAgICB9LCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHJlc2V0ID0gITA7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW90ZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGNoLFxuICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICAgIHByZXZpb3VzU25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIHByZXZpb3VzU25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZGVidWckaShcIlVuc3Vic2NyaWJpbmcgdG8gcGF0Y2hlc1wiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0pLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgIHVuZG9zOiBbXSxcbiAgICAgIHJlZG9zOiBbXVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBoaXN0b3J5XG4gICAgICB9ID0gZWRpdG9yLCB7XG4gICAgICAgIHVuZG9zXG4gICAgICB9ID0gaGlzdG9yeSwgc3RlcCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdLCBsYXN0T3AgPSBzdGVwICYmIHN0ZXAub3BlcmF0aW9ucyAmJiBzdGVwLm9wZXJhdGlvbnNbc3RlcC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdLCBvdmVyd3JpdGUgPSBzaG91bGRPdmVyd3JpdGUob3AsIGxhc3RPcCksIHNhdmUgPSBpc1NhdmluZyhlZGl0b3IpO1xuICAgICAgbGV0IG1lcmdlID0gITA7XG4gICAgICBpZiAoc2F2ZSkge1xuICAgICAgICBpZiAoc3RlcCA/IG9wZXJhdGlvbnMubGVuZ3RoID09PSAwICYmIChtZXJnZSA9IHNob3VsZE1lcmdlKG9wLCBsYXN0T3ApIHx8IG92ZXJ3cml0ZSkgOiBtZXJnZSA9ICExLCBzdGVwICYmIG1lcmdlKVxuICAgICAgICAgIHN0ZXAub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RlcCA9IHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFsuLi5lZGl0b3Iuc2VsZWN0aW9uID09PSBudWxsID8gW10gOiBbY3JlYXRlU2VsZWN0T3BlcmF0aW9uKGVkaXRvcildLCBvcF0sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1bmRvcy5wdXNoKG5ld1N0ZXApLCBkZWJ1ZyRpKFwiQ3JlYXRlZCBuZXcgdW5kbyBzdGVwXCIsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyB1bmRvcy5sZW5ndGggPiBVTkRPX1NURVBfTElNSVQ7IClcbiAgICAgICAgICB1bmRvcy5zaGlmdCgpO1xuICAgICAgICBzaG91bGRDbGVhcihvcCkgJiYgKGhpc3RvcnkucmVkb3MgPSBbXSk7XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvci51bmRvID0gKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVuZG9zXG4gICAgICB9ID0gZWRpdG9yLmhpc3Rvcnk7XG4gICAgICBpZiAodW5kb3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkZWJ1ZyRpKFwiVW5kb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJldmVyc2VkT3BlcmF0aW9ucyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoT3BlcmF0aW9uLmludmVyc2UpLnJldmVyc2UoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgd2l0aFVuZG9pbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldmVyc2VkT3BlcmF0aW9ucy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1ZyRpKFwiQ291bGQgbm90IHBlcmZvcm0gdW5kbyBzdGVwXCIsIGVyciksIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHNldElzVW5kb2luZyhlZGl0b3IsICExKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5oaXN0b3J5LnJlZG9zLnB1c2goc3RlcCksIGVkaXRvci5oaXN0b3J5LnVuZG9zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZWRpdG9yLnJlZG8gPSAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVkb3NcbiAgICAgIH0gPSBlZGl0b3IuaGlzdG9yeTtcbiAgICAgIGlmIChyZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSByZWRvc1tyZWRvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRlYnVnJGkoXCJSZWRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4odHJhbnNmb3JtZWRPcGVyYXRpb25zLm1hcCgob3ApID0+IHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIGl0ZW0ucGF0Y2gsIG9wLCBpdGVtLnNuYXBzaG90LCBpdGVtLnByZXZpb3VzU25hcHNob3QpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHdpdGhSZWRvaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVidWckaShcIkNvdWxkIG5vdCBwZXJmb3JtIHJlZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgcmVkb3M6IFtdXG4gICAgICAgICAgICB9LCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCBzZXRJc1JlZG9pbmcoZWRpdG9yLCAhMSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIHBhdGNoLCBvcGVyYXRpb24sIHNuYXBzaG90LCBwcmV2aW91c1NuYXBzaG90KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJpbnNlcnRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGluc2VydEJsb2NrSW5kZXggPSAoc25hcHNob3QgfHwgW10pLmZpbmRJbmRleCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkpO1xuICAgIHJldHVybiBkZWJ1ZyRpKGBBZGp1c3RpbmcgYmxvY2sgcGF0aCAoKyR7cGF0Y2guaXRlbXMubGVuZ3RofSkgZm9yICcke3RyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGV9JyBvcGVyYXRpb24gYW5kIHBhdGNoICcke3BhdGNoLnR5cGV9J2ApLCBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCBwYXRjaC5pdGVtcy5sZW5ndGgsIGluc2VydEJsb2NrSW5kZXgpXTtcbiAgfVxuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgdW5zZXRCbG9ja0luZGV4ID0gKHByZXZpb3VzU25hcHNob3QgfHwgW10pLmZpbmRJbmRleCgoYmxrKSA9PiBpc0VxdWFsKHtcbiAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkpO1xuICAgIHJldHVybiBcInBhdGhcIiBpbiB0cmFuc2Zvcm1lZE9wZXJhdGlvbiAmJiBBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGgpICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gPT09IHVuc2V0QmxvY2tJbmRleCA/IChkZWJ1ZyRpKFwiU2tpcHBpbmcgdHJhbnNmb3JtYXRpb24gdGhhdCB0YXJnZXRlZCByZW1vdmVkIGJsb2NrXCIpLCBbXSkgOiBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCAtMSwgdW5zZXRCbG9ja0luZGV4KV07XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gZGVidWckaShgQWRqdXN0aW5nIHNlbGVjdGlvbiBmb3IgdW5zZXQgZXZlcnl0aGluZyBwYXRjaCBhbmQgJHtvcGVyYXRpb24udHlwZX0gb3BlcmF0aW9uYCksIFtdO1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJkaWZmTWF0Y2hQYXRjaFwiKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uVGFyZ2V0QmxvY2sgPSBmaW5kT3BlcmF0aW9uVGFyZ2V0QmxvY2soZWRpdG9yLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbik7XG4gICAgcmV0dXJuICFvcGVyYXRpb25UYXJnZXRCbG9jayB8fCAhaXNFcXVhbCh7XG4gICAgICBfa2V5OiBvcGVyYXRpb25UYXJnZXRCbG9jay5fa2V5XG4gICAgfSwgcGF0Y2gucGF0aFswXSkgPyBbdHJhbnNmb3JtZWRPcGVyYXRpb25dIDogKHBhcnNlKHBhdGNoLnZhbHVlKS5mb3JFYWNoKChkaWZmUGF0Y2gpID0+IHtcbiAgICAgIGxldCBhZGp1c3RPZmZzZXRCeSA9IDAsIGNoYW5nZWRPZmZzZXQgPSBkaWZmUGF0Y2gudXRmOFN0YXJ0MTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlmZnNcbiAgICAgIH0gPSBkaWZmUGF0Y2g7XG4gICAgICBpZiAoZGlmZnMuZm9yRWFjaCgoZGlmZjIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IFtkaWZmVHlwZSwgdGV4dF0gPSBkaWZmMjtcbiAgICAgICAgZGlmZlR5cGUgPT09IERJRkZfSU5TRVJUID8gKGFkanVzdE9mZnNldEJ5ICs9IHRleHQubGVuZ3RoLCBjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IGRpZmZUeXBlID09PSBESUZGX0RFTEVURSA/IChhZGp1c3RPZmZzZXRCeSAtPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCAtPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnMuc2xpY2UoaW5kZXgpLmV2ZXJ5KChbZFR5cGVdKSA9PiBkVHlwZSA9PT0gRElGRl9FUVVBTCkgfHwgKGNoYW5nZWRPZmZzZXQgKz0gdGV4dC5sZW5ndGgpKTtcbiAgICAgIH0pLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcImluc2VydF90ZXh0XCIgJiYgY2hhbmdlZE9mZnNldCA8IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPD0gdHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0IC0gdHJhbnNmb3JtZWRPcGVyYXRpb24udGV4dC5sZW5ndGggJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5hbmNob3JcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgICAgICB9IDogdm9pZCAwLCBuZXdBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDA7XG4gICAgICAgIChjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciB8fCBuZXdGb2N1cyAmJiBuZXdBbmNob3IpICYmIChbY3VycmVudEZvY3VzLCBjdXJyZW50QW5jaG9yLCBuZXdGb2N1cywgbmV3QW5jaG9yXS5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgIHBvaW50ICYmIGNoYW5nZWRPZmZzZXQgPCBwb2ludC5vZmZzZXQgJiYgKHBvaW50Lm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSk7XG4gICAgICAgIH0pLCBjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgICAgIGFuY2hvcjogY3VycmVudEFuY2hvclxuICAgICAgICB9KSwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSksIFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl0pO1xuICB9XG4gIHJldHVybiBbdHJhbnNmb3JtZWRPcGVyYXRpb25dO1xufVxuZnVuY3Rpb24gYWRqdXN0QmxvY2tQYXRoKG9wZXJhdGlvbiwgbGV2ZWwsIGJsb2NrSW5kZXgpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRPcGVyYXRpb24gPSB7XG4gICAgLi4ub3BlcmF0aW9uXG4gIH07XG4gIGlmIChibG9ja0luZGV4ID49IDAgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdICsgbGV2ZWwgPiAtMSkge1xuICAgIGNvbnN0IG5ld1BhdGggPSBbdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsLCAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoLnNsaWNlKDEpXTtcbiAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoID0gbmV3UGF0aDtcbiAgfVxuICBpZiAodHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHtcbiAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuZm9jdXNcbiAgICB9IDogdm9pZCAwLCBjdXJyZW50QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/LnByb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgfSA6IHZvaWQgMCwgbmV3Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ubmV3UHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuYW5jaG9yXG4gICAgfSA6IHZvaWQgMDtcbiAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgIHBvaW50ICYmIHBvaW50LnBhdGhbMF0gPj0gYmxvY2tJbmRleCArIGxldmVsICYmIHBvaW50LnBhdGhbMF0gKyBsZXZlbCA+IC0xICYmIChwb2ludC5wYXRoID0gW3BvaW50LnBhdGhbMF0gKyBsZXZlbCwgLi4ucG9pbnQucGF0aC5zbGljZSgxKV0pO1xuICAgIH0pLCBjdXJyZW50Rm9jdXMgJiYgY3VycmVudEFuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBjdXJyZW50Rm9jdXMsXG4gICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICB9KSwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzID0ge1xuICAgICAgZm9jdXM6IG5ld0ZvY3VzLFxuICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVkT3BlcmF0aW9uO1xufVxuY29uc3Qgc2hvdWxkTWVyZ2UgPSAob3AsIHByZXYpID0+ICEhKG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIG9wLm9mZnNldCA9PT0gcHJldi5vZmZzZXQgKyBwcmV2LnRleHQubGVuZ3RoICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkgJiYgb3AudGV4dCAhPT0gXCIgXCIgfHwgcHJldiAmJiBvcC50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgcHJldi50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgb3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPT09IHByZXYub2Zmc2V0ICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHByZXYucGF0aCkpLCBzaG91bGRPdmVyd3JpdGUgPSAob3AsIHByZXYpID0+ICEhKHByZXYgJiYgb3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgcHJldi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiksIHNob3VsZENsZWFyID0gKG9wKSA9PiBvcC50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIjtcbmZ1bmN0aW9uIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNTYXZpbmcoZWRpdG9yKTtcbiAgU0FWSU5HLnNldChlZGl0b3IsICExKSwgZm4oKSwgU0FWSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0T3BlcmF0aW9uKGVkaXRvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0X3NlbGVjdGlvblwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIC4uLmVkaXRvci5zZWxlY3Rpb25cbiAgICB9LFxuICAgIG5ld1Byb3BlcnRpZXM6IHtcbiAgICAgIC4uLmVkaXRvci5zZWxlY3Rpb25cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kT3BlcmF0aW9uVGFyZ2V0QmxvY2soZWRpdG9yLCBvcGVyYXRpb24pIHtcbiAgbGV0IGJsb2NrO1xuICByZXR1cm4gb3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIGVkaXRvci5zZWxlY3Rpb24gPyBibG9jayA9IGVkaXRvci5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF1dIDogXCJwYXRoXCIgaW4gb3BlcmF0aW9uICYmIChibG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0pLCBibG9jaztcbn1cbmNvbnN0IHN5bmNWYWx1ZUNhbGxiYWNrID0gKHtcbiAgc2VuZEJhY2ssXG4gIGlucHV0XG59KSA9PiB7XG4gIHVwZGF0ZVZhbHVlKHtcbiAgICBjb250ZXh0OiBpbnB1dC5jb250ZXh0LFxuICAgIHNlbmRCYWNrLFxuICAgIHNsYXRlRWRpdG9yOiBpbnB1dC5zbGF0ZUVkaXRvcixcbiAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgc3RyZWFtQmxvY2tzOiBpbnB1dC5zdHJlYW1CbG9ja3NcbiAgfSk7XG59LCBzeW5jVmFsdWVMb2dpYyA9IGZyb21DYWxsYmFjayhzeW5jVmFsdWVDYWxsYmFjayksIHN5bmNNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGlucHV0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiOiBhc3NpZ24oe1xuICAgICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMFxuICAgIH0pLFxuICAgIFwiYXNzaWduIHJlYWRPbmx5XCI6IGFzc2lnbih7XG4gICAgICByZWFkT25seTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgcmVhZE9ubHlcIiksIGV2ZW50LnJlYWRPbmx5KVxuICAgIH0pLFxuICAgIFwiYXNzaWduIHBlbmRpbmcgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgdmFsdWVcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDBcbiAgICB9KSxcbiAgICBcImFzc2lnbiBwcmV2aW91cyB2YWx1ZVwiOiBhc3NpZ24oe1xuICAgICAgcHJldmlvdXNWYWx1ZTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJkb25lIHN5bmNpbmdcIiksIGV2ZW50LnZhbHVlKVxuICAgIH0pLFxuICAgIFwiZW1pdCBkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIlxuICAgIH0pXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxWYWx1ZVN5bmNlZCxcbiAgICBcImlzIGJ1c3lcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiAhY29udGV4dC5yZWFkT25seSAmJiAoY29udGV4dC5pc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMgfHwgKGlzQ2hhbmdpbmdSZW1vdGVseShjb250ZXh0LnNsYXRlRWRpdG9yKSA/PyAhMSkpLFxuICAgIFwidmFsdWUgY2hhbmdlZCB3aGlsZSBzeW5jaW5nXCI6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBjb250ZXh0LnBlbmRpbmdWYWx1ZSAhPT0gZXZlbnQudmFsdWUpLFxuICAgIFwicGVuZGluZyB2YWx1ZSBlcXVhbHMgcHJldmlvdXMgdmFsdWVcIjogKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiAhKGNvbnRleHQucHJldmlvdXNWYWx1ZSA9PT0gdm9pZCAwICYmIGNvbnRleHQucGVuZGluZ1ZhbHVlID09PSB2b2lkIDApICYmIGlzRXF1YWwoY29udGV4dC5wZW5kaW5nVmFsdWUsIGNvbnRleHQucHJldmlvdXNWYWx1ZSlcbiAgfSxcbiAgYWN0b3JzOiB7XG4gICAgXCJzeW5jIHZhbHVlXCI6IHN5bmNWYWx1ZUxvZ2ljXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICBpZDogXCJzeW5jXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBpbml0aWFsVmFsdWVTeW5jZWQ6ICExLFxuICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlczogITEsXG4gICAga2V5R2VuZXJhdG9yOiBpbnB1dC5rZXlHZW5lcmF0b3IsXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgcmVhZE9ubHk6IGlucHV0LnJlYWRPbmx5LFxuICAgIHNsYXRlRWRpdG9yOiBpbnB1dC5zbGF0ZUVkaXRvcixcbiAgICBwZW5kaW5nVmFsdWU6IHZvaWQgMCxcbiAgICBwcmV2aW91c1ZhbHVlOiB2b2lkIDBcbiAgfSksXG4gIG9uOiB7XG4gICAgXCJoYXMgcGVuZGluZyBwYXRjaGVzXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlczogITBcbiAgICAgIH0pXG4gICAgfSxcbiAgICBtdXRhdGlvbjoge1xuICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzOiAhMVxuICAgICAgfSlcbiAgICB9LFxuICAgIFwidXBkYXRlIHJlYWRPbmx5XCI6IHtcbiAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiByZWFkT25seVwiXVxuICAgIH1cbiAgfSxcbiAgdHlwZTogXCJwYXJhbGxlbFwiLFxuICBzdGF0ZXM6IHtcbiAgICBcInNldHRpbmcgdXBcIjoge1xuICAgICAgaW5pdGlhbDogXCJzeW5jaW5nIGluaXRpYWwgdmFsdWVcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBcInN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiB7XG4gICAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgICBndWFyZDogXCJpbml0aWFsIHZhbHVlIHN5bmNlZFwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjoge1xuICAgICAgICAgIGVudHJ5OiBbXCJlbWl0IGRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCJdLFxuICAgICAgICAgIHR5cGU6IFwiZmluYWxcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzeW5jaW5nOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IFt7XG4gICAgICAgICAgICAgIGd1YXJkOiBcImlzIGJ1c3lcIixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcImJ1c3lcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInN5bmNpbmdcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBidXN5OiB7XG4gICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgIDFlMzogW3tcbiAgICAgICAgICAgICAgZ3VhcmQ6IFwiaXMgYnVzeVwiLFxuICAgICAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwic3luY2luZ1wiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IFt7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3luY2luZzoge1xuICAgICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgZ3VhcmQ6IFwicGVuZGluZyB2YWx1ZSBlcXVhbHMgcHJldmlvdXMgdmFsdWVcIixcbiAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXCJjbGVhciBwZW5kaW5nIHZhbHVlXCIsIFwiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCJdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnZva2U6IHtcbiAgICAgICAgICAgIHNyYzogXCJzeW5jIHZhbHVlXCIsXG4gICAgICAgICAgICBpZDogXCJzeW5jIHZhbHVlXCIsXG4gICAgICAgICAgICBpbnB1dDogKHtcbiAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIGtleUdlbmVyYXRvcjogY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogY29udGV4dC5wcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiBjb250ZXh0LnJlYWRPbmx5LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2xhdGVFZGl0b3I6IGNvbnRleHQuc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICAgIHN0cmVhbUJsb2NrczogIWNvbnRleHQuaW5pdGlhbFZhbHVlU3luY2VkLFxuICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dC5wZW5kaW5nVmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgdmFsdWVcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaW52YWxpZCB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidmFsdWUgY2hhbmdlZFwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZG9uZSBzeW5jaW5nXCI6IFt7XG4gICAgICAgICAgICAgIGd1YXJkOiBcInZhbHVlIGNoYW5nZWQgd2hpbGUgc3luY2luZ1wiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIiwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIl0sXG4gICAgICAgICAgICAgIHJlZW50ZXI6ICEwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJpZGxlXCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImNsZWFyIHBlbmRpbmcgdmFsdWVcIiwgXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIiwgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIl1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgZGVidWckaCA9IGRlYnVnV2l0aE5hbWUoXCJob29rOnVzZVN5bmNWYWx1ZVwiKTtcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKHtcbiAgY29udGV4dCxcbiAgc2VuZEJhY2ssXG4gIHNsYXRlRWRpdG9yLFxuICBzdHJlYW1CbG9ja3MsXG4gIHZhbHVlXG59KSB7XG4gIGxldCBpc0NoYW5nZWQgPSAhMSwgaXNWYWxpZCA9ICEwO1xuICBjb25zdCBoYWRTZWxlY3Rpb24gPSAhIXNsYXRlRWRpdG9yLnNlbGVjdGlvbjtcbiAgaWYgKCghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSAmJiAoZGVidWckaChcIlZhbHVlIGlzIGVtcHR5XCIpLCBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgd2l0aG91dFNhdmluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGhhZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IFtjaGlsZHJlbkxlbmd0aCAtIDEgLSBpbmRleF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgfSksIHtcbiAgICAgICAgICBhdDogWzBdXG4gICAgICAgIH0pLCBoYWRTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIGlzQ2hhbmdlZCA9ICEwKSwgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNsYXRlVmFsdWVGcm9tUHJvcHMgPSB0b1NsYXRlVmFsdWUodmFsdWUsIHtcbiAgICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICAgIH0pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCA8IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbkxlbmd0aCAtIDE7IGkgPiBzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCAtIDE7IGktLSlcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBhdDogW2ldXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlzQ2hhbmdlZCA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBbY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleF0gb2YgZ2V0QmxvY2tzKHtcbiAgICAgICAgICAgICAgc2xhdGVWYWx1ZTogc2xhdGVWYWx1ZUZyb21Qcm9wcyxcbiAgICAgICAgICAgICAgc3RyZWFtQmxvY2tzXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgYmxvY2tDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGJsb2NrVmFsaWRcbiAgICAgICAgICAgICAgfSA9IHN5bmNCbG9jayh7XG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBzZW5kQmFjayxcbiAgICAgICAgICAgICAgICBibG9jazogY3VycmVudEJsb2NrLFxuICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50QmxvY2tJbmRleCxcbiAgICAgICAgICAgICAgICBzbGF0ZUVkaXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gYmxvY2tDaGFuZ2VkIHx8IGlzQ2hhbmdlZCwgaXNWYWxpZCA9IGlzVmFsaWQgJiYgYmxvY2tWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIWlzVmFsaWQpIHtcbiAgICBkZWJ1ZyRoKFwiSW52YWxpZCB2YWx1ZSwgcmV0dXJuaW5nXCIpLCBzZW5kQmFjayh7XG4gICAgICB0eXBlOiBcImRvbmUgc3luY2luZ1wiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQ2hhbmdlZCkge1xuICAgIGRlYnVnJGgoXCJTZXJ2ZXIgdmFsdWUgY2hhbmdlZCwgc3luY2luZyBlZGl0b3JcIik7XG4gICAgdHJ5IHtcbiAgICAgIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVyciksIHNlbmRCYWNrKHtcbiAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgIHJlc29sdXRpb246IG51bGwsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSwgc2VuZEJhY2soe1xuICAgICAgICB0eXBlOiBcImRvbmUgc3luY2luZ1wiLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhZFNlbGVjdGlvbiAmJiAhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSksIHNlbmRCYWNrKHtcbiAgICAgIHR5cGU6IFwidmFsdWUgY2hhbmdlZFwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlXG4gICAgZGVidWckaChcIlNlcnZlciB2YWx1ZSBhbmQgZWRpdG9yIHZhbHVlIGlzIGVxdWFsLCBubyBuZWVkIHRvIHN5bmMuXCIpO1xuICBzZW5kQmFjayh7XG4gICAgdHlwZTogXCJkb25lIHN5bmNpbmdcIixcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBnZXRCbG9ja3Moe1xuICBzbGF0ZVZhbHVlLFxuICBzdHJlYW1CbG9ja3Ncbn0pIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiBzbGF0ZVZhbHVlKVxuICAgIHN0cmVhbUJsb2NrcyAmJiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSksIHlpZWxkIFtibG9jaywgaW5kZXhdLCBpbmRleCsrO1xufVxuZnVuY3Rpb24gc3luY0Jsb2NrKHtcbiAgY29udGV4dCxcbiAgc2VuZEJhY2ssXG4gIGJsb2NrLFxuICBpbmRleCxcbiAgc2xhdGVFZGl0b3IsXG4gIHZhbHVlXG59KSB7XG4gIGxldCBibG9ja0NoYW5nZWQgPSAhMSwgYmxvY2tWYWxpZCA9ICEwO1xuICBjb25zdCBjdXJyZW50QmxvY2sgPSBibG9jaywgY3VycmVudEJsb2NrSW5kZXggPSBpbmRleCwgb2xkQmxvY2sgPSBzbGF0ZUVkaXRvci5jaGlsZHJlbltjdXJyZW50QmxvY2tJbmRleF0sIGhhc0NoYW5nZXMgPSBvbGRCbG9jayAmJiAhaXNFcXVhbChjdXJyZW50QmxvY2ssIG9sZEJsb2NrKTtcbiAgcmV0dXJuIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICB3aXRoUmVtb3RlQ2hhbmdlcyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VzICYmIGJsb2NrVmFsaWQpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWUgPSBbdmFsdWVbY3VycmVudEJsb2NrSW5kZXhdXSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlLCBjb250ZXh0LnNjaGVtYSwgY29udGV4dC5rZXlHZW5lcmF0b3IpO1xuICAgICAgICAgICF2YWxpZGF0aW9uLnZhbGlkICYmIHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgJiYgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5wYXRjaGVzLmxlbmd0aCA+IDAgJiYgIWNvbnRleHQucmVhZE9ubHkgJiYgY29udGV4dC5wcmV2aW91c1ZhbHVlICYmIGNvbnRleHQucHJldmlvdXNWYWx1ZSAhPT0gdmFsdWUgJiYgKGNvbnNvbGUud2FybihgJHt2YWxpZGF0aW9uLnJlc29sdXRpb24uYWN0aW9ufSBmb3IgYmxvY2sgd2l0aCBfa2V5ICcke3ZhbGlkYXRpb25WYWx1ZVswXS5fa2V5fScuICR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5kZXNjcmlwdGlvbn1gKSwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uLnBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlbmRCYWNrKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICAgICAgICBwYXRjaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkpLCB2YWxpZGF0aW9uLnZhbGlkIHx8IHZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgPyAob2xkQmxvY2suX2tleSA9PT0gY3VycmVudEJsb2NrLl9rZXkgPyAoZGVidWckaC5lbmFibGVkICYmIGRlYnVnJGgoXCJVcGRhdGluZyBibG9ja1wiLCBvbGRCbG9jaywgY3VycmVudEJsb2NrKSwgX3VwZGF0ZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIG9sZEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkpIDogKGRlYnVnJGguZW5hYmxlZCAmJiBkZWJ1ZyRoKFwiUmVwbGFjaW5nIGJsb2NrXCIsIG9sZEJsb2NrLCBjdXJyZW50QmxvY2spLCBfcmVwbGFjZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSksIGJsb2NrQ2hhbmdlZCA9ICEwKSA6IChzZW5kQmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IHZhbGlkYXRpb24ucmVzb2x1dGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksIGJsb2NrVmFsaWQgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRCbG9jayAmJiBibG9ja1ZhbGlkKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvblZhbHVlID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZSwgY29udGV4dC5zY2hlbWEsIGNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICBkZWJ1ZyRoLmVuYWJsZWQgJiYgZGVidWckaChcIlZhbGlkYXRpbmcgYW5kIGluc2VydGluZyBuZXcgYmxvY2sgaW4gdGhlIGVuZCBvZiB0aGUgdmFsdWVcIiwgY3VycmVudEJsb2NrKSwgdmFsaWRhdGlvbi52YWxpZCB8fCB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICAgICAgICAgIH0pIDogKGRlYnVnJGgoXCJJbnZhbGlkXCIsIHZhbGlkYXRpb24pLCBzZW5kQmFjayh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IHZhbGlkYXRpb24ucmVzb2x1dGlvbixcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksIGJsb2NrVmFsaWQgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSwge1xuICAgIGJsb2NrQ2hhbmdlZCxcbiAgICBibG9ja1ZhbGlkXG4gIH07XG59XG5mdW5jdGlvbiBfcmVwbGFjZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvbkZvY3VzT25CbG9jayA9IGN1cnJlbnRTZWxlY3Rpb24gJiYgY3VycmVudFNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdID09PSBjdXJyZW50QmxvY2tJbmRleDtcbiAgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpLCBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIGN1cnJlbnRTZWxlY3Rpb24pO1xufVxuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIG9sZEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkge1xuICBpZiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7XG4gICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgfSksIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKGN1cnJlbnRCbG9jaykgJiYgc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgY29uc3Qgb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCA9IG9sZEJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBjdXJyZW50QmxvY2suY2hpbGRyZW4ubGVuZ3RoIDwgb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAmJiBBcnJheS5mcm9tKEFycmF5KG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggLSBjdXJyZW50QmxvY2suY2hpbGRyZW4ubGVuZ3RoKSkuZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gMSAtIGluZGV4O1xuICAgICAgY2hpbGRJbmRleCA+IDAgJiYgKGRlYnVnJGgoXCJSZW1vdmluZyBjaGlsZFwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjaGlsZEluZGV4XVxuICAgICAgfSkpO1xuICAgIH0pLCBjdXJyZW50QmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoY3VycmVudEJsb2NrQ2hpbGQsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGQgPSBvbGRCbG9jay5jaGlsZHJlbltjdXJyZW50QmxvY2tDaGlsZEluZGV4XSwgaXNDaGlsZENoYW5nZWQgPSAhaXNFcXVhbChjdXJyZW50QmxvY2tDaGlsZCwgb2xkQmxvY2tDaGlsZCksIGlzVGV4dENoYW5nZWQgPSAhaXNFcXVhbChjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCBvbGRCbG9ja0NoaWxkPy50ZXh0KSwgcGF0aCA9IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF07XG4gICAgICBpZiAoaXNDaGlsZENoYW5nZWQpXG4gICAgICAgIGlmIChjdXJyZW50QmxvY2tDaGlsZC5fa2V5ID09PSBvbGRCbG9ja0NoaWxkPy5fa2V5KSB7XG4gICAgICAgICAgZGVidWckaChcIlVwZGF0aW5nIGNoYW5nZWQgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpc1NwYW5Ob2RlID0gVGV4dC5pc1RleHQoY3VycmVudEJsb2NrQ2hpbGQpICYmIGN1cnJlbnRCbG9ja0NoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiBUZXh0LmlzVGV4dChvbGRCbG9ja0NoaWxkKSAmJiBvbGRCbG9ja0NoaWxkLl90eXBlID09PSBcInNwYW5cIjtcbiAgICAgICAgICBpc1NwYW5Ob2RlICYmIGlzVGV4dENoYW5nZWQgPyAoVHJhbnNmb3Jtcy5kZWxldGUoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9sZEJsb2NrQ2hpbGQudGV4dC5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydFRleHQoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLnRleHQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpIDogaXNTcGFuTm9kZSB8fCAoZGVidWckaChcIlVwZGF0aW5nIGNoYW5nZWQgaW5saW5lIG9iamVjdCBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIF9rZXk6IFZPSURfQ0hJTERfS0VZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCAwXSxcbiAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIG9sZEJsb2NrQ2hpbGQgPyAoZGVidWckaChcIlJlcGxhY2luZyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSkgOiBvbGRCbG9ja0NoaWxkIHx8IChkZWJ1ZyRoKFwiSW5zZXJ0aW5nIG5ldyBjaGlsZFwiLCBjdXJyZW50QmxvY2tDaGlsZCksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBkZWJ1ZyRnID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3I6U3luY2hyb25pemVyXCIpO1xuZnVuY3Rpb24gU3luY2hyb25pemVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQwKSwge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHNsYXRlRWRpdG9yXG4gIH0gPSBwcm9wcywgdmFsdWUgPSB1c2VTZWxlY3Rvcihwcm9wcy5lZGl0b3JBY3RvciwgX3RlbXApLCByZWFkT25seSA9IHVzZVNlbGVjdG9yKHByb3BzLmVkaXRvckFjdG9yLCBfdGVtcDIpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQwID0gcHJvcHMuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSwgJFswXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCB0MSA9IHQwLmNvbnRleHQua2V5R2VuZXJhdG9yO1xuICBsZXQgdDI7XG4gICRbMl0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQyID0gcHJvcHMuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gIH0pLCAkWzJdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbM10gPSB0MikgOiB0MiA9ICRbM107XG4gIGxldCB0MztcbiAgJFs0XSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDMgPSBwcm9wcy5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLCAkWzRdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbNV0gPSB0MykgOiB0MyA9ICRbNV07XG4gIGxldCB0NDtcbiAgJFs2XSAhPT0gc2xhdGVFZGl0b3IgfHwgJFs3XSAhPT0gdDAuY29udGV4dC5rZXlHZW5lcmF0b3IgfHwgJFs4XSAhPT0gdDIgfHwgJFs5XSAhPT0gdDMuY29udGV4dC5zY2hlbWEgPyAodDQgPSB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIGtleUdlbmVyYXRvcjogdDEsXG4gICAgICByZWFkT25seTogdDIsXG4gICAgICBzY2hlbWE6IHQzLmNvbnRleHQuc2NoZW1hLFxuICAgICAgc2xhdGVFZGl0b3JcbiAgICB9XG4gIH0sICRbNl0gPSBzbGF0ZUVkaXRvciwgJFs3XSA9IHQwLmNvbnRleHQua2V5R2VuZXJhdG9yLCAkWzhdID0gdDIsICRbOV0gPSB0My5jb250ZXh0LnNjaGVtYSwgJFsxMF0gPSB0NCkgOiB0NCA9ICRbMTBdO1xuICBjb25zdCBzeW5jQWN0b3JSZWYgPSB1c2VBY3RvclJlZihzeW5jTWFjaGluZSwgdDQpO1xuICBsZXQgdDU7XG4gICRbMTFdICE9PSBlZGl0b3JBY3RvciA/ICh0NSA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCksICRbMTFdID0gZWRpdG9yQWN0b3IsICRbMTJdID0gdDUpIDogdDUgPSAkWzEyXTtcbiAgbGV0IHQ2O1xuICAkWzEzXSAhPT0gc2xhdGVFZGl0b3IgfHwgJFsxNF0gIT09IHQ1LmNvbnRleHQuc2NoZW1hID8gKHQ2ID0ge1xuICAgIGlucHV0OiB7XG4gICAgICBzY2hlbWE6IHQ1LmNvbnRleHQuc2NoZW1hLFxuICAgICAgc2xhdGVFZGl0b3JcbiAgICB9XG4gIH0sICRbMTNdID0gc2xhdGVFZGl0b3IsICRbMTRdID0gdDUuY29udGV4dC5zY2hlbWEsICRbMTVdID0gdDYpIDogdDYgPSAkWzE1XTtcbiAgY29uc3QgbXV0YXRpb25BY3RvclJlZiA9IHVzZUFjdG9yUmVmKG11dGF0aW9uTWFjaGluZSwgdDYpO1xuICBsZXQgdDcsIHQ4O1xuICAkWzE2XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxN10gIT09IG11dGF0aW9uQWN0b3JSZWYgfHwgJFsxOF0gIT09IHN5bmNBY3RvclJlZiA/ICh0NyA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBtdXRhdGlvbkFjdG9yUmVmLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnR5cGUgPT09IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiICYmIHN5bmNBY3RvclJlZi5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJoYXMgcGVuZGluZyBwYXRjaGVzXCJcbiAgICAgIH0pLCBldmVudC50eXBlID09PSBcIm11dGF0aW9uXCIgJiYgKHN5bmNBY3RvclJlZi5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiXG4gICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibXV0YXRpb25cIixcbiAgICAgICAgcGF0Y2hlczogZXZlbnQucGF0Y2hlcyxcbiAgICAgICAgc25hcHNob3Q6IGV2ZW50LnNuYXBzaG90LFxuICAgICAgICB2YWx1ZTogZXZlbnQuc25hcHNob3RcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDggPSBbbXV0YXRpb25BY3RvclJlZiwgc3luY0FjdG9yUmVmLCBlZGl0b3JBY3Rvcl0sICRbMTZdID0gZWRpdG9yQWN0b3IsICRbMTddID0gbXV0YXRpb25BY3RvclJlZiwgJFsxOF0gPSBzeW5jQWN0b3JSZWYsICRbMTldID0gdDcsICRbMjBdID0gdDgpIDogKHQ3ID0gJFsxOV0sIHQ4ID0gJFsyMF0pLCB1c2VFZmZlY3QodDcsIHQ4KTtcbiAgbGV0IHQxMCwgdDk7XG4gICRbMjFdICE9PSBwcm9wcy5lZGl0b3JBY3RvciB8fCAkWzIyXSAhPT0gc3luY0FjdG9yUmVmID8gKHQ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbl8wID0gc3luY0FjdG9yUmVmLm9uKFwiKlwiLCAoZXZlbnRfMCkgPT4ge1xuICAgICAgcHJvcHMuZWRpdG9yQWN0b3Iuc2VuZChldmVudF8wKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uXzAudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MTAgPSBbcHJvcHMuZWRpdG9yQWN0b3IsIHN5bmNBY3RvclJlZl0sICRbMjFdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMjJdID0gc3luY0FjdG9yUmVmLCAkWzIzXSA9IHQxMCwgJFsyNF0gPSB0OSkgOiAodDEwID0gJFsyM10sIHQ5ID0gJFsyNF0pLCB1c2VFZmZlY3QodDksIHQxMCk7XG4gIGxldCB0MTEsIHQxMjtcbiAgJFsyNV0gIT09IHJlYWRPbmx5IHx8ICRbMjZdICE9PSBzeW5jQWN0b3JSZWYgPyAodDExID0gKCkgPT4ge1xuICAgIHN5bmNBY3RvclJlZi5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIHJlYWRPbmx5XCIsXG4gICAgICByZWFkT25seVxuICAgIH0pO1xuICB9LCB0MTIgPSBbc3luY0FjdG9yUmVmLCByZWFkT25seV0sICRbMjVdID0gcmVhZE9ubHksICRbMjZdID0gc3luY0FjdG9yUmVmLCAkWzI3XSA9IHQxMSwgJFsyOF0gPSB0MTIpIDogKHQxMSA9ICRbMjddLCB0MTIgPSAkWzI4XSksIHVzZUVmZmVjdCh0MTEsIHQxMik7XG4gIGxldCB0MTMsIHQxNDtcbiAgJFsyOV0gIT09IHN5bmNBY3RvclJlZiB8fCAkWzMwXSAhPT0gdmFsdWUgPyAodDEzID0gKCkgPT4ge1xuICAgIGRlYnVnJGcoXCJWYWx1ZSBmcm9tIHByb3BzIGNoYW5nZWQsIHN5bmNpbmcgbmV3IHZhbHVlXCIpLCBzeW5jQWN0b3JSZWYuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSB2YWx1ZVwiLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSwgdDE0ID0gW3N5bmNBY3RvclJlZiwgdmFsdWVdLCAkWzI5XSA9IHN5bmNBY3RvclJlZiwgJFszMF0gPSB2YWx1ZSwgJFszMV0gPSB0MTMsICRbMzJdID0gdDE0KSA6ICh0MTMgPSAkWzMxXSwgdDE0ID0gJFszMl0pLCB1c2VFZmZlY3QodDEzLCB0MTQpO1xuICBsZXQgdDE1O1xuICAkWzMzXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFszNF0gIT09IG11dGF0aW9uQWN0b3JSZWYgPyAodDE1ID0gKCkgPT4ge1xuICAgIGRlYnVnJGcoXCJTdWJzY3JpYmluZyB0byBwYXRjaCBldmVudHNcIik7XG4gICAgY29uc3Qgc3ViID0gZWRpdG9yQWN0b3Iub24oXCJwYXRjaFwiLCAoZXZlbnRfMSkgPT4ge1xuICAgICAgbXV0YXRpb25BY3RvclJlZi5zZW5kKGV2ZW50XzEpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWJ1ZyRnKFwiVW5zdWJzY3JpYmluZyB0byBwYXRjaCBldmVudHNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sICRbMzNdID0gZWRpdG9yQWN0b3IsICRbMzRdID0gbXV0YXRpb25BY3RvclJlZiwgJFszNV0gPSB0MTUpIDogdDE1ID0gJFszNV07XG4gIGxldCB0MTY7XG4gIHJldHVybiAkWzM2XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFszN10gIT09IG11dGF0aW9uQWN0b3JSZWYgfHwgJFszOF0gIT09IHNsYXRlRWRpdG9yID8gKHQxNiA9IFtlZGl0b3JBY3RvciwgbXV0YXRpb25BY3RvclJlZiwgc2xhdGVFZGl0b3JdLCAkWzM2XSA9IGVkaXRvckFjdG9yLCAkWzM3XSA9IG11dGF0aW9uQWN0b3JSZWYsICRbMzhdID0gc2xhdGVFZGl0b3IsICRbMzldID0gdDE2KSA6IHQxNiA9ICRbMzldLCB1c2VFZmZlY3QodDE1LCB0MTYpLCBudWxsO1xufVxuZnVuY3Rpb24gX3RlbXAyKHNfMCkge1xuICByZXR1cm4gc18wLm1hdGNoZXMoe1xuICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgfSk7XG59XG5mdW5jdGlvbiBfdGVtcChzKSB7XG4gIHJldHVybiBzLmNvbnRleHQudmFsdWU7XG59XG5TeW5jaHJvbml6ZXIuZGlzcGxheU5hbWUgPSBcIlN5bmNocm9uaXplclwiO1xuY29uc3QgZGVidWckZiA9IGRlYnVnV2l0aE5hbWUoXCJvcGVyYXRpb25Ub1BhdGNoZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVPcGVyYXRpb25Ub1BhdGNoZXModHlwZXMpIHtcbiAgY29uc3QgdGV4dEJsb2NrTmFtZSA9IHR5cGVzLmJsb2NrLm5hbWU7XG4gIGZ1bmN0aW9uIGluc2VydFRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBkZWJ1ZyRmLmVuYWJsZWQgJiYgZGVidWckZihcIk9wZXJhdGlvblwiLCBKU09OLnN0cmluZ2lmeShvcGVyYXRpb24sIG51bGwsIDIpKTtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvci5pc1RleHRCbG9jayhlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCB0ZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSkgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICAgIH0sIFwidGV4dFwiXSwgcHJldkJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCBwcmV2Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2socHJldkJsb2NrKSAmJiBwcmV2QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dLCBwcmV2VGV4dCA9IGVkaXRvci5pc1RleHRTcGFuKHByZXZDaGlsZCkgPyBwcmV2Q2hpbGQudGV4dCA6IFwiXCIsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCwgdGV4dENoaWxkLnRleHQsIHBhdGgpO1xuICAgIHJldHVybiBwYXRjaC52YWx1ZS5sZW5ndGggPyBbcGF0Y2hdIDogW107XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yICYmIGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKCFibG9jaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGJsb2NrXCIpO1xuICAgIGNvbnN0IGNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gfHwgdm9pZCAwLCB0ZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgPyBjaGlsZCA6IHZvaWQgMDtcbiAgICBpZiAoY2hpbGQgJiYgIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW5cIik7XG4gICAgaWYgKCF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBjaGlsZFwiKTtcbiAgICBjb25zdCBwYXRoID0gW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IHRleHRDaGlsZC5fa2V5XG4gICAgfSwgXCJ0ZXh0XCJdLCBiZWZvcmVCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldlRleHRDaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhiZWZvcmVCbG9jaykgJiYgYmVmb3JlQmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dLCBwcmV2VGV4dCA9IGVkaXRvci5pc1RleHRTcGFuKHByZXZUZXh0Q2hpbGQpICYmIHByZXZUZXh0Q2hpbGQudGV4dCwgcGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaCQxKHByZXZUZXh0IHx8IFwiXCIsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUgPyBbcGF0Y2hdIDogW107XG4gIH1cbiAgZnVuY3Rpb24gc2V0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKHR5cGVvZiBibG9jay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGJsb2NrIHRvIGhhdmUgYSBfa2V5XCIpO1xuICAgICAgY29uc3Qgc2V0Tm9kZSA9IG9taXRCeSh7XG4gICAgICAgIC4uLmVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV0sXG4gICAgICAgIC4uLm9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzXG4gICAgICB9LCBpc1VuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gW3NldChmcm9tU2xhdGVWYWx1ZShbc2V0Tm9kZV0sIHRleHRCbG9ja05hbWUpWzBdLCBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSldO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBibG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgY29uc3QgYmxvY2tLZXkgPSBibG9jay5fa2V5LCBjaGlsZEtleSA9IGNoaWxkLl9rZXksIHBhdGNoZXMgPSBbXSwga2V5cyA9IE9iamVjdC5rZXlzKG9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICByZXR1cm4ga2V5cy5mb3JFYWNoKChrZXlOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5TmFtZSA9PT0gXCJfa2V5XCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gZ2V0KG9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLCBrZXlOYW1lKTtcbiAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHNldCh2YWwsIFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2tLZXlcbiAgICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCBibG9jay5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSwga2V5TmFtZV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICAgIHBhdGNoZXMucHVzaChzZXQodmFsLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkS2V5XG4gICAgICAgICAgICAgIH0sIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHBhdGNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBjaGlsZFwiKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgYmxvY2tcIik7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcGF0aCBlbmNvdW50ZXJlZDogJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24ucGF0aCl9YCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCBpc1RleHRCbG9jayA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jayk7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIsIGJlZm9yZUJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF0gLSAxXSwgdGFyZ2V0S2V5ID0gb3BlcmF0aW9uLnBhdGhbMF0gPT09IDAgPyBibG9jaz8uX2tleSA6IGJlZm9yZUJsb2NrPy5fa2V5O1xuICAgICAgcmV0dXJuIHRhcmdldEtleSA/IFtpbnNlcnQoW2Zyb21TbGF0ZVZhbHVlKFtvcGVyYXRpb24ubm9kZV0sIHRleHRCbG9ja05hbWUpWzBdXSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IHRhcmdldEtleVxuICAgICAgfV0pXSA6IFtzZXRJZk1pc3NpbmcoYmVmb3JlVmFsdWUsIFtdKSwgaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbb3BlcmF0aW9uLm5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIFwiYmVmb3JlXCIsIFtvcGVyYXRpb24ucGF0aFswXV0pXTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dEJsb2NrICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCAhYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIsIG5vZGUgPSB7XG4gICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlXG4gICAgICB9O1xuICAgICAgIW5vZGUuX3R5cGUgJiYgVGV4dC5pc1RleHQobm9kZSkgJiYgKG5vZGUuX3R5cGUgPSBcInNwYW5cIiwgbm9kZS5tYXJrcyA9IFtdKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gZnJvbVNsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogXCJib2d1c1wiLFxuICAgICAgICBfdHlwZTogdGV4dEJsb2NrTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IFtub2RlXVxuICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgcmV0dXJuIFtpbnNlcnQoW2NoaWxkXSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoIDw9IDEgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyAwIDoge1xuICAgICAgICBfa2V5OiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdLl9rZXlcbiAgICAgIH1dKV07XG4gICAgfVxuICAgIHJldHVybiBkZWJ1ZyRmKFwiU29tZXRoaW5nIHdhcyBpbnNlcnRlZCBpbnRvIGEgdm9pZCBibG9jay4gTm90IHByb2R1Y2luZyBlZGl0b3IgcGF0Y2hlcy5cIiksIFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgc3BsaXRCbG9jayA9IGVkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soc3BsaXRCbG9jaykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggcGF0aCAke0pTT04uc3RyaW5naWZ5KG9wZXJhdGlvbi5wYXRoWzBdKX0gaXMgbm90IGEgdGV4dCBibG9jayBhbmQgY2FuJ3QgYmUgc3BsaXRgKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBvbGRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZnJvbVNsYXRlVmFsdWUoW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSArIDFdXSwgdGV4dEJsb2NrTmFtZSlbMF07XG4gICAgICAgIHRhcmdldFZhbHVlICYmIChwYXRjaGVzLnB1c2goaW5zZXJ0KFt0YXJnZXRWYWx1ZV0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICBfa2V5OiBzcGxpdEJsb2NrLl9rZXlcbiAgICAgICAgfV0pKSwgb2xkQmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBvc2l0aW9uKS5mb3JFYWNoKChzcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICAgICAgICBfa2V5OiBvbGRCbG9jay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBwYXRjaGVzLnB1c2godW5zZXQocGF0aCkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICB9XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BsaXRTcGFuID0gc3BsaXRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oc3BsaXRTcGFuKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTcGFucyA9IGZyb21TbGF0ZVZhbHVlKFt7XG4gICAgICAgICAgLi4uc3BsaXRCbG9jayxcbiAgICAgICAgICBjaGlsZHJlbjogc3BsaXRCbG9jay5jaGlsZHJlbi5zbGljZShvcGVyYXRpb24ucGF0aFsxXSArIDEsIG9wZXJhdGlvbi5wYXRoWzFdICsgMilcbiAgICAgICAgfV0sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuO1xuICAgICAgICBwYXRjaGVzLnB1c2goaW5zZXJ0KHRhcmdldFNwYW5zLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaChzZXQoc3BsaXRTcGFuLnRleHQsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwbGl0U3Bhbi5fa2V5XG4gICAgICAgIH0sIFwidGV4dFwiXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgYmxvY2suX2tleSlcbiAgICAgICAgcmV0dXJuIFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIG5vdCBmb3VuZFwiKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBzcGFuVG9SZW1vdmUgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICByZXR1cm4gc3BhblRvUmVtb3ZlID8gYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IG9wZXJhdGlvbi5ub2RlLl9rZXkpLmxlbmd0aCA+IDEgPyAoY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtvcGVyYXRpb24ubm9kZS5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpLCBbXSkgOiBbdW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHNwYW5Ub1JlbW92ZS5fa2V5XG4gICAgICB9XSldIDogKGRlYnVnJGYoXCJTcGFuIG5vdCBmb3VuZCBpbiBlZGl0b3IgdHJ5aW5nIHRvIHJlbW92ZSBub2RlXCIpLCBbXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZGVidWckZihcIk5vdCBjcmVhdGluZyBwYXRjaCBpbnNpZGUgb2JqZWN0IGJsb2NrXCIpLCBbXTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB1cGRhdGVkQmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpXG4gICAgICBpZiAoYmxvY2s/Ll9rZXkpIHtcbiAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdIC0gMV1dLCB0ZXh0QmxvY2tOYW1lKVswXTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHNldChuZXdCbG9jaywgW3tcbiAgICAgICAgICBfa2V5OiBuZXdCbG9jay5fa2V5XG4gICAgICAgIH1dKSksIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV0pKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQga2V5IG5vdCBmb3VuZCFcIik7XG4gICAgZWxzZSBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2sodXBkYXRlZEJsb2NrKSAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTcGFuID0gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gJiYgZWRpdG9yLmlzVGV4dFNwYW4odXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0pID8gdXBkYXRlZEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gOiB2b2lkIDAsIHJlbW92ZWRTcGFuID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSkgPyBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gOiB2b2lkIDA7XG4gICAgICB1cGRhdGVkU3BhbiAmJiAoYmxvY2suY2hpbGRyZW4uZmlsdGVyKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IHVwZGF0ZWRTcGFuLl9rZXkpLmxlbmd0aCA9PT0gMSA/IHBhdGNoZXMucHVzaChzZXQodXBkYXRlZFNwYW4udGV4dCwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHVwZGF0ZWRTcGFuLl9rZXlcbiAgICAgIH0sIFwidGV4dFwiXSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHt1cGRhdGVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHVwZGF0ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKSwgcmVtb3ZlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSByZW1vdmVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIF9rZXk6IHJlbW92ZWRTcGFuLl9rZXlcbiAgICAgIH1dKSkgOiBjb25zb2xlLndhcm4oYE11bHRpcGxlIHNwYW5zIGhhdmUgXFxgX2tleVxcYCAke3JlbW92ZWRTcGFuLl9rZXl9LiBJdCdzIGFtYmlndW91cyB3aGljaCBvbmUgdG8gcmVtb3ZlLmAsIEpTT04uc3RyaW5naWZ5KGJsb2NrLCBudWxsLCAyKSkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckZihcIlZvaWQgbm9kZXMgY2FuJ3QgYmUgbWVyZ2VkLCBub3QgY3JlYXRpbmcgYW55IHBhdGNoZXNcIik7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgZnVuY3Rpb24gbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCB0YXJnZXRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5uZXdQYXRoWzBdXTtcbiAgICBpZiAoIXRhcmdldEJsb2NrKVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA+IG9wZXJhdGlvbi5uZXdQYXRoWzBdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9XSkpO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHRhcmdldENoaWxkID0gdGFyZ2V0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLm5ld1BhdGhbMV1dLCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5uZXdQYXRoWzFdID09PSB0YXJnZXRCbG9jay5jaGlsZHJlbi5sZW5ndGggPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiLCBjaGlsZFRvSW5zZXJ0ID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtjaGlsZFRvSW5zZXJ0XSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB0YXJnZXRDaGlsZC5fa2V5XG4gICAgICB9XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc2VydE5vZGVQYXRjaCxcbiAgICBpbnNlcnRUZXh0UGF0Y2gsXG4gICAgbWVyZ2VOb2RlUGF0Y2gsXG4gICAgbW92ZU5vZGVQYXRjaCxcbiAgICByZW1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlVGV4dFBhdGNoLFxuICAgIHNldE5vZGVQYXRjaCxcbiAgICBzcGxpdE5vZGVQYXRjaFxuICB9O1xufVxuY29uc3QgSVNfQVBQTFlJTkdfQkVIQVZJT1JfQUNUSU9OUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKTtcbiAgSVNfQVBQTFlJTkdfQkVIQVZJT1JfQUNUSU9OUy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX0FQUExZSU5HX0JFSEFWSU9SX0FDVElPTlMuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc0FwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvcikge1xuICByZXR1cm4gSVNfQVBQTFlJTkdfQkVIQVZJT1JfQUNUSU9OUy5nZXQoZWRpdG9yKSA/PyAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvciwgc3Vic2NyaXB0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5tYXhCbG9ja3MgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogZXZlbnQuYW5ub3RhdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiYmx1clwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJibHVyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY3VzdG9tLipcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IGV2ZW50LmV2ZW50LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IGV2ZW50LmRlY29yYXRvclxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJmb2N1c1wiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmb2N1c1wiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImluc2VydC5ibG9jayBvYmplY3RcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogZXZlbnQucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIGJsb2NrT2JqZWN0OiBldmVudC5ibG9ja09iamVjdFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGlubGluZU9iamVjdDogZXZlbnQuaW5saW5lT2JqZWN0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImxpc3QgaXRlbS50b2dnbGVcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgIGxpc3RJdGVtOiBldmVudC5saXN0SXRlbVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3R5bGUudG9nZ2xlXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0eWxlLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBldmVudC5zdHlsZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBkZWxldGVCYWNrd2FyZDogZGVsZXRlQmFja3dhcmQyLFxuICAgICAgZGVsZXRlRm9yd2FyZDogZGVsZXRlRm9yd2FyZDIsXG4gICAgICBpbnNlcnRCcmVhayxcbiAgICAgIGluc2VydFNvZnRCcmVhayxcbiAgICAgIGluc2VydFRleHQ6IGluc2VydFRleHQyLFxuICAgICAgc2VsZWN0XG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmRlbGV0ZUJhY2t3YXJkID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChpc0FwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGVkaXRvcikpIHtcbiAgICAgICAgZGVsZXRlQmFja3dhcmQyKHVuaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUZvcndhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBkZWxldGVGb3J3YXJkMih1bml0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlLmZvcndhcmRcIixcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnRCcmVhaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsgPSAoKSA9PiB7XG4gICAgICBpZiAoaXNBcHBseWluZ0JlaGF2aW9yQWN0aW9ucyhlZGl0b3IpKSB7XG4gICAgICAgIGluc2VydFNvZnRCcmVhaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuc29mdCBicmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydFRleHQgPSAodGV4dCwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBpbnNlcnRUZXh0Mih0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICBpbnNlcnRUZXh0Mih0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnNlbGVjdCA9IChsb2NhdGlvbikgPT4ge1xuICAgICAgaWYgKGlzQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZWRpdG9yKSkge1xuICAgICAgICBzZWxlY3QobG9jYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGxvY2F0aW9uKTtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCByYW5nZSwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSlcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICBzZWxlY3QobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoTWF4QmxvY2tzKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93cyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5tYXhCbG9ja3MgPz8gLTE7XG4gICAgICByb3dzID4gMCAmJiBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID49IHJvd3MgJiYgKG9wZXJhdGlvbi50eXBlID09PSBcImluc2VydF9ub2RlXCIgfHwgb3BlcmF0aW9uLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiKSAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEgfHwgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aE9iamVjdEtleXMoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyLFxuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiKSB7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcImluc2VydF9ub2RlXCIgJiYgIUVkaXRvci5pc0VkaXRvcihvcGVyYXRpb24ubm9kZSkpIHtcbiAgICAgICAgYXBwbHkyKHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24sXG4gICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgLi4ub3BlcmF0aW9uLm5vZGUsXG4gICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBub2RlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5fa2V5KSB7XG4gICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgIGlmICghY2hpbGQuX2tleSkge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRlID0gZGVidWdXaXRoTmFtZShcImFwcGx5UGF0Y2hlc1wiKSwgZGVidWdWZXJib3NlID0gZGVidWckZS5lbmFibGVkICYmICEwO1xuZnVuY3Rpb24gY3JlYXRlQXBwbHlQYXRjaChzY2hlbWFUeXBlcykge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSAmJiAoZGVidWckZShgXG5cbk5FVyBQQVRDSCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09YCksIGRlYnVnJGUoSlNPTi5zdHJpbmdpZnkocGF0Y2gsIG51bGwsIDIpKSk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVuc2V0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaWZmTWF0Y2hQYXRjaFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBkaWZmTWF0Y2hQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZWJ1ZyRlKFwiVW5oYW5kbGVkIHBhdGNoXCIsIHBhdGNoLnR5cGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZNYXRjaFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGNoaWxkLFxuICAgIGNoaWxkUGF0aFxuICB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBkZWJ1ZyRlKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKCFjaGlsZCB8fCAhY2hpbGRQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRlKFwiQ2hpbGQgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKCEoYmxvY2sgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gNCAmJiBwYXRjaC5wYXRoWzFdID09PSBcImNoaWxkcmVuXCIgJiYgcGF0Y2gucGF0aFszXSA9PT0gXCJ0ZXh0XCIpIHx8ICFUZXh0LmlzVGV4dChjaGlsZCkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBwYXRjaGVzID0gcGFyc2UocGF0Y2gudmFsdWUpLCBbbmV3VmFsdWVdID0gYXBwbHkocGF0Y2hlcywgY2hpbGQudGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogITBcbiAgfSksIGRpZmYkMSA9IGNsZWFudXBFZmZpY2llbmN5KGRpZmYoY2hpbGQudGV4dCwgbmV3VmFsdWUpLCA1KTtcbiAgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBbb3AsIHRleHRdIG9mIGRpZmYkMSlcbiAgICBvcCA9PT0gRElGRl9JTlNFUlQgPyAoZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0X3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHRcbiAgICB9KSwgb2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IG9wID09PSBESUZGX0RFTEVURSA/IGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXh0XG4gICAgfSkgOiBvcCA9PT0gRElGRl9FUVVBTCAmJiAob2Zmc2V0ICs9IHRleHQubGVuZ3RoKTtcbiAgcmV0dXJuIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKSB7XG4gIGNvbnN0IHtcbiAgICBibG9jazogdGFyZ2V0QmxvY2ssXG4gICAgY2hpbGQ6IHRhcmdldENoaWxkLFxuICAgIGJsb2NrUGF0aDogdGFyZ2V0QmxvY2tQYXRoLFxuICAgIGNoaWxkUGF0aDogdGFyZ2V0Q2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghdGFyZ2V0QmxvY2sgfHwgIXRhcmdldEJsb2NrUGF0aClcbiAgICByZXR1cm4gZGVidWckZShcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDEgJiYgcGF0Y2gucGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiKVxuICAgIHJldHVybiBkZWJ1ZyRlKFwiSWdub3JpbmcgcGF0Y2ggdGFyZ2V0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtczogaXRlbXMyLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uMlxuICAgIH0gPSBwYXRjaCwgYmxvY2tzVG9JbnNlcnQgPSB0b1NsYXRlVmFsdWUoaXRlbXMyLCB7XG4gICAgICBzY2hlbWFUeXBlc1xuICAgIH0sIEtFWV9UT19TTEFURV9FTEVNRU5ULmdldChlZGl0b3IpKSwgdGFyZ2V0QmxvY2tJbmRleCA9IHRhcmdldEJsb2NrUGF0aFswXSwgbm9ybWFsaXplZElkeDIgPSBwb3NpdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleDtcbiAgICByZXR1cm4gZGVidWckZShgSW5zZXJ0aW5nIGJsb2NrcyBhdCBwYXRoIFske25vcm1hbGl6ZWRJZHgyfV1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2tzVG9JbnNlcnQsIHtcbiAgICAgIGF0OiBbbm9ybWFsaXplZElkeDJdXG4gICAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbiAgfVxuICBjb25zdCB7XG4gICAgaXRlbXMsXG4gICAgcG9zaXRpb25cbiAgfSA9IHBhdGNoO1xuICBpZiAoIXRhcmdldENoaWxkIHx8ICF0YXJnZXRDaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJGUoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBjb25zdCBjaGlsZHJlblRvSW5zZXJ0ID0gdGFyZ2V0QmxvY2sgJiYgdG9TbGF0ZVZhbHVlKFt7XG4gICAgLi4udGFyZ2V0QmxvY2ssXG4gICAgY2hpbGRyZW46IGl0ZW1zXG4gIH1dLCB7XG4gICAgc2NoZW1hVHlwZXNcbiAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRDaGlsZEluZGV4ID0gdGFyZ2V0Q2hpbGRQYXRoWzFdLCBub3JtYWxpemVkSWR4ID0gcG9zaXRpb24gPT09IFwiYWZ0ZXJcIiA/IHRhcmdldENoaWxkSW5kZXggKyAxIDogdGFyZ2V0Q2hpbGRJbmRleCwgY2hpbGRJbnNlcnRQYXRoID0gW3RhcmdldENoaWxkUGF0aFswXSwgbm9ybWFsaXplZElkeF07XG4gIHJldHVybiBkZWJ1ZyRlKGBJbnNlcnRpbmcgY2hpbGRyZW4gYXQgcGF0aCAke2NoaWxkSW5zZXJ0UGF0aH1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBjaGlsZHJlblRvSW5zZXJ0ICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGRyZW5Ub0luc2VydFswXSkgJiYgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkcmVuVG9JbnNlcnRbMF0uY2hpbGRyZW4sIHtcbiAgICBhdDogY2hpbGRJbnNlcnRQYXRoXG4gIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiBzZXRQYXRjaChlZGl0b3IsIHBhdGNoKSB7XG4gIGxldCB2YWx1ZSA9IHBhdGNoLnZhbHVlO1xuICB0eXBlb2YgcGF0Y2gucGF0aFszXSA9PSBcInN0cmluZ1wiICYmICh2YWx1ZSA9IHt9LCB2YWx1ZVtwYXRjaC5wYXRoWzNdXSA9IHBhdGNoLnZhbHVlKTtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gZGVidWckZShcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGlzVGV4dEJsb2NrID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKTtcbiAgaWYgKGlzVGV4dEJsb2NrICYmIHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGUoXCJJZ25vcmluZyBzZXR0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAoZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBpc1RleHRCbG9jayAmJiBjaGlsZCAmJiBjaGlsZFBhdGgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQodmFsdWUpICYmIFRleHQuaXNUZXh0KGNoaWxkKSkge1xuICAgICAgY29uc3QgbmV3VGV4dCA9IGNoaWxkLnRleHQ7XG4gICAgICB2YWx1ZS50ZXh0ICE9PSBuZXdUZXh0ICYmIChkZWJ1ZyRlKFwiU2V0dGluZyB0ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICB9KSwgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgdGV4dDogdmFsdWUudGV4dFxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9IGVsc2VcbiAgICAgIGRlYnVnJGUoXCJTZXR0aW5nIG5vbi10ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInNldF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IHZhbHVlXG4gICAgICB9KTtcbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEgJiYgYmxvY2tQYXRoKSB7XG4gICAgZGVidWckZShcIlNldHRpbmcgYmxvY2sgcHJvcGVydHlcIik7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5uZXh0UmVzdFxuICAgIH0gPSB2YWx1ZSwge1xuICAgICAgY2hpbGRyZW46IHByZXZDaGlsZHJlbixcbiAgICAgIC4uLnByZXZSZXN0XG4gICAgfSA9IGJsb2NrIHx8IHtcbiAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICB9O1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiBcInNldF9ub2RlXCIsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC4uLnByZXZSZXN0XG4gICAgICB9LFxuICAgICAgbmV3UHJvcGVydGllczogbmV4dFJlc3RcbiAgICB9KSwgZGVidWckZShcIlNldHRpbmcgY2hpbGRyZW5cIiksIGJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlX25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxIC0gY0luZGV4KSxcbiAgICAgICAgbm9kZTogYzJcbiAgICAgIH0pO1xuICAgIH0pLCBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5mb3JFYWNoKChjMiwgY0luZGV4KSA9PiB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGJsb2NrUGF0aC5jb25jYXQoY0luZGV4KSxcbiAgICAgICAgbm9kZTogYzJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGJsb2NrICYmIFwidmFsdWVcIiBpbiBibG9jaykge1xuICAgIGNvbnN0IG5ld1ZhbCA9IGFwcGx5QWxsKFtibG9jay52YWx1ZV0sIFtwYXRjaF0pWzBdO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgLi4uYmxvY2ssXG4gICAgICB2YWx1ZTogbmV3VmFsXG4gICAgfSwge1xuICAgICAgYXQ6IGJsb2NrUGF0aFxuICAgIH0pLCAhMDtcbiAgfVxuICByZXR1cm4gZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gdW5zZXRQYXRjaChlZGl0b3IsIHBhdGNoKSB7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlYnVnJGUoXCJSZW1vdmluZyBldmVyeXRoaW5nXCIpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIik7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5jaGlsZHJlbi5mb3JFYWNoKChfY2hpbGQsIGkpID0+IHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBbaV1cbiAgICAgIH0pO1xuICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICBkZWNvcmF0b3JzOiBbXVxuICAgIH0pKSwgcHJldmlvdXNTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBibG9jayxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICghYmxvY2sgfHwgIWJsb2NrUGF0aClcbiAgICAgIHJldHVybiBkZWJ1ZyRlKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgICBjb25zdCBibG9ja0luZGV4ID0gYmxvY2tQYXRoWzBdO1xuICAgIHJldHVybiBkZWJ1ZyRlKGBSZW1vdmluZyBibG9jayBhdCBwYXRoIFske2Jsb2NrSW5kZXh9XWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogW2Jsb2NrSW5kZXhdXG4gICAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbiAgfVxuICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBwYXRjaC5wYXRoWzFdID09PSBcImNoaWxkcmVuXCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDMgPyAhY2hpbGQgfHwgIWNoaWxkUGF0aCA/IChkZWJ1ZyRlKFwiQ2hpbGQgbm90IGZvdW5kXCIpLCAhMSkgOiAoZGVidWckZShgVW5zZXR0aW5nIGNoaWxkIGF0IHBhdGggJHtKU09OLnN0cmluZ2lmeShjaGlsZFBhdGgpfWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGRlYnVnVmVyYm9zZSAmJiBkZWJ1ZyRlKGBSZW1vdmluZyBjaGlsZCBhdCBwYXRoICR7SlNPTi5zdHJpbmdpZnkoY2hpbGRQYXRoKX1gKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICBhdDogY2hpbGRQYXRoXG4gIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITApIDogITE7XG59XG5mdW5jdGlvbiBpc0tleWVkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1Z1N0YXRlKGVkaXRvciwgc3RhdGVOYW1lKSB7XG4gIGRlYnVnVmVyYm9zZSAmJiAoZGVidWckZShgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyRlKGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMF0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzBdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFswXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoYmxvY2tJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHtcbiAgICBibG9jayxcbiAgICBwYXRoOiBbYmxvY2tJbmRleF1cbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IGJsb2NrUGF0aFxuICB9ID0gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBibG9ja1BhdGgsXG4gICAgICBjaGlsZDogdm9pZCAwLFxuICAgICAgY2hpbGRQYXRoOiB2b2lkIDBcbiAgICB9O1xuICBsZXQgY2hpbGRJbmRleCA9IC0xO1xuICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMl0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzJdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFsyXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoY2hpbGRJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBjaGlsZCA/IHtcbiAgICBibG9jayxcbiAgICBjaGlsZCxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiBibG9ja1BhdGg/LmNvbmNhdChjaGlsZEluZGV4KVxuICB9IDoge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZDogdm9pZCAwLFxuICAgIGNoaWxkUGF0aDogdm9pZCAwXG4gIH07XG59XG5jb25zdCBkZWJ1ZyRkID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHBhdGNoRnVuY3Rpb25zLFxuICBzY2hlbWFUeXBlcyxcbiAgc3Vic2NyaXB0aW9uc1xufSkge1xuICBsZXQgcHJldmlvdXNDaGlsZHJlbjtcbiAgY29uc3QgYXBwbHlQYXRjaCA9IGNyZWF0ZUFwcGx5UGF0Y2goc2NoZW1hVHlwZXMpO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMSksIFBBVENISU5HLnNldChlZGl0b3IsICEwKSwgcHJldmlvdXNDaGlsZHJlbiA9IFsuLi5lZGl0b3IuY2hpbGRyZW5dO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIGxldCBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyZWRQYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0Y2hlcyA9IGJ1ZmZlcmVkUGF0Y2hlcztcbiAgICAgIGJ1ZmZlcmVkUGF0Y2hlcyA9IFtdO1xuICAgICAgbGV0IGNoYW5nZWQgPSAhMTtcbiAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyRkLmVuYWJsZWQgJiYgZGVidWckZChgSGFuZGxpbmcgcmVtb3RlIHBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfWApLCBjaGFuZ2VkID0gYXBwbHlQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNoYW5nZWQgJiYgKGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfSk7XG4gICAgfSwgaGFuZGxlUGF0Y2hlcyA9ICh7XG4gICAgICBwYXRjaGVzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IHBhdGNoZXMuZmlsdGVyKChwKSA9PiBwLm9yaWdpbiAhPT0gXCJsb2NhbFwiKTtcbiAgICAgIHJlbW90ZVBhdGNoZXMubGVuZ3RoICE9PSAwICYmIChidWZmZXJlZFBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXMuY29uY2F0KHJlbW90ZVBhdGNoZXMpLCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGQoXCJTdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCBoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGQoXCJVbnN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGxldCBwYXRjaGVzID0gW107XG4gICAgICBwcmV2aW91c0NoaWxkcmVuID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZWRpdG9yV2FzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihwcmV2aW91c0NoaWxkcmVuLCBzY2hlbWFUeXBlcyk7XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgIGNvbnN0IGVkaXRvcklzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihlZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKTtcbiAgICAgIGlmICghaXNQYXRjaGluZyhlZGl0b3IpKVxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgc3dpdGNoIChlZGl0b3JXYXNFbXB0eSAmJiAhZWRpdG9ySXNFbXB0eSAmJiBvcGVyYXRpb24udHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgcGF0Y2hlcy5wdXNoKGluc2VydChwcmV2aW91c0NoaWxkcmVuLCBcImJlZm9yZVwiLCBbMF0pKSwgb3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImluc2VydF90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5pbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNwbGl0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuc2V0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXJnZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWVkaXRvcldhc0VtcHR5ICYmIGVkaXRvcklzRW1wdHkgJiYgW1wibWVyZ2Vfbm9kZVwiLCBcInNldF9ub2RlXCIsIFwicmVtb3ZlX3RleHRcIiwgXCJyZW1vdmVfbm9kZVwiXS5pbmNsdWRlcyhvcGVyYXRpb24udHlwZSkgJiYgKHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgdW5zZXQoW10pXSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidW5zZXRcIixcbiAgICAgICAgcHJldmlvdXNWYWx1ZTogZnJvbVNsYXRlVmFsdWUocHJldmlvdXNDaGlsZHJlbiwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpXG4gICAgICB9KSksIGVkaXRvcldhc0VtcHR5ICYmIHBhdGNoZXMubGVuZ3RoID4gMCAmJiAocGF0Y2hlcyA9IFtzZXRJZk1pc3NpbmcoW10sIFtdKSwgLi4ucGF0Y2hlc10pLCBwYXRjaGVzLmxlbmd0aCA+IDAgJiYgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgIC4uLnBhdGNoLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGVkaXRvcjtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRjID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGxhY2Vob2xkZXJCbG9ja1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICBpZiAob3AucGF0aFswXSA9PT0gMCAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChvcC5wYXRoKTtcbiAgICAgICAgICBlZGl0b3IuY2hpbGRyZW5bbmV4dFBhdGhbMF1dIHx8IChkZWJ1ZyRjKFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGIgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVzLnN0eWxlc1swXS52YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBlZGl0b3Iub3BlcmF0aW9ucylcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRCbG9jayhvcC5wcm9wZXJ0aWVzKSAmJiBvcC5wcm9wZXJ0aWVzLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgJiYgb3AucGF0aFswXSA9PT0gcGF0aFswXSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgb3AucGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBbY2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJGIoYE5vcm1hbGl6aW5nIHNwbGl0IG5vZGUgdG8gJHtkZWZhdWx0U3R5bGV9IHN0eWxlYCwgb3ApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogW29wLnBhdGhbMF0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID4gXCJ1XCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KChtYXJrKSA9PiB0eXBlb2YgbWFyayA9PSBcInN0cmluZ1wiKSk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIGJsb2NrIGRvZXNuJ3QgX2hhdmVfIHRvIGJlIG5hbWVkICdibG9jaycgLSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAvLyBhbGxvd2VkIGNoaWxkIHR5cGVzIGFuZCBtYXJrcywgb25lIG1pZ2h0IG5hbWUgdGhlbSBkaWZmZXJlbnRseVxuICAgIHR5cGVvZiBub2RlLl90eXBlID09IFwic3RyaW5nXCIgJiYgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIC8vIGBtYXJrRGVmc2AgaXNuJ3QgX3JlcXVpcmVkXyBwZXIgc2F5LCBidXQgaWYgaXQncyB0aGVyZSwgaXQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICAoIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJiAvLyBFdmVyeSBtYXJrIGRlZmluaXRpb24gbmVlZHMgdG8gaGF2ZSBhbiBgX2tleWAgdG8gYmUgbWFwcGFibGUgaW4gY2hpbGQgc3BhbnNcbiAgICBub2RlLm1hcmtEZWZzLmV2ZXJ5KChkZWYpID0+IHR5cGVvZiBkZWYuX2tleSA9PSBcInN0cmluZ1wiKSkgJiYgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmIC8vIEFsbCBjaGlsZHJlbiBhcmUgb2JqZWN0cyB3aXRoIGBfdHlwZWAgKHVzdWFsbHkgc3BhbnMsIGJ1dCBjYW4gY29udGFpbiBvdGhlciBzdHVmZilcbiAgICBub2RlLmNoaWxkcmVuLmV2ZXJ5KChjaGlsZCkgPT4gdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgXCJfdHlwZVwiIGluIGNoaWxkKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNTcGFuKHtcbiAgZWRpdG9yLFxuICBibG9ja1BhdGgsXG4gIHNwYW5QYXRoXG59KSB7XG4gIGxldCBwcmV2aW91c1NwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgsIHtcbiAgICByZXZlcnNlOiAhMFxuICB9KSlcbiAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNCZWZvcmUoY2hpbGRQYXRoLCBzcGFuUGF0aCkpIHtcbiAgICAgIHByZXZpb3VzU3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gcHJldmlvdXNTcGFuO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IG5leHRTcGFuO1xuICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgbmV4dFNwYW4gPSBjaGlsZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIG5leHRTcGFuO1xufVxuY29uc3QgZGVidWckYSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyLFxuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3IsIGRlY29yYXRvcnMgPSB0eXBlcy5kZWNvcmF0b3JzLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKG5vZGVFbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bY2hpbGRQYXRoWzFdICsgMV07XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihuZXh0Tm9kZSkgJiYgY2hpbGQubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBuZXh0Tm9kZS5tYXJrcz8uaW5jbHVkZXMobWFyaykpICYmIG5leHROb2RlLm1hcmtzPy5ldmVyeSgobWFyaykgPT4gY2hpbGQubWFya3M/LmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgZGVidWckYShcIk1lcmdpbmcgc3BhbnNcIiwgSlNPTi5zdHJpbmdpZnkoY2hpbGQsIG51bGwsIDIpLCBKU09OLnN0cmluZ2lmeShuZXh0Tm9kZSwgbnVsbCwgMikpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogW2NoaWxkUGF0aFswXSwgY2hpbGRQYXRoWzFdICsgMV0sXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgIGRlYnVnJGEoXCJBZGRpbmcgLm1hcmtEZWZzIHRvIGJsb2NrIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrRGVmczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya3MpKSB7XG4gICAgICAgIGRlYnVnJGEoXCJBZGRpbmcgLm1hcmtzIHRvIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tQYXRoID0gUGF0aC5wYXJlbnQocGF0aCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGJsb2NrUGF0aCksIGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKSwgYW5ub3RhdGlvbnMgPSBub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG5vZGUudGV4dCA9PT0gXCJcIiAmJiBhbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWckYShcIlJlbW92aW5nIGFubm90YXRpb25zIGZyb20gZW1wdHkgc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIW5vZGUubWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZGVidWckYShcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSksIG1hcmtzID0gbm9kZS5tYXJrcyA/PyBbXSwgb3JwaGFuZWRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspICYmICFibG9jay5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnJGEoXCJSZW1vdmluZyBvcnBoYW5lZCBhbm5vdGF0aW9ucyBmcm9tIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hcmtzOiBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFvcnBoYW5lZEFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWZzID0gbm9kZS5tYXJrRGVmcyA/PyBbXSwgbWFya0RlZktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdNYXJrRGVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmtEZWYgb2YgbWFya0RlZnMpXG4gICAgICAgICAgbWFya0RlZktleXMuaGFzKG1hcmtEZWYuX2tleSkgfHwgKG1hcmtEZWZLZXlzLmFkZChtYXJrRGVmLl9rZXkpLCBuZXdNYXJrRGVmcy5wdXNoKG1hcmtEZWYpKTtcbiAgICAgICAgaWYgKG1hcmtEZWZzLmxlbmd0aCAhPT0gbmV3TWFya0RlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVidWckYShcIlJlbW92aW5nIGR1cGxpY2F0ZSBtYXJrRGVmc1wiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIWVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG9wKSA9PiBvcC50eXBlID09PSBcIm1lcmdlX25vZGVcIiAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgY29uc3QgbmV3TWFya0RlZnMgPSAobm9kZS5tYXJrRGVmcyB8fCBbXSkuZmlsdGVyKChkZWYpID0+IG5vZGUuY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IFRleHQuaXNUZXh0KGNoaWxkKSAmJiBBcnJheS5pc0FycmF5KGNoaWxkLm1hcmtzKSAmJiBjaGlsZC5tYXJrcy5pbmNsdWRlcyhkZWYuX2tleSkpKTtcbiAgICAgICAgaWYgKG5vZGUubWFya0RlZnMgJiYgIWlzRXF1YWwobmV3TWFya0RlZnMsIG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgICAgZGVidWckYShcIlJlbW92aW5nIG1hcmtEZWYgbm90IGluIHVzZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIEVkaXRvci5tYXJrcyhlZGl0b3IpICYmIG9wLnByb3BlcnRpZXMgJiYgb3AubmV3UHJvcGVydGllcyAmJiBvcC5wcm9wZXJ0aWVzLmFuY2hvciAmJiBvcC5wcm9wZXJ0aWVzLmZvY3VzICYmIG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLnByb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pLCBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCAmJiBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5wcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBuZXdGb2N1c1NwYW4gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogb3AubmV3UHJvcGVydGllcy5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0/LlswXSwgbW92ZWRUb05leHRTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSArIDEgJiYgZm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCA9PT0gMCwgbW92ZWRUb1ByZXZpb3VzU3BhbiA9IGZvY3VzU3BhbiAmJiBuZXdGb2N1c1NwYW4gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzBdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzFdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gLSAxICYmIG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwICYmIG5ld0ZvY3VzU3Bhbi50ZXh0Lmxlbmd0aCA9PT0gb3AubmV3UHJvcGVydGllcy5mb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgaWYgKG1vdmVkVG9OZXh0U3BhbiB8fCBtb3ZlZFRvUHJldmlvdXNTcGFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IFtfYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBvcC5wYXRoXG4gICAgICAgICAgfSksIHByZXZpb3VzU3BhbkFubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBbb3AucGF0aFswXSwgb3AucGF0aFsxXSAtIDFdXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3BhbiA/IG5leHRTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBhbm5vdGF0aW9uc0VuZGluZyA9IHByZXZpb3VzU3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFuZXh0U3BhbkFubm90YXRpb25zPy5pbmNsdWRlcyhhbm5vdGF0aW9uKSkgPz8gW10sIGF0VGhlRW5kT2ZBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNFbmRpbmcubGVuZ3RoID4gMDtcbiAgICAgICAgICBpZiAoYXRUaGVFbmRPZkFubm90YXRpb24gJiYgaXNQb3J0YWJsZVRleHRTcGFuKG9wLm5vZGUpICYmIG9wLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+IGFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSA/PyBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zU3RhcnRpbmcgPSBuZXh0U3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMoYW5ub3RhdGlvbikpID8/IFtdLCBhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNTdGFydGluZy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5zb21lKChtYXJrKSA9PiBhbm5vdGF0aW9uc1N0YXJ0aW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zU3RhcnRpbmcuaW5jbHVkZXMobWFyaykpID8/IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV4dFNwYW5EZWNvcmF0b3JzID0gbmV4dFNwYW4/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdO1xuICAgICAgICAgIGlmIChuZXh0U3BhbkRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiBhdFRoZUVuZE9mQW5ub3RhdGlvbiAmJiAhYXRUaGVTdGFydE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBtYXJrczogbmV4dFNwYW5EZWNvcmF0b3JzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcImluc2VydF90ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yLCBjb2xsYXBzZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gPyBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pIDogITE7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgY29sbGFwc2VkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgW19ibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBbc3Bhbiwgc3BhblBhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXSwgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBtYXJrc1dpdGhvdXRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSksIHNwYW5IYXNBbm5vdGF0aW9ucyA9IG1hcmtzLmxlbmd0aCA+IG1hcmtzV2l0aG91dEFubm90YXRpb25zLmxlbmd0aCwgc3BhbklzRW1wdHkgPSBzcGFuLnRleHQubGVuZ3RoID09PSAwLCBhdFRoZUJlZ2lubmluZ09mU3BhbiA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwLCBhdFRoZUVuZE9mU3BhbiA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSBzcGFuLnRleHQubGVuZ3RoLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICB9KSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgIH0pLCBuZXh0U3BhbkFubm90YXRpb25zID0gbmV4dFNwYW4/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA/PyBbXSwgc3BhbkFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSksIHByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKS5ldmVyeSgobWFyaykgPT4gbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZU1hcmtzID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5ldmVyeSgobWFyaykgPT4gbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIG5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zID0gc3BhbkFubm90YXRpb25zLnNvbWUoKG1hcmspID0+IG5leHRTcGFuQW5ub3RhdGlvbnM/LmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgICBpZiAoc3Bhbkhhc0Fubm90YXRpb25zICYmICFzcGFuSXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nT2ZTcGFuKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MpIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldmlvdXNTcGFuKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdFRoZUVuZE9mU3Bhbikge1xuICAgICAgICAgICAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgJiYgbmV4dFNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggPCBzcGFuQW5ub3RhdGlvbnMubGVuZ3RoIHx8ICFuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IG5leHRTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW5leHRTcGFuKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nT2ZTcGFuICYmICFzcGFuSXNFbXB0eSAmJiBwcmV2aW91c1NwYW4pIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuSGFzQW5ub3RhdGlvbnMgPyBbXSA6IChwcmV2aW91c1NwYW4ubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIFtzcGFuLCBzcGFuUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDoge1xuICAgICAgICAgICAgICBwYXRoOiBvcC5wYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9wLm9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgICAgICBpZiAoc3BhbiAmJiBibG9jayAmJiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICAgICAgY29uc3QgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXSwgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBzcGFuSGFzQW5ub3RhdGlvbnMgPSBtYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmspKSwgZGVsZXRpbmdGcm9tVGhlRW5kID0gb3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPT09IHNwYW4udGV4dC5sZW5ndGgsIGRlbGV0aW5nQWxsVGV4dCA9IG9wLm9mZnNldCA9PT0gMCAmJiBkZWxldGluZ0Zyb21UaGVFbmQsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgICAgfSksIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICAgIH0pLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykgJiYgbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIG5leHRTcGFuSGFzU2FtZUFubm90YXRpb24gPSBuZXh0U3BhbiA/IG5leHRTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMTtcbiAgICAgICAgICAgIGlmIChzcGFuSGFzQW5ub3RhdGlvbnMgJiYgZGVsZXRpbmdBbGxUZXh0ICYmICFwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiAmJiAhbmV4dFNwYW5IYXNTYW1lQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uTWFya3MgPSAoe1xuICAgICAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgICAgICAgIH0ubWFya3MgfHwgW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBwbHkyKG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uTWFya3NcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBhdDogb3AucGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcIm1lcmdlX25vZGVcIiAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBvcC5wcm9wZXJ0aWVzLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lICYmIEFycmF5LmlzQXJyYXkob3AucHJvcGVydGllcy5tYXJrRGVmcykgJiYgb3AucHJvcGVydGllcy5tYXJrRGVmcy5sZW5ndGggPiAwICYmIG9wLnBhdGhbMF0gLSAxID49IDApIHtcbiAgICAgICAgY29uc3QgW3RhcmdldEJsb2NrLCB0YXJnZXRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgW29wLnBhdGhbMF0gLSAxXSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRGVmcyA9IEFycmF5LmlzQXJyYXkodGFyZ2V0QmxvY2subWFya0RlZnMpICYmIHRhcmdldEJsb2NrLm1hcmtEZWZzIHx8IFtdLCBuZXdNYXJrRGVmcyA9IHVuaXEoWy4uLm9sZERlZnMsIC4uLm9wLnByb3BlcnRpZXMubWFya0RlZnNdKTtcbiAgICAgICAgICBkZWJ1ZyRhKFwiQ29weWluZyBtYXJrRGVmcyBvdmVyIHRvIG1lcmdlZCBibG9ja1wiLCBvcCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pLCBhcHBseTIob3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXBwbHkyKG9wKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBhZGREZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCBtYXJrID0gYWN0aW9uLmRlY29yYXRvcjtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzcGxpdFRleHROb2RlcyA9IFJhbmdlLmlzUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbikgPyBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KV0gOiBbXTtcbiAgICAgIHNwbGl0VGV4dE5vZGVzLmxlbmd0aCA+IDEgJiYgc3BsaXRUZXh0Tm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGVbMF0ubWFya3M/LmluY2x1ZGVzKG1hcmspKSA/IGVkaXRvci5yZW1vdmVNYXJrKG1hcmspIDogc3BsaXRUZXh0Tm9kZXMuZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gWy4uLihBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksIG1hcmtdO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSksIGxvbmVseUVtcHR5U3BhbiA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuWzBdKSAmJiBibG9jay5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiID8gYmxvY2suY2hpbGRyZW5bMF0gOiB2b2lkIDA7XG4gICAgICBpZiAobG9uZWx5RW1wdHlTcGFuKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSBsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10sIGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yID0gZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5sZW5ndGggPT09IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yLmxlbmd0aCA/IFsuLi5leGlzdGluZ01hcmtzLCBtYXJrXSA6IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzID0ge1xuICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgIH0ubWFya3MgfHwgW10sIG1hcmtzID0ge1xuICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LFxuICAgICAgICAgIG1hcmtzOiBbLi4uZXhpc3RpbmdNYXJrcywgbWFya11cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uc2VsZWN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSwgcmVtb3ZlRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvciwgbWFyayA9IGFjdGlvbi5kZWNvcmF0b3IsIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpXG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KSwgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW3BhdGhbMF1dO1xuICAgICAgICBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5pbmNsdWRlcyhub2RlKSAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiAoQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSA/IG5vZGUubWFya3MgOiBbXSkuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspLFxuICAgICAgICAgIF90eXBlOiBcInNwYW5cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IgPSAobG9uZWx5RW1wdHlTcGFuLm1hcmtzID8/IFtdKS5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgfS5tYXJrcyB8fCBbXSwgbWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgICAgbWFya3M6IGV4aXN0aW5nTWFya3MuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspXG4gICAgICAgIH07XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IHtcbiAgICAgICAgICBtYXJrczogbWFya3MubWFya3MsXG4gICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24yID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSB7XG4gICAgICAgIC4uLnNlbGVjdGlvbjJcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gaXNEZWNvcmF0b3JBY3RpdmUoe1xuICBlZGl0b3IsXG4gIGRlY29yYXRvclxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZFRleHROb2RlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICB9KSk7XG4gIHJldHVybiBzZWxlY3RlZFRleHROb2Rlcy5sZW5ndGggPT09IDAgPyAhMSA6IFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbikgPyBzZWxlY3RlZFRleHROb2Rlcy5ldmVyeSgobikgPT4ge1xuICAgIGNvbnN0IFtub2RlXSA9IG47XG4gICAgcmV0dXJuIG5vZGUubWFya3M/LmluY2x1ZGVzKGRlY29yYXRvcik7XG4gIH0pIDogKHtcbiAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICB9Lm1hcmtzIHx8IFtdKS5pbmNsdWRlcyhkZWNvcmF0b3IpO1xufVxuY29uc3QgdG9nZ2xlRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaXNEZWNvcmF0b3JBY3RpdmUoe1xuICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICBkZWNvcmF0b3I6IGFjdGlvbi5kZWNvcmF0b3JcbiAgfSkgPyByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb246IHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgICAgZGVjb3JhdG9yOiBhY3Rpb24uZGVjb3JhdG9yXG4gICAgfVxuICB9KSA6IGFkZERlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IuYWRkXCIsXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBkZWNvcmF0b3I6IGFjdGlvbi5kZWNvcmF0b3JcbiAgICB9XG4gIH0pO1xufTtcbmRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyhlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgbGV0IHByZXZTZWxlY3Rpb24gPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgZW1pdFBvcnRhYmxlVGV4dFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChwcmV2U2VsZWN0aW9uICE9PSBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBwdFJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGlmIChleGlzdGluZylcbiAgICAgICAgICAgIHB0UmFuZ2UgPSBleGlzdGluZztcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgICAgICAgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB0UmFuZ2UgPyBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogcHRSYW5nZVxuICAgICAgICB9KSA6IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJldlNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgfSwge1xuICAgICAgb25DaGFuZ2VcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iub25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBvbkNoYW5nZSgpLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBzZXR1cDogXCJzZXR0aW5nIHVwXCJcbiAgICAgIH0pIHx8IGVtaXRQb3J0YWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQ5ID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoU2NoZW1hVHlwZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICBlZGl0b3JBY3RvcixcbiAgc2NoZW1hVHlwZXNcbn0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5pc1RleHRCbG9jayA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBlZGl0b3IuaXNUZXh0U3BhbiA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRTcGFuJDEodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsIGVkaXRvci5pc0xpc3RCbG9jayA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRMaXN0QmxvY2sodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBlZGl0b3IuaXNWb2lkID0gKGVsZW1lbnQpID0+IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUgIT09IGVsZW1lbnQuX3R5cGUgJiYgKHNjaGVtYVR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpIHx8IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSksIGVkaXRvci5pc0lubGluZSA9IChlbGVtZW50KSA9PiBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgJiYgXCJfX2lubGluZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC5fX2lubGluZSA9PT0gITA7XG4gICAgY29uc3Qge1xuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChub2RlLl90eXBlID09PSB2b2lkIDAgJiYgcGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZGVidWckOShcIlNldHRpbmcgc3BhbiB0eXBlIG9uIHRleHQgbm9kZSB3aXRob3V0IGEgdHlwZVwiKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5vZGUsIGtleSA9IHNwYW4uX2tleSB8fCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5zcGFuLFxuICAgICAgICAgIF90eXBlOiBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsXG4gICAgICAgICAgX2tleToga2V5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLl9rZXkgPT09IHZvaWQgMCAmJiAocGF0aC5sZW5ndGggPT09IDEgfHwgcGF0aC5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgIGRlYnVnJDkoXCJTZXR0aW5nIG1pc3Npbmcga2V5IG9uIGNoaWxkIG5vZGUgd2l0aG91dCBhIGtleVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpO1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgX2tleToga2V5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDggPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhVdGlsc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhVdGlscyh7XG4gIGVkaXRvckFjdG9yLFxuICBzY2hlbWFUeXBlc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wdGVFeHBhbmRUb1dvcmQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBbdGV4dE5vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMsIHtcbiAgICAgICAgICBkZXB0aDogMlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSB8fCAhVGV4dC5pc1RleHQodGV4dE5vZGUpIHx8IHRleHROb2RlLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVidWckOChcInB0ZUV4cGFuZFRvV29yZDogQ2FuJ3QgZXhwYW5kIHRvIHdvcmQgaGVyZVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb24sIGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0LCBjaGFyc0JlZm9yZSA9IHRleHROb2RlLnRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpLCBjaGFyc0FmdGVyID0gdGV4dE5vZGUudGV4dC5zbGljZShmb2N1c09mZnNldCwgLTEpLCBpc0VtcHR5ID0gKHN0cikgPT4gc3RyLm1hdGNoKC9cXHMvZyksIHdoaXRlU3BhY2VCZWZvcmVJbmRleCA9IGNoYXJzQmVmb3JlLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5maW5kSW5kZXgoKHN0cikgPT4gaXNFbXB0eShzdHIpKSwgbmV3U3RhcnRPZmZzZXQgPSB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggPiAtMSA/IGNoYXJzQmVmb3JlLmxlbmd0aCAtIHdoaXRlU3BhY2VCZWZvcmVJbmRleCA6IDAsIHdoaXRlU3BhY2VBZnRlckluZGV4ID0gY2hhcnNBZnRlci5zcGxpdChcIlwiKS5maW5kSW5kZXgoKG9iaikgPT4gaXNFbXB0eShvYmopKSwgbmV3RW5kT2Zmc2V0ID0gY2hhcnNCZWZvcmUubGVuZ3RoICsgKHdoaXRlU3BhY2VBZnRlckluZGV4ID4gLTEgPyB3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA6IGNoYXJzQWZ0ZXIubGVuZ3RoICsgMSk7XG4gICAgICAgIGlmICghKG5ld1N0YXJ0T2Zmc2V0ID09PSBuZXdFbmRPZmZzZXQgfHwgTnVtYmVyLmlzTmFOKG5ld1N0YXJ0T2Zmc2V0KSB8fCBOdW1iZXIuaXNOYU4obmV3RW5kT2Zmc2V0KSkpIHtcbiAgICAgICAgICBkZWJ1ZyQ4KFwicHRlRXhwYW5kVG9Xb3JkOiBFeHBhbmRpbmcgdG8gZm9jdXNlZCB3b3JkXCIpLCBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICAuLi5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld1N0YXJ0T2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld0VuZE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyQ4KFwicHRlRXhwYW5kVG9Xb3JkOiBDYW4ndCBleHBhbmQgdG8gd29yZCBoZXJlXCIpO1xuICAgICAgfVxuICAgIH0sIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2sgPSAob3B0aW9ucykgPT4gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfdHlwZTogc2NoZW1hVHlwZXMuYmxvY2submFtZSxcbiAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIHN0eWxlOiBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUgfHwgXCJub3JtYWxcIixcbiAgICAgIC4uLm9wdGlvbnMubGlzdEl0ZW0gPyB7XG4gICAgICAgIGxpc3RJdGVtOiBvcHRpb25zLmxpc3RJdGVtXG4gICAgICB9IDoge30sXG4gICAgICAuLi5vcHRpb25zLmxldmVsID8ge1xuICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgfSA6IHt9LFxuICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogb3B0aW9ucy5kZWNvcmF0b3JzLmZpbHRlcigoZGVjb3JhdG9yKSA9PiBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLmZpbmQoKHtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KSA9PiB2YWx1ZSA9PT0gZGVjb3JhdG9yKSlcbiAgICAgIH1dXG4gICAgfV0sIHtcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSlbMF0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IHdpdGhQbHVnaW5zID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlID0gZWRpdG9yLCB7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSA9IG9wdGlvbnMsIHNjaGVtYVR5cGVzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgb3BlcmF0aW9uVG9QYXRjaGVzID0gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHNjaGVtYVR5cGVzKSwgd2l0aE9iamVjdEtleXMgPSBjcmVhdGVXaXRoT2JqZWN0S2V5cyhlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoU2NoZW1hVHlwZXMgPSBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHNjaGVtYVR5cGVzXG4gIH0pLCB3aXRoUGF0Y2hlcyA9IGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBwYXRjaEZ1bmN0aW9uczogb3BlcmF0aW9uVG9QYXRjaGVzLFxuICAgIHNjaGVtYVR5cGVzLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aE1heEJsb2NrcyA9IGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpLCB3aXRoVW5kb1JlZG8gPSBjcmVhdGVXaXRoVW5kb1JlZG8oe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGJsb2NrU2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuYmxvY2ssXG4gICAgc3Vic2NyaXB0aW9uczogb3B0aW9ucy5zdWJzY3JpcHRpb25zXG4gIH0pLCB3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyksIHdpdGhQbGFjZWhvbGRlckJsb2NrID0gY3JlYXRlV2l0aFBsYWNlaG9sZGVyQmxvY2soZWRpdG9yQWN0b3IpLCB3aXRoVXRpbHMgPSBjcmVhdGVXaXRoVXRpbHMoe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHNjaGVtYVR5cGVzXG4gIH0pLCB3aXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyk7XG4gIHJldHVybiBjcmVhdGVXaXRoRXZlbnRMaXN0ZW5lcnMoZWRpdG9yQWN0b3IsIG9wdGlvbnMuc3Vic2NyaXB0aW9ucykod2l0aFNjaGVtYVR5cGVzKHdpdGhPYmplY3RLZXlzKHdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwod2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUod2l0aFBsYWNlaG9sZGVyQmxvY2sod2l0aFV0aWxzKHdpdGhNYXhCbG9ja3Mod2l0aFVuZG9SZWRvKHdpdGhQYXRjaGVzKHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGUpKSkpKSkpKSkpKTtcbn0sIGRlYnVnJDcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTbGF0ZUNvbnRhaW5lclwiKSwgc2xhdGVFZGl0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVTbGF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgZXhpc3RpbmdTbGF0ZUVkaXRvciA9IHNsYXRlRWRpdG9ycy5nZXQoY29uZmlnLmVkaXRvckFjdG9yKTtcbiAgaWYgKGV4aXN0aW5nU2xhdGVFZGl0b3IpXG4gICAgcmV0dXJuIGRlYnVnJDcoXCJSZXVzaW5nIGV4aXN0aW5nIFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpLCBleGlzdGluZ1NsYXRlRWRpdG9yO1xuICBkZWJ1ZyQ3KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpO1xuICBjb25zdCB1bnN1YnNjcmlwdGlvbnMgPSBbXSwgc3Vic2NyaXB0aW9ucyA9IFtdLCBpbnN0YW5jZSA9IHdpdGhQbHVnaW5zKHdpdGhSZWFjdChjcmVhdGVFZGl0b3IkMSgpKSwge1xuICAgIGVkaXRvckFjdG9yOiBjb25maWcuZWRpdG9yQWN0b3IsXG4gICAgc3Vic2NyaXB0aW9uc1xuICB9KTtcbiAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChpbnN0YW5jZSwge30pO1xuICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBzdWJzY3JpcHRpb25zKVxuICAgIHVuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgY29uc3QgaW5pdGlhbFZhbHVlID0gW2luc3RhbmNlLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgZGVjb3JhdG9yczogW11cbiAgfSldLCBzbGF0ZUVkaXRvciA9IHtcbiAgICBpbnN0YW5jZSxcbiAgICBpbml0aWFsVmFsdWVcbiAgfTtcbiAgcmV0dXJuIHNsYXRlRWRpdG9ycy5zZXQoY29uZmlnLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yO1xufVxuY29uc3QgdG9nZ2xlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICB9KSA/IHJlbW92ZUxpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICAuLi5hY3Rpb24sXG4gICAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJsaXN0IGl0ZW0uYWRkXCJcbiAgICB9XG4gIH0pO1xufSwgcmVtb3ZlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc0xpc3RCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgbGV2ZWw6IDEsXG4gICAgICBsaXN0SXRlbTogYWN0aW9uLmxpc3RJdGVtXG4gICAgfSwge1xuICAgICAgYXRcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBsaXN0SXRlbVxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCA/IHNlbGVjdGVkQmxvY2tzLmV2ZXJ5KChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0SXRlbSkgOiAhMTtcbn1cbmNvbnN0IHRvZ2dsZVN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaXNTdHlsZUFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgfSkgPyByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5hZGRcIlxuICAgIH1cbiAgfSk7XG59LCByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSBjb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0udmFsdWUsIGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhjb250ZXh0KSwgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBhdDogYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBndWFyZHMuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICBmb3IgKGNvbnN0IFssIGF0XSBvZiBzZWxlY3RlZEJsb2NrcylcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9LCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgc3R5bGU6IGFjdGlvbi5zdHlsZVxuICAgIH0sIHtcbiAgICAgIGF0XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gaXNTdHlsZUFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgc3R5bGVcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gIH0pXTtcbiAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEJsb2Nrcy5ldmVyeSgoW25vZGVdKSA9PiBub2RlLnN0eWxlID09PSBzdHlsZSkgOiAhMTtcbn1cbmNvbnN0IGRlYnVnJDYgPSBkZWJ1Z1dpdGhOYW1lKFwiQVBJOmVkaXRhYmxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlRWRpdGFibGVBUEkoZWRpdG9yLCBlZGl0b3JBY3Rvcikge1xuICBjb25zdCB0eXBlcyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWE7XG4gIHJldHVybiB7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImZvY3VzXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJsdXI6ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImJsdXJcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlTWFyazogKG1hcmspID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZUxpc3Q6IChsaXN0SXRlbSkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0eWxlLnRvZ2dsZVwiLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc01hcmtBY3RpdmU6IChtYXJrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNEZWNvcmF0b3JBY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpLCAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtzOiAoKSA9PiAoe1xuICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICB9KS5tYXJrcyB8fCBbXSxcbiAgICB1bmRvOiAoKSA9PiBlZGl0b3IudW5kbygpLFxuICAgIHJlZG86ICgpID0+IGVkaXRvci5yZWRvKCksXG4gICAgc2VsZWN0OiAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBzbGF0ZVNlbGVjdGlvbiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICBzbGF0ZVNlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2xhdGVTZWxlY3Rpb24pIDogVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9LFxuICAgIGZvY3VzQmxvY2s6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICB9XG4gICAgfSxcbiAgICBmb2N1c0NoaWxkOiAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBibG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0uY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzFdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydENoaWxkOiAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlLm5hbWUgIT09IHR5cGVzLnNwYW4ubmFtZSlcbiAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcImluc2VydC5pbmxpbmUgb2JqZWN0XCIsXG4gICAgICAgICAgICBpbmxpbmVPYmplY3Q6IHtcbiAgICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdG9yXG4gICAgICAgIH0pLCB0b1BvcnRhYmxlVGV4dFJhbmdlKGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyk/LmZvY3VzLnBhdGggPz8gW107XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlZGl0b3IgaGFzIG5vIHNlbGVjdGlvblwiKTtcbiAgICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgICBtYXRjaDogKG4pID0+IG4uX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgIH0pKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgIGlmICghZm9jdXNCbG9jaylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZm9jdXNlZCB0ZXh0IGJsb2NrXCIpO1xuICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmICF0eXBlcy5pbmxpbmVPYmplY3RzLnNvbWUoKHQpID0+IHQubmFtZSA9PT0gdHlwZS5uYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0eXBlIGNhbm5vdCBiZSBpbnNlcnRlZCBhcyBhIGNoaWxkIHRvIGEgdGV4dCBibG9ja1wiKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICBfdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgIC4uLnZhbHVlIHx8IHt9XG4gICAgICAgIH1dXG4gICAgICB9XSwge1xuICAgICAgICBzY2hlbWFUeXBlczogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgfSlbMF0uY2hpbGRyZW5bMF0sIGZvY3VzQ2hpbGRQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDIpLCBpc1NwYW5Ob2RlID0gY2hpbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSwgZm9jdXNOb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBmb2N1c0NoaWxkUGF0aCk7XG4gICAgICByZXR1cm4gaXNTcGFuTm9kZSAmJiBmb2N1c05vZGUuX3R5cGUgIT09IHR5cGVzLnNwYW4ubmFtZSAmJiAoZGVidWckNihcIkluc2VydGluZyBzcGFuIGNoaWxkIG5leHQgdG8gaW5saW5lIG9iamVjdCBjaGlsZCwgbW92aW5nIHNlbGVjdGlvbiArIDFcIiksIGVkaXRvci5tb3ZlKHtcbiAgICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCJcbiAgICAgIH0pKSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgIHNlbGVjdDogITAsXG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCksIHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKT8uZm9jdXMucGF0aCB8fCBbXTtcbiAgICB9LFxuICAgIGluc2VydEJsb2NrOiAodHlwZSwgdmFsdWUpID0+IChlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgICAgIGJsb2NrT2JqZWN0OiB7XG4gICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJhdXRvXCJcbiAgICAgIH0sXG4gICAgICBlZGl0b3JcbiAgICB9KSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoID8/IFtdKSxcbiAgICBoYXNCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpc1N0eWxlQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzTGlzdFN0eWxlOiAobGlzdEl0ZW0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNWb2lkOiAoZWxlbWVudCkgPT4gIVt0eXBlcy5ibG9jay5uYW1lLCB0eXBlcy5zcGFuLm5hbWVdLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpLFxuICAgIGZpbmRCeVBhdGg6IChwYXRoKSA9PiB7XG4gICAgICBjb25zdCBzbGF0ZVBhdGggPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sIGVkaXRvcik7XG4gICAgICBpZiAoc2xhdGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2xhdGVQYXRoLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2tQYXRoICYmIHR5cGVvZiBibG9jay5fa2V5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgc2xhdGVQYXRoLmZvY3VzLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lKVswXSwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfV1dO1xuICAgICAgICAgIGNvbnN0IHB0QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhwdEJsb2NrKSkge1xuICAgICAgICAgICAgY29uc3QgcHRDaGlsZCA9IHB0QmxvY2suY2hpbGRyZW5bc2xhdGVQYXRoLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgICAgICAgaWYgKHB0Q2hpbGQpXG4gICAgICAgICAgICAgIHJldHVybiBbcHRDaGlsZCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IHB0Q2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICB9LFxuICAgIGZpbmRET01Ob2RlOiAoZWxlbWVudCkgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbaXRlbV0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogW10sXG4gICAgICAgICAgbWF0Y2g6IChuKSA9PiBuLl9rZXkgPT09IGVsZW1lbnQuX2tleVxuICAgICAgICB9KSB8fCBbXSlbMF0gfHwgW3ZvaWQgMF07XG4gICAgICAgIG5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBpdGVtKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBhY3RpdmVBbm5vdGF0aW9uczogKCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhY3RpdmVBbm5vdGF0aW9ucyA9IFtdLCBzcGFucyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpICYmIG5vZGUubWFya3MgIT09IHZvaWQgMCAmJiBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MubGVuZ3RoID4gMFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBbc3BhbiwgcGF0aF0gb2Ygc3BhbnMpIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2subWFya0RlZnM/LmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICAgICAgVGV4dC5pc1RleHQoc3BhbikgJiYgc3Bhbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpICYmIHNwYW4ubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpICYmIGFjdGl2ZUFubm90YXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlQW5ub3RhdGlvbnM7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNBbm5vdGF0aW9uQWN0aXZlOiAoYW5ub3RhdGlvblR5cGUpID0+IGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gICAgICBlZGl0b3IsXG4gICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgIG5hbWU6IGFubm90YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSksXG4gICAgYWRkQW5ub3RhdGlvbjogKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgcGF0aHM7XG4gICAgICByZXR1cm4gRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgcGF0aHMgPSBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogdHlwZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAgICAgICAgICAgYW5ub3RhdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCksIHBhdGhzO1xuICAgIH0sXG4gICAgZGVsZXRlOiAoc2VsZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgaWYgKCEocmFuZ2UgJiYgcmFuZ2UuYW5jaG9yLnBhdGgubGVuZ3RoID4gMCAmJiByYW5nZS5mb2N1cy5wYXRoLmxlbmd0aCA+IDApKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmFuZ2VcIik7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucz8ubW9kZSB8fCBvcHRpb25zPy5tb2RlID09PSBcInNlbGVjdGVkXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJDYoXCJEZWxldGluZyBjb250ZW50IGluIHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgICAgaGFuZ2luZzogITAsXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zPy5tb2RlID09PSBcImJsb2Nrc1wiICYmIChkZWJ1ZyQ2KFwiRGVsZXRpbmcgYmxvY2tzIHRvdWNoZWQgYnkgc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgfHwgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgfSkpLCBvcHRpb25zPy5tb2RlID09PSBcImNoaWxkcmVuXCIgJiYgKGRlYnVnJDYoXCJEZWxldGluZyBjaGlsZHJlbiB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lIHx8IC8vIFRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKVxuICAgICAgICAgIH0pKSwgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAoZWRpdG9yLmNoaWxkcmVuID0gW2VkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KV0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQW5ub3RhdGlvbjogKHR5cGUpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgICAgICAgYW5ub3RhdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uOiAoKSA9PiB7XG4gICAgICBsZXQgcHRSYW5nZSA9IG51bGw7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICBpZiAoZXhpc3RpbmcpXG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLnNldChlZGl0b3Iuc2VsZWN0aW9uLCBwdFJhbmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdFJhbmdlO1xuICAgIH0sXG4gICAgZ2V0VmFsdWU6ICgpID0+IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLFxuICAgIGlzQ29sbGFwc2VkU2VsZWN0aW9uOiAoKSA9PiAhIWVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgaXNFeHBhbmRlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgaW5zZXJ0QnJlYWs6ICgpID0+IHtcbiAgICAgIGVkaXRvci5pbnNlcnRCcmVhaygpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuZ2V0RnJhZ21lbnQoKSwgdHlwZXMuYmxvY2submFtZSksXG4gICAgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmc6IChzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiB7XG4gICAgICBjb25zdCByYW5nZUEgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uQSwgZWRpdG9yKSwgcmFuZ2VCID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbkIsIGVkaXRvcik7XG4gICAgICByZXR1cm4gUmFuZ2UuaXNSYW5nZShyYW5nZUEpICYmIFJhbmdlLmlzUmFuZ2UocmFuZ2VCKSAmJiBSYW5nZS5pbmNsdWRlcyhyYW5nZUEsIHJhbmdlQik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNBbm5vdGF0aW9uQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBhbm5vdGF0aW9uXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICByZXR1cm4gITE7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3BhbnMgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpXG4gICAgfSldO1xuICAgIGlmIChzcGFucy5sZW5ndGggPT09IDAgfHwgc3BhbnMuc29tZSgoW3NwYW5dKSA9PiAhaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgfHwgIXNwYW4ubWFya3MgfHwgc3Bhbi5tYXJrcz8ubGVuZ3RoID09PSAwKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGlvbk1hcmtEZWZzID0gc3BhbnMucmVkdWNlKChhY2NNYXJrRGVmcywgWywgcGF0aF0pID0+IHtcbiAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2subWFya0RlZnMgPyBbLi4uYWNjTWFya0RlZnMsIC4uLmJsb2NrLm1hcmtEZWZzXSA6IGFjY01hcmtEZWZzO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc3BhbnMuZXZlcnkoKFtzcGFuXSkgPT4gaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgPyBzcGFuLm1hcmtzPy5tYXAoKG1hcmtLZXkpID0+IHNlbGVjdGlvbk1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmPy5fa2V5ID09PSBtYXJrS2V5KT8uX3R5cGUpPy5pbmNsdWRlcyhhbm5vdGF0aW9uLm5hbWUpIDogITEpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCB7XG4gICAgc2VsZWN0aW9uOiBvcmlnaW5hbFNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBsZXQgcGF0aHM7XG4gIGlmIChvcmlnaW5hbFNlbGVjdGlvbiAmJiAoUmFuZ2UuaXNDb2xsYXBzZWQob3JpZ2luYWxTZWxlY3Rpb24pICYmIChlZGl0b3IucHRlRXhwYW5kVG9Xb3JkKCksIGVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICBsZXQgc3BhblBhdGgsIG1hcmtEZWZQYXRoO1xuICAgIGNvbnN0IG1hcmtEZWZQYXRocyA9IFtdO1xuICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSksXG4gICAgICByZXZlcnNlOiBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gb2Ygc2VsZWN0ZWRCbG9ja3MpIHtcbiAgICAgIGlmIChibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYW5ub3RhdGlvbktleSA9IGNvbnRleHQua2V5R2VuZXJhdG9yKCksIG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW107XG4gICAgICBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lICYmIG1hcmtEZWYuX2tleSA9PT0gYW5ub3RhdGlvbktleSkgPT09IHZvaWQgMCAmJiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywge1xuICAgICAgICAgIF90eXBlOiBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGFubm90YXRpb25LZXksXG4gICAgICAgICAgLi4uYWN0aW9uLmFubm90YXRpb24udmFsdWVcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGJsb2NrUGF0aFxuICAgICAgfSksIG1hcmtEZWZQYXRoID0gW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJtYXJrRGVmc1wiLCB7XG4gICAgICAgIF9rZXk6IGFubm90YXRpb25LZXlcbiAgICAgIH1dLCBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pID8gbWFya0RlZlBhdGhzLnVuc2hpZnQobWFya0RlZlBhdGgpIDogbWFya0RlZlBhdGhzLnB1c2gobWFya0RlZlBhdGgpKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNwYW4pIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBwYXRoKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyayAmJiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lKSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IFsuLi5tYXJrcy5maWx0ZXIoKG1hcmspID0+ICFleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpLCBhbm5vdGF0aW9uS2V5XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIHNwYW5QYXRoID0gW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwYW4uX2tleVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0RlZlBhdGggJiYgc3BhblBhdGggJiYgKHBhdGhzID0ge1xuICAgICAgbWFya0RlZlBhdGgsXG4gICAgICBtYXJrRGVmUGF0aHMsXG4gICAgICBzcGFuUGF0aFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRocztcbn0sIHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yO1xuICBpZiAoZGVidWckNihcIlJlbW92aW5nIGFubm90YXRpb25cIiwgYWN0aW9uLmFubm90YXRpb24ubmFtZSksICEhZWRpdG9yLnNlbGVjdGlvbilcbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBvdGVudGlhbEFubm90YXRpb25zID0gKGJsb2NrLm1hcmtEZWZzID8/IFtdKS5maWx0ZXIoKG1hcmtEZWYpID0+IG1hcmtEZWYuX3R5cGUgPT09IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAyXG4gICAgICB9KTtcbiAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oc2VsZWN0ZWRDaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGFubm90YXRpb25Ub1JlbW92ZSA9IHNlbGVjdGVkQ2hpbGQubWFya3M/LmZpbmQoKG1hcmspID0+IHBvdGVudGlhbEFubm90YXRpb25zLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKCFhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgsIHtcbiAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgIH0pKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNCZWZvcmUoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgcHJldmlvdXNTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbi5wdXNoKFtjaGlsZCwgY2hpbGRQYXRoXSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNlbGVjdGVkQ2hpbGRQYXRoKSlcbiAgICAgICAgICBpZiAoY2hpbGQubWFya3M/LmluY2x1ZGVzKGFubm90YXRpb25Ub1JlbW92ZSkpXG4gICAgICAgICAgICBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgWy4uLnByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24sIFtzZWxlY3RlZENoaWxkLCBzZWxlY3RlZENoaWxkUGF0aF0sIC4uLm5leHRTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbl0pXG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IGNoaWxkLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IG1hcmsgIT09IGFubm90YXRpb25Ub1JlbW92ZSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpLFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIGJsb2Nrcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBjaGlsZFBhdGgpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXSwgbWFya3MgPSBjaGlsZC5tYXJrcyA/PyBbXSwgbWFya3NXaXRob3V0QW5ub3RhdGlvbiA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gbWFya0RlZnMuZmluZCgobWFya0RlZjIpID0+IG1hcmtEZWYyLl9rZXkgPT09IG1hcmspPy5fdHlwZSAhPT0gYWN0aW9uLmFubm90YXRpb24ubmFtZSk7XG4gICAgICAgICAgbWFya3NXaXRob3V0QW5ub3RhdGlvbi5sZW5ndGggIT09IG1hcmtzLmxlbmd0aCAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59LCB0b2dnbGVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaWYgKGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIGFubm90YXRpb246IHtcbiAgICAgIG5hbWU6IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWVcbiAgICB9XG4gIH0pKVxuICAgIHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICBjb250ZXh0LFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5yZW1vdmVcIixcbiAgICAgICAgYW5ub3RhdGlvbjogYWN0aW9uLmFubm90YXRpb24sXG4gICAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvclxuICAgICAgfVxuICAgIH0pO1xuICBlbHNlXG4gICAgcmV0dXJuIGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICBjb250ZXh0LFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgICAgYW5ub3RhdGlvbjogYWN0aW9uLmFubm90YXRpb24sXG4gICAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvclxuICAgICAgfVxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGluc2VydEJsb2NrKHtcbiAgYmxvY2ssXG4gIHBsYWNlbWVudCxcbiAgZWRpdG9yLFxuICBzY2hlbWFcbn0pIHtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgbWF0Y2g6IChuKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pXG4gICAgfSkpWzBdID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCBuZXh0UGF0aCA9IFtmb2N1c0Jsb2NrUGF0aFswXSArIDFdO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGJsb2NrLCB7XG4gICAgICAgIGF0OiBuZXh0UGF0aFxuICAgICAgfSksIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dFBhdGhbMF0sIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0UGF0aFswXSwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBwbGFjZW1lbnQgPT09IFwiYmVmb3JlXCIgPyBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2ssIHtcbiAgICAgIGF0OiBmb2N1c0Jsb2NrUGF0aFxuICAgIH0pIDogRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBibG9jayk7XG4gICAgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja10sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBmb2N1c0Jsb2NrUGF0aFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RCbG9jayA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IChuKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgYXQ6IFtdLFxuICAgICAgcmV2ZXJzZTogITBcbiAgICB9KSlbMF07XG4gICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBibG9jayksIGxhc3RCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbbGFzdEJsb2NrWzBdXSwgc2NoZW1hKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGxhc3RCbG9ja1sxXVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBpbnNlcnRCbG9ja09iamVjdEFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICBfdHlwZTogYWN0aW9uLmJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgLi4uYWN0aW9uLmJsb2NrT2JqZWN0LnZhbHVlID8gYWN0aW9uLmJsb2NrT2JqZWN0LnZhbHVlIDoge31cbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlczogY29udGV4dC5zY2hlbWFcbiAgfSlbMF07XG4gIGluc2VydEJsb2NrKHtcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IGFjdGlvbi5wbGFjZW1lbnQsXG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgfSk7XG59LCBpbnNlcnRCcmVha0FjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGtleUdlbmVyYXRvciA9IGNvbnRleHQua2V5R2VuZXJhdG9yLCBzY2hlbWEgPSBjb250ZXh0LnNjaGVtYSwgZWRpdG9yID0gYWN0aW9uLmVkaXRvcjtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgW2ZvY3VzU3Bhbl0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLFxuICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgdm9pZHM6ICExXG4gIH0pKVswXSA/PyBbdm9pZCAwXSwgZm9jdXNEZWNvcmF0b3JzID0gZm9jdXNTcGFuPy5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBzY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0Fubm90YXRpb25zID0gZm9jdXNTcGFuPy5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspKSA/PyBbXSwgYW5jaG9yQmxvY2tQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAxKSwgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhlZGl0b3Iuc2VsZWN0aW9uKSwgbGFzdEZvY3VzQmxvY2tDaGlsZCA9IGZvY3VzQmxvY2suY2hpbGRyZW5bZm9jdXNCbG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXSwgYXRUaGVFbmRPZkJsb2NrID0gaXNFcXVhbChzdGFydCwge1xuICAgICAgcGF0aDogWy4uLmZvY3VzQmxvY2tQYXRoLCBmb2N1c0Jsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDFdLFxuICAgICAgb2Zmc2V0OiBlZGl0b3IuaXNUZXh0U3BhbihsYXN0Rm9jdXNCbG9ja0NoaWxkKSA/IGxhc3RGb2N1c0Jsb2NrQ2hpbGQudGV4dC5sZW5ndGggOiAwXG4gICAgfSksIGF0VGhlU3RhcnRPZkJsb2NrID0gaXNFcXVhbChlbmQsIHtcbiAgICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrUGF0aCwgMF0sXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbiAgICBpZiAoYXRUaGVFbmRPZkJsb2NrICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICBkZWNvcmF0b3JzOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdFRoZVN0YXJ0T2ZCbG9jayAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgZGVjb3JhdG9yczogZm9jdXNBbm5vdGF0aW9ucy5sZW5ndGggPT09IDAgPyBmb2N1c0RlY29yYXRvcnMgOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBbbmV4dEJsb2NrUGF0aF0gPSBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb25BY3Jvc3NCbG9ja3MgPSBhbmNob3JCbG9ja1BhdGhbMF0gIT09IGZvY3VzQmxvY2tQYXRoWzBdO1xuICAgIGlmICghYXRUaGVTdGFydE9mQmxvY2sgJiYgIWF0VGhlRW5kT2ZCbG9jayAmJiAhc2VsZWN0aW9uQWNyb3NzQmxvY2tzKSB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFtuZXh0Tm9kZSwgbmV4dE5vZGVQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5uZXh0KGZvY3VzQmxvY2tQYXRoKSwge1xuICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBbLi4ubmV4dE5vZGVQYXRoLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IFsuLi5uZXh0Tm9kZVBhdGgsIDBdLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgZWRpdG9yLmlzVGV4dEJsb2NrKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5tYXJrRGVmcyAmJiBuZXh0Tm9kZS5tYXJrRGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3TWFya0RlZktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBwcmV2Tm9kZVNwYW5zID0gQXJyYXkuZnJvbShOb2RlLmNoaWxkcmVuKGVkaXRvciwgZm9jdXNCbG9ja1BhdGgpKS5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSkuZmlsdGVyKChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSksIGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIG5leHROb2RlUGF0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gY2hpbGQubWFya3MgPz8gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpXG4gICAgICAgICAgICAgIHNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBtYXJrKSB8fCBwcmV2Tm9kZVNwYW5zLnNvbWUoKHByZXZOb2RlU3BhbikgPT4gcHJldk5vZGVTcGFuLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkgJiYgIW5ld01hcmtEZWZLZXlzLmhhcyhtYXJrKSAmJiBuZXdNYXJrRGVmS2V5cy5zZXQobWFyaywga2V5R2VuZXJhdG9yKCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3TWFya3MgPSBtYXJrcy5tYXAoKG1hcmspID0+IG5ld01hcmtEZWZLZXlzLmdldChtYXJrKSA/PyBtYXJrKTtcbiAgICAgICAgICAgIGlzRXF1YWwobWFya3MsIG5ld01hcmtzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBtYXJrczogbmV3TWFya3NcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld01hcmtEZWZzID0gbmV4dE5vZGUubWFya0RlZnMubWFwKChtYXJrRGVmKSA9PiAoe1xuICAgICAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgICAgIF9rZXk6IG5ld01hcmtEZWZLZXlzLmdldChtYXJrRGVmLl9rZXkpID8/IG1hcmtEZWYuX2tleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpc0VxdWFsKG5leHROb2RlLm1hcmtEZWZzLCBuZXdNYXJrRGVmcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBuZXh0Tm9kZVBhdGgsXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6ICEwXG4gIH0pO1xufSwgaW5zZXJ0U29mdEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb246IHtcbiAgICAgIC4uLmFjdGlvbixcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJyZWFrXCJcbiAgICB9XG4gIH0pO1xufSwgaW5zZXJ0SW5saW5lT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaWYgKCFjb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLnNvbWUoKGlubGluZU9iamVjdCkgPT4gaW5saW5lT2JqZWN0Lm5hbWUgPT09IGFjdGlvbi5pbmxpbmVPYmplY3QubmFtZSkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCB1bmtub3duIGlubGluZSBvYmplY3RcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCBpbmxpbmUgb2JqZWN0IHdpdGhvdXQgc2VsZWN0aW9uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNUZXh0QmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSkuYXQoMCkgPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c1RleHRCbG9jaykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyB0ZXh0IGJsb2NrXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGlsZCA9IHRvU2xhdGVWYWx1ZShbe1xuICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICBfdHlwZTogYWN0aW9uLmlubGluZU9iamVjdC5uYW1lLFxuICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIC4uLmFjdGlvbi5pbmxpbmVPYmplY3QudmFsdWUgPz8ge31cbiAgICB9XVxuICB9XSwge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KS5hdCgwKT8uY2hpbGRyZW4uYXQoMCk7XG4gIGlmICghY2hpbGQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCBpbmxpbmUgb2JqZWN0XCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGFjdGlvbi5lZGl0b3IsIGNoaWxkKTtcbn0sIGluc2VydFNwYW5BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IHNlbGVjdGlvblwiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c0Jsb2NrIHx8ICFmb2N1c0Jsb2NrUGF0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyBibG9ja1wiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXJrRGVmcyA9IGZvY3VzQmxvY2subWFya0RlZnMgPz8gW10sIGFubm90YXRpb25zID0gYWN0aW9uLmFubm90YXRpb25zID8gYWN0aW9uLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICBfdHlwZTogYW5ub3RhdGlvbi5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgLi4uYW5ub3RhdGlvbi52YWx1ZVxuICB9KSkgOiB2b2lkIDA7XG4gIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywgLi4uYW5ub3RhdGlvbnNdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICB0ZXh0OiBhY3Rpb24udGV4dCxcbiAgICBtYXJrczogWy4uLmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+IGFubm90YXRpb24uX2tleSkgPz8gW10sIC4uLmFjdGlvbi5kZWNvcmF0b3JzID8/IFtdXVxuICB9KTtcbn0sIHRleHRCbG9ja1NldEFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGF0ID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH1cbiAgfSwgYWN0aW9uLmVkaXRvcik7XG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIC4uLmFjdGlvbi5zdHlsZSA/IHtcbiAgICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgICB9IDoge30sXG4gICAgLi4uYWN0aW9uLmxpc3RJdGVtID8ge1xuICAgICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICAgIH0gOiB7fSxcbiAgICAuLi5hY3Rpb24ubGV2ZWwgPyB7XG4gICAgICBsZXZlbDogYWN0aW9uLmxldmVsXG4gICAgfSA6IHt9XG4gIH0sIHtcbiAgICBhdFxuICB9KTtcbn0sIHRleHRCbG9ja1Vuc2V0QWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgYXQgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aDogYWN0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aDogYWN0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LCBhY3Rpb24uZWRpdG9yKTtcbiAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi5wcm9wcywge1xuICAgIGF0XG4gIH0pO1xufSwgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMgPSB7XG4gIFwiYW5ub3RhdGlvbi5hZGRcIjogYWRkQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImFubm90YXRpb24ucmVtb3ZlXCI6IHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOiB0b2dnbGVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIGJsdXI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBSZWFjdEVkaXRvci5ibHVyKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcImRlY29yYXRvci5hZGRcIjogYWRkRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHRvZ2dsZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBmb2N1czogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIFJlYWN0RWRpdG9yLmZvY3VzKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcImRlbGV0ZS5iYWNrd2FyZFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZGVsZXRlQmFja3dhcmQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnVuaXQpO1xuICB9LFxuICBcImRlbGV0ZS5mb3J3YXJkXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBkZWxldGVGb3J3YXJkKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi51bml0KTtcbiAgfSxcbiAgXCJkZWxldGUuYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9LCBhY3Rpb24uZWRpdG9yKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGZpbmQgU2xhdGUgcmFuZ2UgZnJvbSBzZWxlY3Rpb24gcG9pbnRzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImRlbGV0ZS50ZXh0XCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoYWN0aW9uLmVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGFjdGlvbi5lZGl0b3IpKSwgYW5jaG9yID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uYW5jaG9yXG4gICAgfSksIGZvY3VzID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uZm9jdXNcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBhbmNob3Igb3IgZm9jdXMgc2VsZWN0aW9uIHBvaW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBTbGF0ZSByYW5nZSBmcm9tIHNlbGVjdGlvbiBwb2ludHNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImluc2VydC5ibG9jayBvYmplY3RcIjogaW5zZXJ0QmxvY2tPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuYnJlYWtcIjogaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiBpbnNlcnRJbmxpbmVPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuc29mdCBicmVha1wiOiBpbnNlcnRTb2Z0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuc3BhblwiOiBpbnNlcnRTcGFuQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnRleHRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGluc2VydFRleHQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnRleHQpO1xuICB9LFxuICBcImluc2VydC50ZXh0IGJsb2NrXCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICBzdHlsZTogY29udGV4dC5zY2hlbWEuc3R5bGVzWzBdLnZhbHVlID8/IFwibm9ybWFsXCIsXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBjaGlsZHJlbjogYWN0aW9uLnRleHRCbG9jaz8uY2hpbGRyZW4/Lm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAgIC4uLmNoaWxkLFxuICAgICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICB9KSkgPz8gW3tcbiAgICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIlxuICAgICAgfV1cbiAgICB9XSwge1xuICAgICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gICAgfSlbMF07XG4gICAgaW5zZXJ0QmxvY2soe1xuICAgICAgYmxvY2ssXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgcGxhY2VtZW50OiBhY3Rpb24ucGxhY2VtZW50XG4gICAgfSk7XG4gIH0sXG4gIGVmZmVjdDogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGFjdGlvbi5lZmZlY3QoKTtcbiAgfSxcbiAgXCJsaXN0IGl0ZW0uYWRkXCI6IGFkZExpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwibGlzdCBpdGVtLnJlbW92ZVwiOiByZW1vdmVMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImxpc3QgaXRlbS50b2dnbGVcIjogdG9nZ2xlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJtb3ZlLmJsb2NrXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBhdCA9IFt0b1NsYXRlUGF0aChhY3Rpb24uYXQsIGFjdGlvbi5lZGl0b3IpWzBdXSwgdG8gPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLnRvLCBhY3Rpb24uZWRpdG9yKVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIFwibW92ZS5ibG9jayBkb3duXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBhdCA9IFt0b1NsYXRlUGF0aChhY3Rpb24uYXQsIGFjdGlvbi5lZGl0b3IpWzBdXSwgdG8gPSBbUGF0aC5uZXh0KGF0KVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIFwibW92ZS5ibG9jayB1cFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgYXQgPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLmF0LCBhY3Rpb24uZWRpdG9yKVswXV07XG4gICAgaWYgKCFQYXRoLmhhc1ByZXZpb3VzKGF0KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0byA9IFtQYXRoLnByZXZpb3VzKGF0KVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIG5vb3A6ICgpID0+IHtcbiAgfSxcbiAgc2VsZWN0OiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdG9TbGF0ZVJhbmdlKGFjdGlvbi5zZWxlY3Rpb24sIGFjdGlvbi5lZGl0b3IpO1xuICAgIG5ld1NlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGFjdGlvbi5lZGl0b3IsIG5ld1NlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcInNlbGVjdC5wcmV2aW91cyBibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgaWYgKCFhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBzZWxlY3QgcHJldmlvdXMgYmxvY2sgd2l0aG91dCBhIHNlbGVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tQYXRoID0gYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKTtcbiAgICBpZiAoIVBhdGguaGFzUHJldmlvdXMoYmxvY2tQYXRoKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRoZXJlJ3Mgbm8gcHJldmlvdXMgYmxvY2sgdG8gc2VsZWN0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Jsb2NrUGF0aCA9IFBhdGgucHJldmlvdXMoYmxvY2tQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChhY3Rpb24uZWRpdG9yLCBwcmV2aW91c0Jsb2NrUGF0aCk7XG4gIH0sXG4gIFwic2VsZWN0Lm5leHQgYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gc2VsZWN0IG5leHQgYmxvY2sgd2l0aG91dCBhIHNlbGVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dEJsb2NrUGF0aCA9IFthY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpWzBdICsgMV07XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoYWN0aW9uLmVkaXRvciwgbmV4dEJsb2NrUGF0aCk7XG4gIH0sXG4gIFwic3R5bGUudG9nZ2xlXCI6IHRvZ2dsZVN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwic3R5bGUuYWRkXCI6IGFkZFN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwic3R5bGUucmVtb3ZlXCI6IHJlbW92ZVN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwidGV4dCBibG9jay5zZXRcIjogdGV4dEJsb2NrU2V0QWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwidGV4dCBibG9jay51bnNldFwiOiB0ZXh0QmxvY2tVbnNldEFjdGlvbkltcGxlbWVudGF0aW9uXG59O1xuZnVuY3Rpb24gcGVyZm9ybUFjdGlvbih7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImFubm90YXRpb24udG9nZ2xlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi50b2dnbGVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWNvcmF0b3IuYWRkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVjb3JhdG9yLmFkZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlY29yYXRvci5yZW1vdmVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWNvcmF0b3IucmVtb3ZlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlLmJsb2NrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlLnRleHRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUudGV4dFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5zcGFuXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnNwYW5cIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQudGV4dCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC50ZXh0IGJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibGlzdCBpdGVtLmFkZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImxpc3QgaXRlbS5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJsaXN0IGl0ZW0ucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibGlzdCBpdGVtLnJlbW92ZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1vdmUuYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJtb3ZlLmJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayBkb3duXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5ibG9jayBkb3duXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayB1cFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcIm1vdmUuYmxvY2sgdXBcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJub29wXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZWZmZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLmVmZmVjdCh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5zZWxlY3Qoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3QubmV4dCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNlbGVjdC5uZXh0IGJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic3R5bGUuYWRkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wic3R5bGUuYWRkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic3R5bGUucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wic3R5bGUucmVtb3ZlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGV4dCBibG9jay5zZXRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJ0ZXh0IGJsb2NrLnNldFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRleHQgYmxvY2sudW5zZXRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJ0ZXh0IGJsb2NrLnVuc2V0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcGVyZm9ybURlZmF1bHRBY3Rpb24oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtRGVmYXVsdEFjdGlvbih7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24ucmVtb3ZlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYmx1clwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5ibHVyKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVjb3JhdG9yLnRvZ2dsZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci50b2dnbGVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWxldGUuYmFja3dhcmRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUuYmFja3dhcmRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWxldGUuZm9yd2FyZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZS5mb3J3YXJkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZm9jdXNcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuZm9jdXMoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LmJsb2NrIG9iamVjdFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5pbmxpbmUgb2JqZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LmlubGluZSBvYmplY3RcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQuYnJlYWtcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuYnJlYWtcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQuc29mdCBicmVha1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5zb2Z0IGJyZWFrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LnRleHRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQudGV4dFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImxpc3QgaXRlbS50b2dnbGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJsaXN0IGl0ZW0udG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2VsZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLnNlbGVjdCh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wic3R5bGUudG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRGVjb3JhdG9ycyh7XG4gIHNjaGVtYSxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICBjb25zdCBkZWNvcmF0b3JzID0gc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSk7XG4gIHJldHVybiAoe1xuICAgIC4uLkVkaXRvci5tYXJrcyhzbGF0ZUVkaXRvckluc3RhbmNlKSA/PyB7fVxuICB9Lm1hcmtzID8/IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdG9yU25hcHNob3Qoe1xuICBlZGl0b3IsXG4gIGtleUdlbmVyYXRvcixcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBzZWxlY3Rpb24gPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBlZGl0b3Iuc2VsZWN0aW9uLCBzY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGFjdGl2ZURlY29yYXRvcnM6IGdldEFjdGl2ZURlY29yYXRvcnMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IGVkaXRvclxuICAgICAgfSksXG4gICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICBzY2hlbWEsXG4gICAgICBzZWxlY3Rpb24sXG4gICAgICB2YWx1ZVxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGVkaXRvck1hY2hpbmUgPSBzZXR1cCh7XG4gIHR5cGVzOiB7XG4gICAgY29udGV4dDoge30sXG4gICAgZXZlbnRzOiB7fSxcbiAgICBlbWl0dGVkOiB7fSxcbiAgICBpbnB1dDoge31cbiAgfSxcbiAgYWN0aW9uczoge1xuICAgIFwiYWRkIGJlaGF2aW9yIHRvIGNvbnRleHRcIjogYXNzaWduKHtcbiAgICAgIGJlaGF2aW9yczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJhZGQgYmVoYXZpb3JcIiksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5jb250ZXh0LmJlaGF2aW9ycywgZXZlbnQuYmVoYXZpb3JdKSlcbiAgICB9KSxcbiAgICBcInJlbW92ZSBiZWhhdmlvciBmcm9tIGNvbnRleHRcIjogYXNzaWduKHtcbiAgICAgIGJlaGF2aW9yczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJyZW1vdmUgYmVoYXZpb3JcIiksIGNvbnRleHQuYmVoYXZpb3JzLmRlbGV0ZShldmVudC5iZWhhdmlvciksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5jb250ZXh0LmJlaGF2aW9yc10pKVxuICAgIH0pLFxuICAgIFwiYXNzaWduIGJlaGF2aW9yc1wiOiBhc3NpZ24oe1xuICAgICAgYmVoYXZpb3JzOiAoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInVwZGF0ZSBiZWhhdmlvcnNcIiksIG5ldyBTZXQoZXZlbnQuYmVoYXZpb3JzKSlcbiAgICB9KSxcbiAgICBcImFzc2lnbiBzY2hlbWFcIjogYXNzaWduKHtcbiAgICAgIHNjaGVtYTogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgc2NoZW1hXCIpLCBldmVudC5zY2hlbWEpXG4gICAgfSksXG4gICAgXCJlbWl0IHBhdGNoIGV2ZW50XCI6IGVtaXQoKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBhdGNoXCIpLCBldmVudCkpLFxuICAgIFwiZW1pdCBtdXRhdGlvbiBldmVudFwiOiBlbWl0KCh7XG4gICAgICBldmVudFxuICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtdXRhdGlvblwiKSwgZXZlbnQpKSxcbiAgICBcImVtaXQgcmVhZCBvbmx5XCI6IGVtaXQoe1xuICAgICAgdHlwZTogXCJyZWFkIG9ubHlcIlxuICAgIH0pLFxuICAgIFwiZW1pdCBlZGl0YWJsZVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwiZWRpdGFibGVcIlxuICAgIH0pLFxuICAgIFwiZGVmZXIgZXZlbnRcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6ICh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFtcInBhdGNoXCIsIFwibXV0YXRpb25cIl0pLCBbLi4uY29udGV4dC5wZW5kaW5nRXZlbnRzLCBldmVudF0pXG4gICAgfSksXG4gICAgXCJlbWl0IHBlbmRpbmcgZXZlbnRzXCI6IGVucXVldWVBY3Rpb25zKCh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZW5xdWV1ZVxuICAgIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgY29udGV4dC5wZW5kaW5nRXZlbnRzKVxuICAgICAgICBlbnF1ZXVlKGVtaXQoZXZlbnQpKTtcbiAgICB9KSxcbiAgICBcImVtaXQgcmVhZHlcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcInJlYWR5XCJcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgZXZlbnRzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nRXZlbnRzOiBbXVxuICAgIH0pLFxuICAgIFwiaGFuZGxlIGJlaGF2aW9yIGV2ZW50XCI6IGVucXVldWVBY3Rpb25zKCh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFtcImJlaGF2aW9yIGV2ZW50XCIsIFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCJdKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRBY3Rpb24gPSBldmVudC50eXBlID09PSBcImN1c3RvbSBiZWhhdmlvciBldmVudFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJjb3B5XCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS5kb3duXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS51cFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiID8gdm9pZCAwIDoge1xuICAgICAgICAuLi5ldmVudC5iZWhhdmlvckV2ZW50LFxuICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgfSwgZGVmYXVsdEFjdGlvbkNhbGxiYWNrID0gZXZlbnQudHlwZSA9PT0gXCJiZWhhdmlvciBldmVudFwiID8gZXZlbnQuZGVmYXVsdEFjdGlvbkNhbGxiYWNrIDogdm9pZCAwLCBldmVudEJlaGF2aW9ycyA9IFsuLi5jb250ZXh0LmJlaGF2aW9ycy52YWx1ZXMoKV0uZmlsdGVyKChiZWhhdmlvcikgPT4gYmVoYXZpb3Iub24gPT09IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSk7XG4gICAgICBpZiAoZXZlbnRCZWhhdmlvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChkZWZhdWx0QWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICB3aXRoQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBY3Rpb25DYWxsYmFjaygpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBQZXJmb3JtaW5nIGFjdGlvbiBcIiR7ZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZmF1bHRBY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB3aXRoQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBlcmZvcm1BY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBkZWZhdWx0QWN0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoYFBlcmZvcm1pbmcgYWN0aW9uIFwiJHtkZWZhdWx0QWN0aW9uLnR5cGV9XCIgYXMgYSByZXN1bHQgb2YgXCIke2V2ZW50LmJlaGF2aW9yRXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgZXZlbnQuZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvclNuYXBzaG90ID0gY3JlYXRlRWRpdG9yU25hcHNob3Qoe1xuICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvcixcbiAgICAgICAga2V5R2VuZXJhdG9yOiBjb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSk7XG4gICAgICBsZXQgYmVoYXZpb3JPdmVyd3JpdHRlbiA9ICExO1xuICAgICAgZm9yIChjb25zdCBldmVudEJlaGF2aW9yIG9mIGV2ZW50QmVoYXZpb3JzKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFJ1biA9IGV2ZW50QmVoYXZpb3IuZ3VhcmQgPT09IHZvaWQgMCB8fCBldmVudEJlaGF2aW9yLmd1YXJkKHtcbiAgICAgICAgICBjb250ZXh0OiBlZGl0b3JTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIGV2ZW50OiBldmVudC5iZWhhdmlvckV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYWN0aW9uSW50ZW5kU2V0cyA9IGV2ZW50QmVoYXZpb3IuYWN0aW9ucy5tYXAoKGFjdGlvblNldCkgPT4gYWN0aW9uU2V0KHtcbiAgICAgICAgICBjb250ZXh0OiBlZGl0b3JTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgICAgIGV2ZW50OiBldmVudC5iZWhhdmlvckV2ZW50XG4gICAgICAgIH0sIHNob3VsZFJ1bikpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbkludGVuZHMgb2YgYWN0aW9uSW50ZW5kU2V0cylcbiAgICAgICAgICBiZWhhdmlvck92ZXJ3cml0dGVuID0gYmVoYXZpb3JPdmVyd3JpdHRlbiB8fCBhY3Rpb25JbnRlbmRzLmxlbmd0aCA+IDAgJiYgYWN0aW9uSW50ZW5kcy5zb21lKChhY3Rpb25JbnRlbmQpID0+IGFjdGlvbkludGVuZC50eXBlICE9PSBcImVmZmVjdFwiKSwgd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb25JbnRlbmQgb2YgYWN0aW9uSW50ZW5kcykge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25JbnRlbmQudHlwZSA9PT0gXCJyYWlzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBpc0N1c3RvbUJlaGF2aW9yRXZlbnQoYWN0aW9uSW50ZW5kLmV2ZW50KSA/IGVucXVldWUucmFpc2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImN1c3RvbSBiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiBhY3Rpb25JbnRlbmQuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcjogZXZlbnQuZWRpdG9yXG4gICAgICAgICAgICAgICAgICB9KSA6IGVucXVldWUucmFpc2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IGFjdGlvbkludGVuZC5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbkludGVuZCxcbiAgICAgICAgICAgICAgICAgIGVkaXRvcjogZXZlbnQuZWRpdG9yXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcGVyZm9ybUFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IEVycm9yKGBQZXJmb3JtaW5nIGFjdGlvbiBcIiR7YWN0aW9uLnR5cGV9XCIgYXMgYSByZXN1bHQgb2YgXCIke2V2ZW50LmJlaGF2aW9yRXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgZXZlbnQuZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIGlmIChiZWhhdmlvck92ZXJ3cml0dGVuKSB7XG4gICAgICAgICAgZXZlbnQubmF0aXZlRXZlbnQ/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghYmVoYXZpb3JPdmVyd3JpdHRlbikge1xuICAgICAgICBpZiAoZGVmYXVsdEFjdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgd2l0aEFwcGx5aW5nQmVoYXZpb3JBY3Rpb25zKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWN0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBFcnJvcihgUGVyZm9ybWluZyBcIiR7ZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlfVwiIGZhaWxlZCBkdWUgdG86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZmF1bHRBY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB3aXRoQXBwbHlpbmdCZWhhdmlvckFjdGlvbnMoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBlcmZvcm1BY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBkZWZhdWx0QWN0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihuZXcgRXJyb3IoYFBlcmZvcm1pbmcgYWN0aW9uIFwiJHtkZWZhdWx0QWN0aW9uLnR5cGV9XCIgYXMgYSByZXN1bHQgb2YgXCIke2V2ZW50LmJlaGF2aW9yRXZlbnQudHlwZX1cIiBmYWlsZWQgZHVlIHRvOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgZXZlbnQuZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcImVkaXRvclwiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgYmVoYXZpb3JzOiBuZXcgU2V0KGlucHV0LmJlaGF2aW9ycyA/PyBjb3JlQmVoYXZpb3JzKSxcbiAgICBrZXlHZW5lcmF0b3I6IGlucHV0LmtleUdlbmVyYXRvcixcbiAgICBwZW5kaW5nRXZlbnRzOiBbXSxcbiAgICBzY2hlbWE6IGlucHV0LnNjaGVtYSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgaW5pdGlhbFJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSA/PyAhMSxcbiAgICBtYXhCbG9ja3M6IGlucHV0Lm1heEJsb2NrcyxcbiAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgfSksXG4gIG9uOiB7XG4gICAgXCJhZGQgYmVoYXZpb3JcIjoge1xuICAgICAgYWN0aW9uczogXCJhZGQgYmVoYXZpb3IgdG8gY29udGV4dFwiXG4gICAgfSxcbiAgICBcInJlbW92ZSBiZWhhdmlvclwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSBiZWhhdmlvciBmcm9tIGNvbnRleHRcIlxuICAgIH0sXG4gICAgdW5zZXQ6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhY3Rpb25zOiBbYXNzaWduKHtcbiAgICAgICAgc2VsZWN0aW9uOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LnNlbGVjdGlvblxuICAgICAgfSksIGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KV1cbiAgICB9LFxuICAgIGJsdXJyZWQ6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgZm9jdXNlZDoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBsb2FkaW5nOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KHtcbiAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwYXRjaGVzOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIFwiZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImRvbmUgbG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgYmVoYXZpb3JzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYXNzaWduIGJlaGF2aW9yc1wiXG4gICAgfSxcbiAgICBcInVwZGF0ZSBzY2hlbWFcIjoge1xuICAgICAgYWN0aW9uczogXCJhc3NpZ24gc2NoZW1hXCJcbiAgICB9LFxuICAgIFwidXBkYXRlIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIHZhbHVlOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LnZhbHVlXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgbWF4QmxvY2tzXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIG1heEJsb2NrczogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5tYXhCbG9ja3NcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB0eXBlOiBcInBhcmFsbGVsXCIsXG4gIHN0YXRlczoge1xuICAgIFwiZWRpdCBtb2RlXCI6IHtcbiAgICAgIGluaXRpYWw6IFwicmVhZCBvbmx5XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJyZWFkIG9ubHlcIjoge1xuICAgICAgICAgIGluaXRpYWw6IFwiZGV0ZXJtaW5lIGluaXRpYWwgZWRpdCBtb2RlXCIsXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBcImRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgXCJkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxSZWFkT25seVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVhZCBvbmx5XCI6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgIH0pID0+ICFldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBlZGl0YWJsZVwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCByZWFkIG9ubHlcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY3VzdG9tIGJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYW5ub3RhdGlvbi4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiY3VzdG9tLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImN1c3RvbS4qXCIsXG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkZWNvcmF0b3IuKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpbnNlcnQuKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImxpc3QgaXRlbS4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzdHlsZS4qXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0dXA6IHtcbiAgICAgIGluaXRpYWw6IFwic2V0dGluZyB1cFwiLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIFwic2V0dGluZyB1cFwiOiB7XG4gICAgICAgICAgZXhpdDogW1wiZW1pdCByZWFkeVwiXSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJwcmlzdGluZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmlzdGluZToge1xuICAgICAgICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgaWRsZToge1xuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6aW5nOiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLnNldHVwLmRpcnR5XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5zZXR1cC5kaXJ0eVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcImRvbmUgbm9ybWFsaXppbmdcIjoge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlydHk6IHtcbiAgICAgICAgICBlbnRyeTogW1wiZW1pdCBwZW5kaW5nIGV2ZW50c1wiLCBcImNsZWFyIHBlbmRpbmcgZXZlbnRzXCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImVtaXQgcGF0Y2ggZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGF0aW9uOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZW1pdCBtdXRhdGlvbiBldmVudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGdldFZhbHVlKHtcbiAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICByZXR1cm4gZnJvbVNsYXRlVmFsdWUoc2xhdGVFZGl0b3JJbnN0YW5jZS5jaGlsZHJlbiwgZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoc2xhdGVFZGl0b3JJbnN0YW5jZSkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRvclNlbGVjdG9yKGVkaXRvciwgc2VsZWN0b3IsIHQwKSB7XG4gIGNvbnN0ICQgPSBjKDMpLCBjb21wYXJlID0gdDAgPT09IHZvaWQgMCA/IGRlZmF1bHRDb21wYXJlIDogdDA7XG4gIGxldCB0MTtcbiAgcmV0dXJuICRbMF0gIT09IGVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UgfHwgJFsxXSAhPT0gc2VsZWN0b3IgPyAodDEgPSAoZWRpdG9yQWN0b3JTbmFwc2hvdCkgPT4ge1xuICAgIGNvbnN0IHNuYXBzaG90ID0gZ2V0RWRpdG9yU25hcHNob3Qoe1xuICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IGVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZWN0b3Ioc25hcHNob3QpO1xuICB9LCAkWzBdID0gZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSwgJFsxXSA9IHNlbGVjdG9yLCAkWzJdID0gdDEpIDogdDEgPSAkWzJdLCB1c2VTZWxlY3RvcihlZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCB0MSwgY29tcGFyZSk7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gIGVkaXRvckFjdG9yU25hcHNob3QsXG4gIHNsYXRlRWRpdG9ySW5zdGFuY2Vcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBhY3RpdmVEZWNvcmF0b3JzOiBnZXRBY3RpdmVEZWNvcmF0b3JzKHtcbiAgICAgICAgc2NoZW1hOiBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgICBzbGF0ZUVkaXRvckluc3RhbmNlXG4gICAgICB9KSxcbiAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYTogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNlbGVjdGlvbjogZWRpdG9yQWN0b3JTbmFwc2hvdC5jb250ZXh0LnNlbGVjdGlvbixcbiAgICAgIHZhbHVlOiBnZXRWYWx1ZSh7XG4gICAgICAgIGVkaXRvckFjdG9yU25hcHNob3QsXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2VcbiAgICAgIH0pXG4gICAgfVxuICB9O1xufVxuY29uc3QgZGVmYXVsdEtleUdlbmVyYXRvciA9ICgpID0+IHJhbmRvbUtleSgxMiksIGdldEJ5dGVIZXhUYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBsZXQgdGFibGU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHRhYmxlKVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIHRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSlcbiAgICAgIHRhYmxlW2ldID0gKGkgKyAyNTYpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGFibGU7XG4gIH07XG59KSgpO1xuZnVuY3Rpb24gd2hhdHdnUk5HKGxlbmd0aCA9IDE2KSB7XG4gIGNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCksIHJuZHM4O1xufVxuZnVuY3Rpb24gcmFuZG9tS2V5KGxlbmd0aCkge1xuICBjb25zdCB0YWJsZSA9IGdldEJ5dGVIZXhUYWJsZSgpO1xuICByZXR1cm4gd2hhdHdnUk5HKGxlbmd0aCkucmVkdWNlKChzdHIsIG4pID0+IHN0ciArIHRhYmxlW25dLCBcIlwiKS5zbGljZSgwLCBsZW5ndGgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWRpdG9yKGNvbmZpZykge1xuICBjb25zdCBlZGl0b3JBY3RvciA9IGNyZWF0ZUFjdG9yKGVkaXRvck1hY2hpbmUsIHtcbiAgICBpbnB1dDogZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKVxuICB9KTtcbiAgcmV0dXJuIGVkaXRvckFjdG9yLnN0YXJ0KCksIGNyZWF0ZUVkaXRvckZyb21BY3RvcihlZGl0b3JBY3Rvcik7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVFZGl0b3IoY29uZmlnKSB7XG4gIGNvbnN0ICQgPSBjKDYpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IGNvbmZpZyA/ICh0MCA9IGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZyksICRbMF0gPSBjb25maWcsICRbMV0gPSB0MCkgOiB0MCA9ICRbMV07XG4gIGxldCB0MTtcbiAgJFsyXSAhPT0gdDAgPyAodDEgPSB7XG4gICAgaW5wdXQ6IHQwXG4gIH0sICRbMl0gPSB0MCwgJFszXSA9IHQxKSA6IHQxID0gJFszXTtcbiAgY29uc3QgZWRpdG9yQWN0b3IgPSB1c2VBY3RvclJlZihlZGl0b3JNYWNoaW5lLCB0MSk7XG4gIGxldCB0MiwgdDM7XG4gIHJldHVybiAkWzRdICE9PSBlZGl0b3JBY3RvciA/ICh0MyA9IGNyZWF0ZUVkaXRvckZyb21BY3RvcihlZGl0b3JBY3RvciksICRbNF0gPSBlZGl0b3JBY3RvciwgJFs1XSA9IHQzKSA6IHQzID0gJFs1XSwgdDIgPSB0MywgdDI7XG59XG5mdW5jdGlvbiBlZGl0b3JDb25maWdUb01hY2hpbmVJbnB1dChjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBiZWhhdmlvcnM6IGNvbmZpZy5iZWhhdmlvcnMsXG4gICAga2V5R2VuZXJhdG9yOiBjb25maWcua2V5R2VuZXJhdG9yID8/IGRlZmF1bHRLZXlHZW5lcmF0b3IsXG4gICAgbWF4QmxvY2tzOiBjb25maWcubWF4QmxvY2tzLFxuICAgIHJlYWRPbmx5OiBjb25maWcucmVhZE9ubHksXG4gICAgc2NoZW1hOiBjb25maWcuc2NoZW1hRGVmaW5pdGlvbiA/IGNvbXBpbGVTY2hlbWFEZWZpbml0aW9uKGNvbmZpZy5zY2hlbWFEZWZpbml0aW9uKSA6IGNyZWF0ZUVkaXRvclNjaGVtYShjb25maWcuc2NoZW1hLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyBjb25maWcuc2NoZW1hIDogY29tcGlsZVR5cGUoY29uZmlnLnNjaGVtYSkpLFxuICAgIHZhbHVlOiBjb25maWcuaW5pdGlhbFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3JGcm9tQWN0b3IoZWRpdG9yQWN0b3IpIHtcbiAgY29uc3Qgc2xhdGVFZGl0b3IgPSBjcmVhdGVTbGF0ZUVkaXRvcih7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSksIGVkaXRhYmxlID0gY3JlYXRlRWRpdGFibGVBUEkoc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGVkaXRvckFjdG9yKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4gZ2V0RWRpdG9yU25hcHNob3Qoe1xuICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdDogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSxcbiAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2U6IHNsYXRlRWRpdG9yLmluc3RhbmNlXG4gICAgfSksXG4gICAgcmVnaXN0ZXJCZWhhdmlvcjogKGNvbmZpZykgPT4gKGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJhZGQgYmVoYXZpb3JcIixcbiAgICAgIGJlaGF2aW9yOiBjb25maWcuYmVoYXZpb3JcbiAgICB9KSwgKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlIGJlaGF2aW9yXCIsXG4gICAgICAgIGJlaGF2aW9yOiBjb25maWcuYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHNlbmQ6IChldmVudCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZChldmVudCk7XG4gICAgfSxcbiAgICBvbjogKGV2ZW50LCBsaXN0ZW5lcikgPT4gZWRpdG9yQWN0b3Iub24oXG4gICAgICBldmVudCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxpc3RlbmVyXG4gICAgKSxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGVkaXRhYmxlLFxuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVkaXRvckFjdG9yQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pLCBQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uID0gKCkgPT4ge1xuICBjb25zdCBzZWxlY3Rpb24gPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQpO1xuICBpZiAoc2VsZWN0aW9uID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25gIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIHJldHVybiBzZWxlY3Rpb247XG59LCBkZWJ1ZyQ1ID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3I6U2VsZWN0aW9uUHJvdmlkZXJcIik7XG5mdW5jdGlvbiBQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlcihwcm9wcykge1xuICBjb25zdCAkID0gYyg2KSwgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICBsZXQgdDAsIHQxO1xuICAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MCA9ICgpID0+IHtcbiAgICBkZWJ1ZyQ1KFwiU3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIik7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMuZWRpdG9yQWN0b3Iub24oXCJzZWxlY3Rpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3Rpb24oZXZlbnQuc2VsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWJ1ZyQ1KFwiVW5zdWJzY3JpYmluZyB0byBzZWxlY3Rpb24gY2hhbmdlc1wiKSwgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDEgPSBbcHJvcHMuZWRpdG9yQWN0b3JdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSB0MCwgJFsyXSA9IHQxKSA6ICh0MCA9ICRbMV0sIHQxID0gJFsyXSksIHVzZUVmZmVjdCh0MCwgdDEpO1xuICBsZXQgdDI7XG4gIHJldHVybiAkWzNdICE9PSBwcm9wcy5jaGlsZHJlbiB8fCAkWzRdICE9PSBzZWxlY3Rpb24gPyAodDIgPSAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlbGVjdGlvbiwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzNdID0gcHJvcHMuY2hpbGRyZW4sICRbNF0gPSBzZWxlY3Rpb24sICRbNV0gPSB0MikgOiB0MiA9ICRbNV0sIHQyO1xufVxuY29uc3QgZGVidWckNCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yXCIpO1xuY2xhc3MgUG9ydGFibGVUZXh0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJQb3J0YWJsZVRleHRFZGl0b3JcIjtcbiAgLyoqXG4gICAqIEFuIG9ic2VydmFibGUgb2YgYWxsIHRoZSBlZGl0b3IgY2hhbmdlcy5cbiAgICovXG4gIGNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAvKipcbiAgICogQSBsb29rdXAgdGFibGUgZm9yIGFsbCB0aGUgcmVsZXZhbnQgc2NoZW1hIHR5cGVzIGZvciB0aGlzIHBvcnRhYmxlIHRleHQgdHlwZS5cbiAgICovXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICAvKlxuICAgKiBUaGUgZWRpdG9yIEFQSSAoY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGggU2xhdGUpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyksIHByb3BzLmVkaXRvciA/IHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIDogdGhpcy5lZGl0b3IgPSBjcmVhdGVFZGl0b3Ioe1xuICAgICAga2V5R2VuZXJhdG9yOiBwcm9wcy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYTogcHJvcHMuc2NoZW1hVHlwZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICBtYXhCbG9ja3M6IHByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMCksXG4gICAgICByZWFkT25seTogcHJvcHMucmVhZE9ubHlcbiAgICB9KSwgdGhpcy5zY2hlbWFUeXBlcyA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLCB0aGlzLmVkaXRhYmxlID0gdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAhdGhpcy5wcm9wcy5lZGl0b3IgJiYgIXByZXZQcm9wcy5lZGl0b3IgJiYgdGhpcy5wcm9wcy5zY2hlbWFUeXBlICE9PSBwcmV2UHJvcHMuc2NoZW1hVHlwZSAmJiAodGhpcy5zY2hlbWFUeXBlcyA9IGNyZWF0ZUVkaXRvclNjaGVtYSh0aGlzLnByb3BzLnNjaGVtYVR5cGUuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IHRoaXMucHJvcHMuc2NoZW1hVHlwZSA6IGNvbXBpbGVUeXBlKHRoaXMucHJvcHMuc2NoZW1hVHlwZSkpLCB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSBzY2hlbWFcIixcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFUeXBlc1xuICAgIH0pKSwgIXRoaXMucHJvcHMuZWRpdG9yICYmICFwcmV2UHJvcHMuZWRpdG9yICYmICh0aGlzLnByb3BzLnJlYWRPbmx5ICE9PSBwcmV2UHJvcHMucmVhZE9ubHkgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgcmVhZE9ubHlcIixcbiAgICAgIHJlYWRPbmx5OiB0aGlzLnByb3BzLnJlYWRPbmx5ID8/ICExXG4gICAgfSksIHRoaXMucHJvcHMubWF4QmxvY2tzICE9PSBwcmV2UHJvcHMubWF4QmxvY2tzICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIG1heEJsb2Nrc1wiLFxuICAgICAgbWF4QmxvY2tzOiB0aGlzLnByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHRoaXMucHJvcHMubWF4QmxvY2tzLnRvU3RyaW5nKCksIDEwKVxuICAgIH0pLCB0aGlzLnByb3BzLnZhbHVlICE9PSBwcmV2UHJvcHMudmFsdWUgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlXG4gICAgfSksIHRoaXMucHJvcHMuZWRpdG9yUmVmICE9PSBwcmV2UHJvcHMuZWRpdG9yUmVmICYmIHRoaXMucHJvcHMuZWRpdG9yUmVmICYmICh0aGlzLnByb3BzLmVkaXRvclJlZi5jdXJyZW50ID0gdGhpcykpO1xuICB9XG4gIHNldEVkaXRhYmxlID0gKGVkaXRhYmxlKSA9PiB7XG4gICAgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlID0ge1xuICAgICAgLi4udGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlLFxuICAgICAgLi4uZWRpdGFibGVcbiAgICB9O1xuICB9O1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbGVnYWN5UGF0Y2hlcyA9IHRoaXMucHJvcHMuZWRpdG9yID8gdm9pZCAwIDogdGhpcy5wcm9wcy5pbmNvbWluZ1BhdGNoZXMkID8/IHRoaXMucHJvcHMucGF0Y2hlcyQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICBsZWdhY3lQYXRjaGVzID8gLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZVBhdGNoZXNPYnNlcnZhYmxlVG9FZGl0b3JBY3RvciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBwYXRjaGVzJDogbGVnYWN5UGF0Y2hlcyB9KSA6IG51bGwsXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlRXZlbnRzVG9DaGFuZ2VzLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIG9uQ2hhbmdlOiAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuZWRpdG9yIHx8IHRoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgdGhpcy5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgICAgIH0gfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFN5bmNocm9uaXplciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGluaXRpYWxWYWx1ZTogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluaXRpYWxWYWx1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSkgfSkgfSkgfSlcbiAgICBdIH0pO1xuICB9XG4gIC8vIFN0YXRpYyBBUEkgbWV0aG9kc1xuICBzdGF0aWMgYWN0aXZlQW5ub3RhdGlvbnMgPSAoZWRpdG9yKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmFjdGl2ZUFubm90YXRpb25zKCkgOiBbXTtcbiAgc3RhdGljIGlzQW5ub3RhdGlvbkFjdGl2ZSA9IChlZGl0b3IsIGFubm90YXRpb25UeXBlKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmlzQW5ub3RhdGlvbkFjdGl2ZShhbm5vdGF0aW9uVHlwZSkgOiAhMTtcbiAgc3RhdGljIGFkZEFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5hZGRBbm5vdGF0aW9uKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGJsdXIgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgYmx1cnJlZFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5ibHVyKCk7XG4gIH07XG4gIHN0YXRpYyBkZWxldGUgPSAoZWRpdG9yLCBzZWxlY3Rpb24sIG9wdGlvbnMpID0+IGVkaXRvci5lZGl0YWJsZT8uZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucyk7XG4gIHN0YXRpYyBmaW5kRE9NTm9kZSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5lZGl0YWJsZT8uZmluZERPTU5vZGUoZWxlbWVudCk7XG4gIHN0YXRpYyBmaW5kQnlQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5maW5kQnlQYXRoKHBhdGgpIHx8IFtdO1xuICBzdGF0aWMgZm9jdXMgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgcmVxdWVzdGluZyBmb2N1c1wiKSwgZWRpdG9yLmVkaXRhYmxlPy5mb2N1cygpO1xuICB9O1xuICBzdGF0aWMgZm9jdXNCbG9jayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNCbG9jaygpO1xuICBzdGF0aWMgZm9jdXNDaGlsZCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNDaGlsZCgpO1xuICBzdGF0aWMgZ2V0U2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmdldFNlbGVjdGlvbigpIDogbnVsbDtcbiAgc3RhdGljIGdldFZhbHVlID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5nZXRWYWx1ZSgpO1xuICBzdGF0aWMgaGFzQmxvY2tTdHlsZSA9IChlZGl0b3IsIGJsb2NrU3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgc3RhdGljIGhhc0xpc3RTdHlsZSA9IChlZGl0b3IsIGxpc3RTdHlsZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5oYXNMaXN0U3R5bGUobGlzdFN0eWxlKTtcbiAgc3RhdGljIGlzQ29sbGFwc2VkU2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc0NvbGxhcHNlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNFeHBhbmRlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNFeHBhbmRlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNNYXJrQWN0aXZlID0gKGVkaXRvciwgbWFyaykgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc01hcmtBY3RpdmUobWFyayk7XG4gIHN0YXRpYyBpbnNlcnRDaGlsZCA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiAoZGVidWckNChcIkhvc3QgaW5zZXJ0aW5nIGNoaWxkXCIpLCBlZGl0b3IuZWRpdGFibGU/Lmluc2VydENoaWxkKHR5cGUsIHZhbHVlKSk7XG4gIHN0YXRpYyBpbnNlcnRCbG9jayA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmluc2VydEJsb2NrKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGluc2VydEJyZWFrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCcmVhaygpO1xuICBzdGF0aWMgaXNWb2lkID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1ZvaWQoZWxlbWVudCk7XG4gIHN0YXRpYyBpc09iamVjdFBhdGggPSAoX2VkaXRvciwgcGF0aCkgPT4ge1xuICAgIGlmICghcGF0aCB8fCAhQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IGlzQ2hpbGRPYmplY3RFZGl0UGF0aCA9IHBhdGgubGVuZ3RoID4gMyAmJiBwYXRoWzFdID09PSBcImNoaWxkcmVuXCI7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoWzFdICE9PSBcImNoaWxkcmVuXCIgfHwgaXNDaGlsZE9iamVjdEVkaXRQYXRoO1xuICB9O1xuICBzdGF0aWMgbWFya3MgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/Lm1hcmtzKCk7XG4gIHN0YXRpYyBzZWxlY3QgPSAoZWRpdG9yLCBzZWxlY3Rpb24pID0+IHtcbiAgICBkZWJ1ZyQ0KFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCBlZGl0b3IuZWRpdGFibGU/LnNlbGVjdChzZWxlY3Rpb24pO1xuICB9O1xuICBzdGF0aWMgcmVtb3ZlQW5ub3RhdGlvbiA9IChlZGl0b3IsIHR5cGUpID0+IGVkaXRvci5lZGl0YWJsZT8ucmVtb3ZlQW5ub3RhdGlvbih0eXBlKTtcbiAgc3RhdGljIHRvZ2dsZUJsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiAoZGVidWckNChcIkhvc3QgaXMgdG9nZ2xpbmcgYmxvY2sgc3R5bGVcIiksIGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlQmxvY2tTdHlsZShibG9ja1N0eWxlKSk7XG4gIHN0YXRpYyB0b2dnbGVMaXN0ID0gKGVkaXRvciwgbGlzdFN0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUxpc3QobGlzdFN0eWxlKTtcbiAgc3RhdGljIHRvZ2dsZU1hcmsgPSAoZWRpdG9yLCBtYXJrKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgdG9nZ2xpbmcgbWFya1wiLCBtYXJrKSwgZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVNYXJrKG1hcmspO1xuICB9O1xuICBzdGF0aWMgZ2V0RnJhZ21lbnQgPSAoZWRpdG9yKSA9PiAoZGVidWckNChcIkhvc3QgZ2V0dGluZyBmcmFnbWVudFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5nZXRGcmFnbWVudCgpKTtcbiAgc3RhdGljIHVuZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgdW5kb2luZ1wiKSwgZWRpdG9yLmVkaXRhYmxlPy51bmRvKCk7XG4gIH07XG4gIHN0YXRpYyByZWRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IHJlZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8ucmVkbygpO1xuICB9O1xuICBzdGF0aWMgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmcgPSAoZWRpdG9yLCBzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzU2VsZWN0aW9uc092ZXJsYXBwaW5nKHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpO1xufVxuZnVuY3Rpb24gUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciB8fCAkWzFdICE9PSBwcm9wcy5wYXRjaGVzJCA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwcm9wcy5wYXRjaGVzJC5zdWJzY3JpYmUoKHBheWxvYWQpID0+IHtcbiAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInBhdGNoZXNcIixcbiAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yLCBwcm9wcy5wYXRjaGVzJF0sICRbMF0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFsxXSA9IHByb3BzLnBhdGNoZXMkLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIFJvdXRlRXZlbnRzVG9DaGFuZ2VzKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDYpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzID8gKHQwID0gKGNoYW5nZSkgPT4gcHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgJFswXSA9IHByb3BzLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh0MCk7XG4gIGxldCB0MSwgdDI7XG4gIHJldHVybiAkWzJdICE9PSBoYW5kbGVDaGFuZ2UgfHwgJFszXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDEgPSAoKSA9PiB7XG4gICAgZGVidWckNChcIlN1YnNjcmliaW5nIHRvIGVkaXRvciBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGJiNTogc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibHVycmVkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJibHVyXCIsXG4gICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdGNoXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibG9hZGluZ1wiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICBpc0xvYWRpbmc6ICExXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmb2N1c2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkVmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IGV2ZW50LnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm11dGF0aW9uXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVhZHlcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzZWxlY3Rpb25cIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnJDQoXCJVbnN1YnNjcmliaW5nIHRvIGNoYW5nZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQyID0gW3Byb3BzLmVkaXRvckFjdG9yLCBoYW5kbGVDaGFuZ2VdLCAkWzJdID0gaGFuZGxlQ2hhbmdlLCAkWzNdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbNF0gPSB0MSwgJFs1XSA9IHQyKSA6ICh0MSA9ICRbNF0sIHQyID0gJFs1XSksIHVzZUVmZmVjdCh0MSwgdDIpLCBudWxsO1xufVxuY29uc3QgZGVidWckMyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkxlYWZcIiksIEVNUFRZX01BUktTID0gW10sIExlYWYgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgbGVhZixcbiAgICBzY2hlbWFUeXBlcyxcbiAgICByZW5kZXJDaGlsZCxcbiAgICByZW5kZXJEZWNvcmF0b3IsXG4gICAgcmVuZGVyQW5ub3RhdGlvblxuICB9ID0gcHJvcHMsIHNwYW5SZWYgPSB1c2VSZWYobnVsbCksIHBvcnRhYmxlVGV4dEVkaXRvciA9IHVzZVBvcnRhYmxlVGV4dEVkaXRvcigpLCBibG9ja1NlbGVjdGVkID0gdXNlU2VsZWN0ZWQoKSwgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoITEpLCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKCExKSwgYmxvY2sgPSBjaGlsZHJlbi5wcm9wcy5wYXJlbnQsIHBhdGggPSB1c2VNZW1vKCgpID0+IGJsb2NrID8gW3tcbiAgICBfa2V5OiBibG9jaz8uX2tleVxuICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBsZWFmLl9rZXlcbiAgfV0gOiBbXSwgW2Jsb2NrLCBsZWFmLl9rZXldKSwgZGVjb3JhdG9yVmFsdWVzID0gdXNlTWVtbygoKSA9PiBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLm1hcCgoZGVjKSA9PiBkZWMudmFsdWUpLCBbc2NoZW1hVHlwZXMuZGVjb3JhdG9yc10pLCBtYXJrcyA9IHVzZU1lbW8oKCkgPT4gdW5pcSgobGVhZi5tYXJrcyB8fCBFTVBUWV9NQVJLUykuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JWYWx1ZXMuaW5jbHVkZXMobWFyaykpKSwgW2RlY29yYXRvclZhbHVlcywgbGVhZi5tYXJrc10pLCBhbm5vdGF0aW9uTWFya3MgPSBBcnJheS5pc0FycmF5KGxlYWYubWFya3MpID8gbGVhZi5tYXJrcyA6IEVNUFRZX01BUktTLCBhbm5vdGF0aW9ucyA9IHVzZU1lbW8oKCkgPT4gYW5ub3RhdGlvbk1hcmtzLm1hcCgobWFya18wKSA9PiAhZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmtfMCkgJiYgYmxvY2s/Lm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrXzApKS5maWx0ZXIoQm9vbGVhbiksIFthbm5vdGF0aW9uTWFya3MsIGJsb2NrLCBkZWNvcmF0b3JWYWx1ZXNdKSwgc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cyA9IGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgYmxvY2tTZWxlY3RlZDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpIHtcbiAgICAgIHNldEZvY3VzZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWwgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgc2VsICYmIGlzRXF1YWwoc2VsLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCEwKTtcbiAgICB9KTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvcl0pO1xuICBjb25zdCBzZXRTZWxlY3RlZEZyb21SYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgZGVidWckMyhcIlNldHRpbmcgc2VsZWN0aW9uIGFuZCBmb2N1cyBmcm9tIHJhbmdlXCIpO1xuICAgIGNvbnN0IHdpblNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXdpblNlbGVjdGlvbikge1xuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2luU2VsZWN0aW9uICYmIHdpblNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW5TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIHNwYW5SZWYuY3VycmVudCAmJiByYW5nZS5pbnRlcnNlY3RzTm9kZShzcGFuUmVmLmN1cnJlbnQpID8gc2V0U2VsZWN0ZWQoITApIDogc2V0U2VsZWN0ZWQoITEpO1xuICAgIH0gZWxzZVxuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICB9LCBbc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1c10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvbkJsdXIgPSBlZGl0b3JBY3Rvci5vbihcImJsdXJcIiwgKCkgPT4ge1xuICAgICAgc2V0Rm9jdXNlZCghMSksIHNldFNlbGVjdGVkKCExKTtcbiAgICB9KSwgb25Gb2N1cyA9IGVkaXRvckFjdG9yLm9uKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsXzAgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxfMCAmJiBpc0VxdWFsKHNlbF8wLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHNldEZvY3VzZWQoITApLCBzZXRTZWxlY3RlZEZyb21SYW5nZSgpO1xuICAgIH0pLCBvblNlbGVjdGlvbiA9IGVkaXRvckFjdG9yLm9uKFwic2VsZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc2VsZWN0aW9uICYmIGlzRXF1YWwoZXZlbnQuc2VsZWN0aW9uLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpID8gc2V0Rm9jdXNlZCghMCkgOiBzZXRGb2N1c2VkKCExKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb25CbHVyLnVuc3Vic2NyaWJlKCksIG9uRm9jdXMudW5zdWJzY3JpYmUoKSwgb25TZWxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yQWN0b3IsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UsIHNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXNdKSwgdXNlRWZmZWN0KCgpID0+IHNldFNlbGVjdGVkRnJvbVJhbmdlKCksIFtzZXRTZWxlY3RlZEZyb21SYW5nZV0pO1xuICBjb25zdCBjb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHJldHVybmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICBpZiAoVGV4dC5pc1RleHQobGVhZikgJiYgbGVhZi5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuc3Bhbi5uYW1lICYmIChtYXJrcy5mb3JFYWNoKChtYXJrXzEpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLmZpbmQoKGRlY18wKSA9PiBkZWNfMC52YWx1ZSA9PT0gbWFya18xKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlICYmIHJlbmRlckRlY29yYXRvcikge1xuICAgICAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuLFxuICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIHNjaGVtYVR5cGUsXG4gICAgICAgICAgdmFsdWU6IG1hcmtfMVxuICAgICAgICB9LCBcInR5cGVcIiwge1xuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gcmVuZGVyRGVjb3JhdG9yKF9wcm9wcyk7XG4gICAgICB9XG4gICAgfSksIGJsb2NrICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgYW5ub3RhdGlvbnMuZm9yRWFjaCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZV8wID0gc2NoZW1hVHlwZXMuYW5ub3RhdGlvbnMuZmluZCgodCkgPT4gdC5uYW1lID09PSBhbm5vdGF0aW9uLl90eXBlKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlXzApXG4gICAgICAgIGlmIChyZW5kZXJBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgX3Byb3BzXzAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbixcbiAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZV8wLFxuICAgICAgICAgICAgdmFsdWU6IGFubm90YXRpb25cbiAgICAgICAgICB9LCBcInR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZV8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHJlZjogc3BhblJlZiwgY2hpbGRyZW46IHJlbmRlckFubm90YXRpb24oX3Byb3BzXzApIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuIH0pIH0pO1xuICAgIH0pLCBibG9jayAmJiByZW5kZXJDaGlsZCkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW4uZmluZCgoX2NoaWxkKSA9PiBfY2hpbGQuX2tleSA9PT0gbGVhZi5fa2V5KTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjb25zdCBfcHJvcHNfMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4gfSksXG4gICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuc3BhbixcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVzLnNwYW47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IHJlbmRlckNoaWxkKF9wcm9wc18xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybmVkQ2hpbGRyZW47XG4gIH0sIFthbm5vdGF0aW9ucywgYmxvY2ssIGNoaWxkcmVuLCBmb2N1c2VkLCBsZWFmLCBtYXJrcywgcGF0aCwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgc2NoZW1hVHlwZXMuYW5ub3RhdGlvbnMsIHNjaGVtYVR5cGVzLmRlY29yYXRvcnMsIHNjaGVtYVR5cGVzLnNwYW4sIHNlbGVjdGVkXSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgLi4uYXR0cmlidXRlcywgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogY29udGVudCB9LCBsZWFmLl9rZXkpLCBbbGVhZiwgYXR0cmlidXRlcywgY29udGVudF0pO1xufTtcbkxlYWYuZGlzcGxheU5hbWUgPSBcIkxlYWZcIjtcbmNvbnN0IGRlYnVnJDIgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhIb3RLZXlzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5c0Zyb21PcHRpb25zKSB7XG4gIGNvbnN0IHJlc2VydmVkSG90a2V5cyA9IFtcImVudGVyXCIsIFwidGFiXCIsIFwic2hpZnRcIiwgXCJkZWxldGVcIiwgXCJlbmRcIl0sIGFjdGl2ZUhvdGtleXMgPSBob3RrZXlzRnJvbU9wdGlvbnMgPz8ge307XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZVdpdGhIb3RLZXlzID0gKGV2ZW50KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY3RpdmVIb3RrZXlzKS5mb3JFYWNoKChjYXQpID0+IHtcbiAgICAgICAgaWYgKGNhdCA9PT0gXCJtYXJrc1wiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlTWFyayA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlTWFyaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBwb3NzaWJsZU1hcmtbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQyKGBIb3RLZXkgJHtob3RrZXl9IHRvIHRvZ2dsZSAke21hcmt9YCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChjYXQgPT09IFwiY3VzdG9tXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDb21tYW5kID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHBvc3NpYmxlQ29tbWFuZFtob3RrZXldO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQoZXZlbnQsIHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQxID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoSW5zZXJ0RGF0YVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhJbnNlcnREYXRhKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgYmxvY2tUeXBlTmFtZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIHNwYW5UeXBlTmFtZSA9IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gc2NoZW1hVHlwZXMuYmxvY2sub3B0aW9ucy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUsIHRvUGxhaW5UZXh0ID0gKGJsb2NrcykgPT4gYmxvY2tzLm1hcCgoYmxvY2spID0+IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgPyBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc3BhblR5cGVOYW1lID8gY2hpbGQudGV4dCA6IGBbJHtzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY2hpbGQuX3R5cGUpPy50aXRsZSB8fCBcIk9iamVjdFwifV1gKS5qb2luKFwiXCIpIDogYFske3NjaGVtYVR5cGVzLmJsb2NrT2JqZWN0cy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGJsb2NrLl90eXBlKT8udGl0bGUgfHwgXCJPYmplY3RcIn1dYCkuam9pbihgXG5cbmApO1xuICAgIHJldHVybiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhID0gKGRhdGEsIG9yaWdpbkV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLCBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LnBhdGhcbiAgICAgIH0pLCBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQucGF0aFxuICAgICAgfSk7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgbGV0IGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgY29uc3QgW3ZvaWROb2RlXSA9IGVuZFZvaWQsIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCksIGRvbU5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCB2b2lkTm9kZSk7XG4gICAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSksIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiKSkuZm9yRWFjaCgoencpID0+IHtcbiAgICAgICAgY29uc3QgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKFwiZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXCIpID09PSBcIm5cIjtcbiAgICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyBgXG5gIDogXCJcIjtcbiAgICAgIH0pLCBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5mb3JFYWNoKChlbG0pID0+IHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtaW5saW5lXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1sZWFmXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1ub2RlXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1zcGFjZXJcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLXN0cmluZ1wiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtemVyby13aWR0aFwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZWxtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgZWxtLmhhc0F0dHJpYnV0ZShrZXkpICYmIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKSwgZGl2LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIiksIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgY29uc3QgYXNIVE1MID0gZGl2LmlubmVySFRNTDtcbiAgICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBlZGl0b3IuZ2V0RnJhZ21lbnQoKSwgcG9ydGFibGVUZXh0ID0gZnJvbVNsYXRlVmFsdWUoZnJhZ21lbnQsIGJsb2NrVHlwZU5hbWUpLCBhc0pTT04gPSBKU09OLnN0cmluZ2lmeShwb3J0YWJsZVRleHQpLCBhc1BsYWluVGV4dCA9IHRvUGxhaW5UZXh0KHBvcnRhYmxlVGV4dCk7XG4gICAgICBkYXRhLmNsZWFyRGF0YSgpLCBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGFzSFRNTCksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIiwgYXNKU09OKSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsIGFzSlNPTiksIGRlYnVnJDEoXCJ0ZXh0XCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0LWV2ZW50LW9yaWdpblwiLCBvcmlnaW5FdmVudCB8fCBcImV4dGVybmFsXCIpLCBkZWJ1ZyQxKFwiU2V0IGZyYWdtZW50IGRhdGFcIiwgYXNKU09OLCBhc0hUTUwpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRQb3J0YWJsZVRleHREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcFRleHQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIiksIG9yaWdpbiA9IGRhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dC1ldmVudC1vcmlnaW5cIik7XG4gICAgICBpZiAoZGVidWckMShgSW5zZXJ0aW5nIHBvcnRhYmxlIHRleHQgZnJvbSAke29yaWdpbn0gZXZlbnRgLCBwVGV4dCksIHBUZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocFRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpICYmIHBhcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2xhdGVWYWx1ZSA9IF9yZWdlbmVyYXRlS2V5cyhlZGl0b3IsIHRvU2xhdGVWYWx1ZShwYXJzZWQsIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsIHNwYW5UeXBlTmFtZSwgc2NoZW1hVHlwZXMpLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZShwYXJzZWQsIHNjaGVtYVR5cGVzLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQgJiYgIXZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBgJHt2YWxpZGF0aW9uLnJlc29sdXRpb24/LmRlc2NyaXB0aW9ufWA7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgbmFtZTogXCJwYXN0ZUVycm9yXCIsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBlcnJvckRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBkYXRhOiB2YWxpZGF0aW9uXG4gICAgICAgICAgICB9KSwgZGVidWckMShcIkludmFsaWQgaW5zZXJ0IHJlc3VsdFwiLCB2YWxpZGF0aW9uKSwgITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBzbGF0ZVZhbHVlLCBzY2hlbWFUeXBlcyksICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yLmluc2VydFRleHRPckhUTUxEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGRlYnVnJDEoXCJObyBzZWxlY3Rpb24sIG5vdCBpbnNlcnRpbmdcIiksICExO1xuICAgICAgY29uc3QgaHRtbCA9IGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgdGV4dCA9IGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICBpZiAoaHRtbCB8fCB0ZXh0KSB7XG4gICAgICAgIGRlYnVnJDEoXCJJbnNlcnRpbmcgZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgbGV0IHBvcnRhYmxlVGV4dCwgZnJhZ21lbnQsIGluc2VydGVkVHlwZTtcbiAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICBpZiAocG9ydGFibGVUZXh0ID0gaHRtbFRvQmxvY2tzKGh0bWwsIHNjaGVtYVR5cGVzLnBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgdW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlOiB3aGl0ZXNwYWNlT25QYXN0ZU1vZGUsXG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3JcbiAgICAgICAgICB9KSwgZnJhZ21lbnQgPSB0b1NsYXRlVmFsdWUocG9ydGFibGVUZXh0LCB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICAgIH0pLCBpbnNlcnRlZFR5cGUgPSBcIkhUTUxcIiwgcG9ydGFibGVUZXh0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0VG9IdG1sID0gYDxodG1sPjxib2R5PiR7ZXNjYXBlSHRtbCh0ZXh0KS5zcGxpdCgvXFxuezIsfS8pLm1hcCgobGluZSkgPT4gbGluZSA/IGA8cD4ke2xpbmUucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIFwiPGJyLz5cIil9PC9wPmAgOiBcIjxwPjwvcD5cIikuam9pbihcIlwiKX08L2JvZHk+PC9odG1sPmA7XG4gICAgICAgICAgcG9ydGFibGVUZXh0ID0gaHRtbFRvQmxvY2tzKHRleHRUb0h0bWwsIHNjaGVtYVR5cGVzLnBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yXG4gICAgICAgICAgfSksIGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgICAgICB9KSwgaW5zZXJ0ZWRUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUocG9ydGFibGVUZXh0LCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBgQ291bGQgbm90IHZhbGlkYXRlIHRoZSByZXN1bHRpbmcgcG9ydGFibGUgdGV4dCB0byBpbnNlcnQuXG4ke3ZhbGlkYXRpb24ucmVzb2x1dGlvbj8uZGVzY3JpcHRpb259XG5UcnkgdG8gaW5zZXJ0IGFzIHBsYWluIHRleHQgKHNoaWZ0LXBhc3RlKSBpbnN0ZWFkLmA7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgbmFtZTogXCJwYXN0ZUVycm9yXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3JEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRhdGE6IHZhbGlkYXRpb25cbiAgICAgICAgICB9KSwgZGVidWckMShcIkludmFsaWQgaW5zZXJ0IHJlc3VsdFwiLCB2YWxpZGF0aW9uKSwgITE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlYnVnJDEoYEluc2VydGluZyAke2luc2VydGVkVHlwZX0gZnJhZ21lbnQgYXQgJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX1gKSwgX2luc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIHNjaGVtYVR5cGVzKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yLmluc2VydERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgZWRpdG9yLmluc2VydFBvcnRhYmxlVGV4dERhdGEoZGF0YSkgfHwgZWRpdG9yLmluc2VydFRleHRPckhUTUxEYXRhKGRhdGEpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZW50aXR5TWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIixcbiAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiLFxuICBcIj1cIjogXCImI3gzRDtcIlxufTtcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRlS2V5cyhlZGl0b3IsIGZyYWdtZW50LCBrZXlHZW5lcmF0b3IsIHNwYW5UeXBlTmFtZSwgZWRpdG9yVHlwZXMpIHtcbiAgcmV0dXJuIGZyYWdtZW50Lm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAuLi5ub2RlXG4gICAgfTtcbiAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5ld05vZGUpKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGVkaXRvclR5cGVzLmFubm90YXRpb25zLm1hcCgodCkgPT4gdC5uYW1lKTtcbiAgICAgIGlmIChhbm5vdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1hcmtEZWZzLFxuICAgICAgICAgIC4uLk5ld05vZGVOb0RlZnNcbiAgICAgICAgfSA9IG5ld05vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uTmV3Tm9kZU5vRGVmcyxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKChuZXdOb2RlLm1hcmtEZWZzIHx8IFtdKS5zb21lKChkZWYpID0+ICFhbm5vdGF0aW9ucy5pbmNsdWRlcyhkZWYuX3R5cGUpKSkge1xuICAgICAgICBjb25zdCBhbGxvd2VkQW5ub3RhdGlvbnMgPSAobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkuZmlsdGVyKChkZWYpID0+IGFubm90YXRpb25zLmluY2x1ZGVzKGRlZi5fdHlwZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld05vZGUsXG4gICAgICAgICAgbWFya0RlZnM6IGFsbG93ZWRBbm5vdGF0aW9ucyxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbmV3Tm9kZS5tYXJrRGVmcyA9IChuZXdOb2RlLm1hcmtEZWZzIHx8IFtdKS5tYXAoKGRlZikgPT4ge1xuICAgICAgICBjb25zdCBvbGRLZXkgPSBkZWYuX2tleSwgbmV3S2V5ID0ga2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlLmNoaWxkcmVuID0gbmV3Tm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc3BhblR5cGVOYW1lICYmIGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSA/IHtcbiAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICBtYXJrczogY2hpbGQubWFya3MgJiYgY2hpbGQubWFya3MuaW5jbHVkZXMob2xkS2V5KSA/IFsuLi5jaGlsZC5tYXJrc10uZmlsdGVyKChtYXJrKSA9PiBtYXJrICE9PSBvbGRLZXkpLmNvbmNhdChuZXdLZXkpIDogY2hpbGQubWFya3NcbiAgICAgICAgfSA6IGNoaWxkKSwge1xuICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICBfa2V5OiBuZXdLZXlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBub2RlV2l0aE5ld0tleXMgPSB7XG4gICAgICAuLi5uZXdOb2RlLFxuICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICB9O1xuICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZVdpdGhOZXdLZXlzKSAmJiAobm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuID0gbm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgfSkpKSwgbm9kZVdpdGhOZXdLZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcykge1xuICBlZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2ZvY3VzQmxvY2ssIGZvY3VzUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgIGRlcHRoOiAxXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhmb2N1c0Jsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2soZnJhZ21lbnRbMF0pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWZzXG4gICAgICB9ID0gZm9jdXNCbG9jaztcbiAgICAgIGRlYnVnJDEoXCJNaXhpbmcgbWFya0RlZnMgb2YgZm9jdXNCbG9jayBhbmQgZnJhZ21lbnRzWzBdIGJsb2NrXCIsIG1hcmtEZWZzLCBmcmFnbWVudFswXS5tYXJrRGVmcyksIGlzRXF1YWwobWFya0RlZnMsIGZyYWdtZW50WzBdLm1hcmtEZWZzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXJrRGVmczogdW5pcShbLi4uZnJhZ21lbnRbMF0ubWFya0RlZnMgfHwgW10sIC4uLm1hcmtEZWZzIHx8IFtdXSlcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGZvY3VzUGF0aCxcbiAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgdm9pZHM6ICExXG4gICAgICB9KTtcbiAgICB9XG4gICAgaXNFcXVhbFRvRW1wdHlFZGl0b3IoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcykgPyAoVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFswLCAwXVxuICAgIH0pLCBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFswXVxuICAgIH0pKSA6IGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbn1cbmZ1bmN0aW9uIHdpdGhTeW5jUmFuZ2VEZWNvcmF0aW9ucyh7XG4gIGVkaXRvckFjdG9yLFxuICBzbGF0ZUVkaXRvcixcbiAgc3luY1JhbmdlRGVjb3JhdGlvbnNcbn0pIHtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IHNsYXRlRWRpdG9yLmFwcGx5O1xuICByZXR1cm4gc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcmlnaW5hbEFwcGx5KG9wKSwgIWVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgfSkgJiYgb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgc3luY1JhbmdlRGVjb3JhdGlvbnMob3ApO1xuICB9LCAoKSA9PiB7XG4gICAgc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICB9O1xufVxuY29uc3QgZGVidWcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OkVkaXRhYmxlXCIpLCBQTEFDRUhPTERFUl9TVFlMRSA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICBsZWZ0OiAwLFxuICByaWdodDogMFxufSwgUG9ydGFibGVUZXh0RWRpdGFibGUgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIGhvdGtleXMsXG4gICAgb25CbHVyLFxuICAgIG9uRm9jdXMsXG4gICAgb25CZWZvcmVJbnB1dCxcbiAgICBvblBhc3RlLFxuICAgIG9uQ29weSxcbiAgICBvbkNsaWNrLFxuICAgIHJhbmdlRGVjb3JhdGlvbnMsXG4gICAgcmVuZGVyQW5ub3RhdGlvbixcbiAgICByZW5kZXJCbG9jayxcbiAgICByZW5kZXJDaGlsZCxcbiAgICByZW5kZXJEZWNvcmF0b3IsXG4gICAgcmVuZGVyTGlzdEl0ZW0sXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyU3R5bGUsXG4gICAgc2VsZWN0aW9uOiBwcm9wc1NlbGVjdGlvbixcbiAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyxcbiAgICBzcGVsbENoZWNrLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9ID0gcHJvcHMsIHBvcnRhYmxlVGV4dEVkaXRvciA9IHVzZVBvcnRhYmxlVGV4dEVkaXRvcigpLCByZWYgPSB1c2VSZWYobnVsbCksIFtlZGl0YWJsZUVsZW1lbnQsIHNldEVkaXRhYmxlRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKSwgW2hhc0ludmFsaWRWYWx1ZSwgc2V0SGFzSW52YWxpZFZhbHVlXSA9IHVzZVN0YXRlKCExKSwgW3JhbmdlRGVjb3JhdGlvblN0YXRlLCBzZXRSYW5nZURlY29yYXRpb25zU3RhdGVdID0gdXNlU3RhdGUoW10pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gcmVmLmN1cnJlbnQpO1xuICBjb25zdCByYW5nZURlY29yYXRpb25zUmVmID0gdXNlUmVmKHJhbmdlRGVjb3JhdGlvbnMpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgcmVhZE9ubHkgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgKHMpID0+IHMubWF0Y2hlcyh7XG4gICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICB9KSksIHNjaGVtYVR5cGVzID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIChzXzApID0+IHNfMC5jb250ZXh0LnNjaGVtYSksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGUoKSwgYmxvY2tUeXBlTmFtZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWU7XG4gIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHdpdGhJbnNlcnREYXRhID0gY3JlYXRlV2l0aEluc2VydERhdGEoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKTtcbiAgICBpZiAocmVhZE9ubHkpXG4gICAgICByZXR1cm4gZGVidWcoXCJFZGl0YWJsZSBpcyBpbiByZWFkIG9ubHkgbW9kZVwiKSwgd2l0aEluc2VydERhdGEoc2xhdGVFZGl0b3IpO1xuICAgIGNvbnN0IHdpdGhIb3RLZXlzID0gY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5cyk7XG4gICAgcmV0dXJuIGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gZWRpdCBtb2RlXCIpLCB3aXRoSW5zZXJ0RGF0YSh3aXRoSG90S2V5cyhzbGF0ZUVkaXRvcikpO1xuICB9LCBbZWRpdG9yQWN0b3IsIGhvdGtleXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgcmVhZE9ubHksIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl0pO1xuICBjb25zdCByZW5kZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2soKGVQcm9wcykgPT4gLyogQF9fUFVSRV9fICovIGpzeChFbGVtZW50LCB7IC4uLmVQcm9wcywgcmVhZE9ubHksIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlLCBzY2hlbWFUeXBlcywgc3BlbGxDaGVjayB9KSwgW3NjaGVtYVR5cGVzLCBzcGVsbENoZWNrLCByZWFkT25seSwgcmVuZGVyQmxvY2ssIHJlbmRlckNoaWxkLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyU3R5bGVdKSwgcmVuZGVyTGVhZiA9IHVzZUNhbGxiYWNrKChsUHJvcHMpID0+IHtcbiAgICBpZiAobFByb3BzLmxlYWYuX3R5cGUgPT09IFwic3BhblwiKSB7XG4gICAgICBsZXQgcmVuZGVyZWQgPSAvKiBAX19QVVJFX18gKi8ganN4KExlYWYsIHsgLi4ubFByb3BzLCBlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMsIHJlbmRlckFubm90YXRpb24sIHJlbmRlckNoaWxkLCByZW5kZXJEZWNvcmF0b3IsIHJlYWRPbmx5IH0pO1xuICAgICAgaWYgKHJlbmRlclBsYWNlaG9sZGVyICYmIGxQcm9wcy5sZWFmLnBsYWNlaG9sZGVyICYmIGxQcm9wcy50ZXh0LnRleHQgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IFBMQUNFSE9MREVSX1NUWUxFLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyUGxhY2Vob2xkZXIoKSB9KSxcbiAgICAgICAgICByZW5kZXJlZFxuICAgICAgICBdIH0pO1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGxQcm9wcy5sZWFmLnJhbmdlRGVjb3JhdGlvbjtcbiAgICAgIHJldHVybiBkZWNvcmF0aW9uICYmIChyZW5kZXJlZCA9IGRlY29yYXRpb24uY29tcG9uZW50KHtcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkXG4gICAgICB9KSksIHJlbmRlcmVkO1xuICAgIH1cbiAgICByZXR1cm4gbFByb3BzLmNoaWxkcmVuO1xuICB9LCBbZWRpdG9yQWN0b3IsIHJlYWRPbmx5LCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJQbGFjZWhvbGRlciwgc2NoZW1hVHlwZXNdKSwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocHJvcHNTZWxlY3Rpb24pIHtcbiAgICAgIGRlYnVnKGBTZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KHByb3BzU2VsZWN0aW9uKX1gKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBub3JtYWxpemVTZWxlY3Rpb24ocHJvcHNTZWxlY3Rpb24sIGZyb21TbGF0ZVZhbHVlKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBibG9ja1R5cGVOYW1lKSk7XG4gICAgICBpZiAobm9ybWFsaXplZFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBkZWJ1ZyhgTm9ybWFsaXplZCBzZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZWxlY3Rpb24pfWApO1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKG5vcm1hbGl6ZWRTZWxlY3Rpb24sIHNsYXRlRWRpdG9yKTtcbiAgICAgICAgc2xhdGVSYW5nZSAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHNsYXRlUmFuZ2UpLCBzbGF0ZUVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG8pID0+IG8udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHx8IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBub3JtYWxpemVkU2VsZWN0aW9uXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja1R5cGVOYW1lLCBlZGl0b3JBY3RvciwgcHJvcHNTZWxlY3Rpb24sIHNsYXRlRWRpdG9yXSksIHN5bmNSYW5nZURlY29yYXRpb25zID0gdXNlQ2FsbGJhY2soKG9wZXJhdGlvbikgPT4ge1xuICAgIGlmIChyYW5nZURlY29yYXRpb25zICYmIHJhbmdlRGVjb3JhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV3U2xhdGVSYW5nZXMgPSBbXTtcbiAgICAgIGlmIChyYW5nZURlY29yYXRpb25zLmZvckVhY2goKHJhbmdlRGVjb3JhdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZV8wID0gdG9TbGF0ZVJhbmdlKHJhbmdlRGVjb3JhdGlvbkl0ZW0uc2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShzbGF0ZVJhbmdlXzApKSB7XG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkICYmIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCh7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW0sXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UmFuZ2U7XG4gICAgICAgIGlmIChvcGVyYXRpb24gJiYgKG5ld1JhbmdlID0gbW92ZVJhbmdlQnlPcGVyYXRpb24oc2xhdGVSYW5nZV8wLCBvcGVyYXRpb24pLCBuZXdSYW5nZSAmJiBuZXdSYW5nZSAhPT0gc2xhdGVSYW5nZV8wIHx8IG5ld1JhbmdlID09PSBudWxsICYmIHNsYXRlUmFuZ2VfMCkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRWYWx1ZShwb3J0YWJsZVRleHRFZGl0b3IpLCBuZXdSYW5nZVNlbGVjdGlvbiA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIG5ld1JhbmdlLCBzY2hlbWFUeXBlcyk7XG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkICYmIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCh7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1JhbmdlU2VsZWN0aW9uLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdSYW5nZSAhPT0gbnVsbCAmJiBuZXdTbGF0ZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAuLi5uZXdSYW5nZSB8fCBzbGF0ZVJhbmdlXzAsXG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtXG4gICAgICAgIH0pO1xuICAgICAgfSksIG5ld1NsYXRlUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlKG5ld1NsYXRlUmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRSYW5nZURlY29yYXRpb25zU3RhdGUoKHJhbmdlRGVjb3JhdGlvblN0YXRlXzApID0+IHJhbmdlRGVjb3JhdGlvblN0YXRlXzAubGVuZ3RoID4gMCA/IFtdIDogcmFuZ2VEZWNvcmF0aW9uU3RhdGVfMCk7XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3IsIHJhbmdlRGVjb3JhdGlvbnMsIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9uUmVhZHkgPSBlZGl0b3JBY3Rvci5vbihcInJlYWR5XCIsICgpID0+IHtcbiAgICAgIHN5bmNSYW5nZURlY29yYXRpb25zKCksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgICB9KSwgb25JbnZhbGlkVmFsdWUgPSBlZGl0b3JBY3Rvci5vbihcImludmFsaWQgdmFsdWVcIiwgKCkgPT4ge1xuICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCEwKTtcbiAgICB9KSwgb25WYWx1ZUNoYW5nZWQgPSBlZGl0b3JBY3Rvci5vbihcInZhbHVlIGNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCExKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb25SZWFkeS51bnN1YnNjcmliZSgpLCBvbkludmFsaWRWYWx1ZS51bnN1YnNjcmliZSgpLCBvblZhbHVlQ2hhbmdlZC51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtlZGl0b3JBY3RvciwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcywgc3luY1JhbmdlRGVjb3JhdGlvbnNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3QgW3N5bmNlZFJhbmdlRGVjb3JhdGlvbnMsIHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdID0gdXNlU3RhdGUoITEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnMgfHwgKHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnMoITApLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucygpKTtcbiAgfSwgW3N5bmNSYW5nZURlY29yYXRpb25zLCBzeW5jZWRSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNFcXVhbChyYW5nZURlY29yYXRpb25zLCByYW5nZURlY29yYXRpb25zUmVmLmN1cnJlbnQpIHx8IHN5bmNSYW5nZURlY29yYXRpb25zKCksIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCA9IHJhbmdlRGVjb3JhdGlvbnM7XG4gIH0sIFtyYW5nZURlY29yYXRpb25zLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRlYXJkb3duID0gd2l0aFN5bmNSYW5nZURlY29yYXRpb25zKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBzeW5jUmFuZ2VEZWNvcmF0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB0ZWFyZG93bigpO1xuICB9LCBbZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pO1xuICBjb25zdCBoYW5kbGVDb3B5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgb25Db3B5ID8gb25Db3B5KGV2ZW50KSAhPT0gdm9pZCAwICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgOiBldmVudC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcImNvcHlcIixcbiAgICAgICAgZGF0YTogZXZlbnQubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSwgW29uQ29weSwgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZVBhc3RlID0gdXNlQ2FsbGJhY2soKGV2ZW50XzApID0+IHtcbiAgICBjb25zdCB2YWx1ZV8wID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFZhbHVlKHBvcnRhYmxlVGV4dEVkaXRvciksIHBhdGggPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlXzAsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbiwgc2NoZW1hVHlwZXMpPy5mb2N1cy5wYXRoIHx8IFtdLCBvblBhc3RlUmVzdWx0ID0gb25QYXN0ZT8uKHtcbiAgICAgIGV2ZW50OiBldmVudF8wLFxuICAgICAgdmFsdWU6IHZhbHVlXzAsXG4gICAgICBwYXRoLFxuICAgICAgc2NoZW1hVHlwZXNcbiAgICB9KTtcbiAgICBvblBhc3RlUmVzdWx0IHx8ICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyAoZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMCkgPT4ge1xuICAgICAgZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0XzApLCAhcmVzdWx0XzAgfHwgIXJlc3VsdF8wLmluc2VydCA/IChkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50XzAuY2xpcGJvYXJkRGF0YSkpIDogcmVzdWx0XzAuaW5zZXJ0ID8gc2xhdGVFZGl0b3IuaW5zZXJ0RnJhZ21lbnQodG9TbGF0ZVZhbHVlKHJlc3VsdF8wLmluc2VydCwge1xuICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgfSkpIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiAoY29uc29sZS5lcnJvcihlcnJvciksIGVycm9yKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJkb25lIGxvYWRpbmdcIlxuICAgICAgfSk7XG4gICAgfSkpIDogZXZlbnRfMC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcInBhc3RlXCIsXG4gICAgICAgIGRhdGE6IGV2ZW50XzAubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRfMFxuICAgIH0pLCBkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uUGFzdGUsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnRfMSkgPT4ge1xuICAgIGlmIChvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMSksICFldmVudF8xLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxlY3Rpb24gPT09IG51bGwgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBFZGl0b3Iuc3RhcnQoc2xhdGVFZGl0b3IsIFtdKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmb2N1c2VkXCIsXG4gICAgICAgIGV2ZW50OiBldmVudF8xXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIHNlbGVjdGlvbiA9PT0gbmV3U2VsZWN0aW9uICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvckFjdG9yLCBvbkZvY3VzLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50XzIpID0+IHtcbiAgICBvbkNsaWNrICYmIG9uQ2xpY2soZXZlbnRfMik7XG4gICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZUVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSA6IHZvaWQgMCwgZm9jdXNCbG9jayA9IGZvY3VzQmxvY2tQYXRoID8gTm9kZS5kZXNjZW5kYW50KHNsYXRlRWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCkgOiB2b2lkIDAsIFtfLCBsYXN0Tm9kZVBhdGhdID0gTm9kZS5sYXN0KHNsYXRlRWRpdG9yLCBbXSksIGxhc3RCbG9ja1BhdGggPSBsYXN0Tm9kZVBhdGguc2xpY2UoMCwgMSksIGxhc3ROb2RlRm9jdXNlZCA9IGZvY3VzQmxvY2tQYXRoID8gUGF0aC5lcXVhbHMobGFzdEJsb2NrUGF0aCwgZm9jdXNCbG9ja1BhdGgpIDogITEsIGxhc3RCbG9ja0lzVm9pZCA9IGZvY3VzQmxvY2sgPyAhc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgOiAhMTtcbiAgICBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKSAmJiBsYXN0Tm9kZUZvY3VzZWQgJiYgbGFzdEJsb2NrSXNWb2lkICYmIChUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgZGVjb3JhdG9yczogW11cbiAgICB9KSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICB9LCBbb25DbGljaywgc2xhdGVFZGl0b3JdKSwgaGFuZGxlT25CbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzMpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzMpLCBldmVudF8zLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJsdXJyZWRcIixcbiAgICAgIGV2ZW50OiBldmVudF8zXG4gICAgfSk7XG4gIH0sIFtlZGl0b3JBY3Rvciwgb25CbHVyXSksIGhhbmRsZU9uQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjaygoZXZlbnRfNCkgPT4ge1xuICAgIG9uQmVmb3JlSW5wdXQgJiYgb25CZWZvcmVJbnB1dChldmVudF80KTtcbiAgfSwgW29uQmVmb3JlSW5wdXRdKSwgdmFsaWRhdGVTZWxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzbGF0ZUVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChzbGF0ZUVkaXRvciksIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gcm9vdDtcbiAgICBpZiAocmVmLmN1cnJlbnQgIT09IGFjdGl2ZUVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KHNsYXRlRWRpdG9yKS5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0RPTVJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0RPTVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIChuZXdET01SYW5nZS5zdGFydE9mZnNldCAhPT0gZXhpc3RpbmdET01SYW5nZS5zdGFydE9mZnNldCB8fCBuZXdET01SYW5nZS5lbmRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2UuZW5kT2Zmc2V0KSAmJiAoZGVidWcoXCJET00gcmFuZ2Ugb3V0IG9mIHN5bmMsIHZhbGlkYXRpbmcgc2VsZWN0aW9uXCIpLCBkb21TZWxlY3Rpb24/LnJlbW92ZUFsbFJhbmdlcygpLCBkb21TZWxlY3Rpb24uYWRkUmFuZ2UobmV3RE9NUmFuZ2UpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRlYnVnKFwiQ291bGQgbm90IHJlc29sdmUgc2VsZWN0aW9uLCBzZWxlY3RpbmcgdG9wIGRvY3VtZW50XCIpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgWzAsIDBdKSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9XG4gIH0sIFtyZWYsIHNsYXRlRWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVkaXRhYmxlRWxlbWVudCkge1xuICAgICAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHZhbGlkYXRlU2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZWRpdGFibGVFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiAhMSxcbiAgICAgICAgYXR0cmlidXRlczogITEsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6ICExLFxuICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICBzdWJ0cmVlOiAhMFxuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ZhbGlkYXRlU2VsZWN0aW9uLCBlZGl0YWJsZUVsZW1lbnRdKTtcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKChldmVudF81KSA9PiB7XG4gICAgcHJvcHMub25LZXlEb3duICYmIHByb3BzLm9uS2V5RG93bihldmVudF81KSwgZXZlbnRfNS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBzbGF0ZUVkaXRvci5wdGVXaXRoSG90S2V5cyhldmVudF81KSwgZXZlbnRfNS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJrZXkuZG93blwiLFxuICAgICAgICBrZXlib2FyZEV2ZW50OiB7XG4gICAgICAgICAga2V5OiBldmVudF81LmtleSxcbiAgICAgICAgICBjb2RlOiBldmVudF81LmNvZGUsXG4gICAgICAgICAgYWx0S2V5OiBldmVudF81LmFsdEtleSxcbiAgICAgICAgICBjdHJsS2V5OiBldmVudF81LmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleTogZXZlbnRfNS5tZXRhS2V5LFxuICAgICAgICAgIHNoaWZ0S2V5OiBldmVudF81LnNoaWZ0S2V5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzVcbiAgICB9KTtcbiAgfSwgW3Byb3BzLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlS2V5VXAgPSB1c2VDYWxsYmFjaygoZXZlbnRfNikgPT4ge1xuICAgIHByb3BzLm9uS2V5VXAgJiYgcHJvcHMub25LZXlVcChldmVudF82KSwgZXZlbnRfNi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJrZXkudXBcIixcbiAgICAgICAga2V5Ym9hcmRFdmVudDoge1xuICAgICAgICAgIGtleTogZXZlbnRfNi5rZXksXG4gICAgICAgICAgY29kZTogZXZlbnRfNi5jb2RlLFxuICAgICAgICAgIGFsdEtleTogZXZlbnRfNi5hbHRLZXksXG4gICAgICAgICAgY3RybEtleTogZXZlbnRfNi5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXk6IGV2ZW50XzYubWV0YUtleSxcbiAgICAgICAgICBzaGlmdEtleTogZXZlbnRfNi5zaGlmdEtleVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF82XG4gICAgfSk7XG4gIH0sIFtwcm9wcywgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID09PSBudWxsID8gbm9vcCA6IChfZWRpdG9yLCBkb21SYW5nZSkgPT4ge1xuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhwb3J0YWJsZVRleHRFZGl0b3IsIGRvbVJhbmdlKTtcbiAgICAgIH07XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3IsIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3XSksIGRlY29yYXRlID0gdXNlQ2FsbGJhY2soKFssIHBhdGhfMF0pID0+IHtcbiAgICBpZiAoaXNFcXVhbFRvRW1wdHlFZGl0b3Ioc2xhdGVFZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSlcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBwbGFjZWhvbGRlcjogITBcbiAgICAgIH1dO1xuICAgIGlmIChwYXRoXzAubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlc3VsdF8xID0gcmFuZ2VEZWNvcmF0aW9uU3RhdGUuZmlsdGVyKChpdGVtKSA9PiBSYW5nZS5pc0NvbGxhcHNlZChpdGVtKSA/IHBhdGhfMC5sZW5ndGggIT09IDIgPyAhMSA6IFBhdGguZXF1YWxzKGl0ZW0uZm9jdXMucGF0aCwgcGF0aF8wKSAmJiBQYXRoLmVxdWFscyhpdGVtLmFuY2hvci5wYXRoLCBwYXRoXzApIDogUmFuZ2UuaW50ZXJzZWN0aW9uKGl0ZW0sIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBwYXRoXzAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IHBhdGhfMCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSkgfHwgUmFuZ2UuaW5jbHVkZXMoaXRlbSwgcGF0aF8wKSk7XG4gICAgcmV0dXJuIHJlc3VsdF8xLmxlbmd0aCA+IDAgPyByZXN1bHRfMSA6IFtdO1xuICB9LCBbc2xhdGVFZGl0b3IsIHNjaGVtYVR5cGVzLCByYW5nZURlY29yYXRpb25TdGF0ZV0pO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IpLCBzZXRFZGl0YWJsZUVsZW1lbnQocmVmLmN1cnJlbnQpO1xuICB9LCBbc2xhdGVFZGl0b3IsIHJlZl0pLCBwb3J0YWJsZVRleHRFZGl0b3IgPyBoYXNJbnZhbGlkVmFsdWUgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBFZGl0YWJsZSxcbiAgICB7XG4gICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICBhdXRvRm9jdXM6ICExLFxuICAgICAgY2xhc3NOYW1lOiByZXN0UHJvcHMuY2xhc3NOYW1lIHx8IFwicHQtZWRpdGFibGVcIixcbiAgICAgIGRlY29yYXRlLFxuICAgICAgb25CbHVyOiBoYW5kbGVPbkJsdXIsXG4gICAgICBvbkNvcHk6IGhhbmRsZUNvcHksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIG9uRE9NQmVmb3JlSW5wdXQ6IGhhbmRsZU9uQmVmb3JlSW5wdXQsXG4gICAgICBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLFxuICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHZvaWQgMCxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJMZWFmLFxuICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXc6IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblBvcnRhYmxlVGV4dEVkaXRhYmxlLmRpc3BsYXlOYW1lID0gXCJGb3J3YXJkUmVmKFBvcnRhYmxlVGV4dEVkaXRhYmxlKVwiO1xuY29uc3QgRWRpdG9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDI4KSwgZWRpdG9yID0gdXNlQ3JlYXRlRWRpdG9yKHByb3BzLmluaXRpYWxDb25maWcpLCBlZGl0b3JBY3RvciA9IGVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yID0gZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvcjtcbiAgbGV0IHQwLCB0MTtcbiAgJFswXSAhPT0gZWRpdG9yID8gKHQxID0gbmV3IFBvcnRhYmxlVGV4dEVkaXRvcih7XG4gICAgZWRpdG9yXG4gIH0pLCAkWzBdID0gZWRpdG9yLCAkWzFdID0gdDEpIDogdDEgPSAkWzFdLCB0MCA9IHQxO1xuICBjb25zdCBwb3J0YWJsZVRleHRFZGl0b3IgPSB0MDtcbiAgbGV0IHQyO1xuICAkWzJdICE9PSBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJCA/ICh0MiA9IChjaGFuZ2UpID0+IHtcbiAgICBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJC5uZXh0KGNoYW5nZSk7XG4gIH0sICRbMl0gPSBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJCwgJFszXSA9IHQyKSA6IHQyID0gJFszXTtcbiAgbGV0IHQzO1xuICAkWzRdICE9PSBlZGl0b3JBY3RvciB8fCAkWzVdICE9PSB0MiA/ICh0MyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUm91dGVFdmVudHNUb0NoYW5nZXMsIHsgZWRpdG9yQWN0b3IsIG9uQ2hhbmdlOiB0MiB9KSwgJFs0XSA9IGVkaXRvckFjdG9yLCAkWzVdID0gdDIsICRbNl0gPSB0MykgOiB0MyA9ICRbNl07XG4gIGxldCB0NDtcbiAgJFs3XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs4XSAhPT0gc2xhdGVFZGl0b3IuaW5zdGFuY2UgPyAodDQgPSAvKiBAX19QVVJFX18gKi8ganN4KFN5bmNocm9uaXplciwgeyBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3I6IHNsYXRlRWRpdG9yLmluc3RhbmNlIH0pLCAkWzddID0gZWRpdG9yQWN0b3IsICRbOF0gPSBzbGF0ZUVkaXRvci5pbnN0YW5jZSwgJFs5XSA9IHQ0KSA6IHQ0ID0gJFs5XTtcbiAgbGV0IHQ1O1xuICAkWzEwXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMV0gIT09IHByb3BzLmNoaWxkcmVuID8gKHQ1ID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlciwgeyBlZGl0b3JBY3RvciwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzEwXSA9IGVkaXRvckFjdG9yLCAkWzExXSA9IHByb3BzLmNoaWxkcmVuLCAkWzEyXSA9IHQ1KSA6IHQ1ID0gJFsxMl07XG4gIGxldCB0NjtcbiAgJFsxM10gIT09IHBvcnRhYmxlVGV4dEVkaXRvciB8fCAkWzE0XSAhPT0gdDUgPyAodDYgPSAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHBvcnRhYmxlVGV4dEVkaXRvciwgY2hpbGRyZW46IHQ1IH0pLCAkWzEzXSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFsxNF0gPSB0NSwgJFsxNV0gPSB0NikgOiB0NiA9ICRbMTVdO1xuICBsZXQgdDc7XG4gICRbMTZdICE9PSBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUgfHwgJFsxN10gIT09IHNsYXRlRWRpdG9yLmluc3RhbmNlIHx8ICRbMThdICE9PSB0NiA/ICh0NyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZSwgaW5pdGlhbFZhbHVlOiBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsIGNoaWxkcmVuOiB0NiB9KSwgJFsxNl0gPSBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsICRbMTddID0gc2xhdGVFZGl0b3IuaW5zdGFuY2UsICRbMThdID0gdDYsICRbMTldID0gdDcpIDogdDcgPSAkWzE5XTtcbiAgbGV0IHQ4O1xuICAkWzIwXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsyMV0gIT09IHQ3ID8gKHQ4ID0gLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGVkaXRvckFjdG9yLCBjaGlsZHJlbjogdDcgfSksICRbMjBdID0gZWRpdG9yQWN0b3IsICRbMjFdID0gdDcsICRbMjJdID0gdDgpIDogdDggPSAkWzIyXTtcbiAgbGV0IHQ5O1xuICByZXR1cm4gJFsyM10gIT09IGVkaXRvciB8fCAkWzI0XSAhPT0gdDMgfHwgJFsyNV0gIT09IHQ0IHx8ICRbMjZdICE9PSB0OCA/ICh0OSA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGVkaXRvciwgY2hpbGRyZW46IFtcbiAgICB0MyxcbiAgICB0NCxcbiAgICB0OFxuICBdIH0pLCAkWzIzXSA9IGVkaXRvciwgJFsyNF0gPSB0MywgJFsyNV0gPSB0NCwgJFsyNl0gPSB0OCwgJFsyN10gPSB0OSkgOiB0OSA9ICRbMjddLCB0OTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcigpIHtcbiAgY29uc3QgZWRpdG9yID0gUmVhY3QudXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRWRpdG9yIHNldC4gVXNlIEVkaXRvclByb3ZpZGVyIHRvIHNldCBvbmUuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufVxuZnVuY3Rpb24gRWRpdG9yRXZlbnRMaXN0ZW5lcihwcm9wcykge1xuICBjb25zdCAkID0gYyg0KSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IG9uID8gKHQwID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvci5vbihcIipcIiwgb24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3IsIG9uXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmV4cG9ydCB7XG4gIEVkaXRvckV2ZW50TGlzdGVuZXIsXG4gIEVkaXRvclByb3ZpZGVyLFxuICBQb3J0YWJsZVRleHRFZGl0YWJsZSxcbiAgUG9ydGFibGVUZXh0RWRpdG9yLFxuICBkZWZpbmVTY2hlbWEsXG4gIGVkaXRvck1hY2hpbmUsXG4gIGRlZmF1bHRLZXlHZW5lcmF0b3IgYXMga2V5R2VuZXJhdG9yLFxuICB1c2VFZGl0b3IsXG4gIHVzZUVkaXRvclNlbGVjdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3IsXG4gIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`\n    );\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(\n  Object.prototype.hasOwnProperty\n);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`\n        );\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsb0JBQW9CLFFBQVEsS0FBSyxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcGF0Y2hlcy9kaXN0L2luZGV4LmpzPzBhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNPYmplY3QuanNcIjtcbmltcG9ydCBpc1N0cmluZyBmcm9tIFwibG9kYXNoL2lzU3RyaW5nLmpzXCI7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gXCJsb2Rhc2gvZmluZEluZGV4LmpzXCI7XG5pbXBvcnQgY2xvbmUgZnJvbSBcImxvZGFzaC9jbG9uZS5qc1wiO1xuaW1wb3J0IG9taXQgZnJvbSBcImxvZGFzaC9vbWl0LmpzXCI7XG5pbXBvcnQgeyBhcHBseVBhdGNoZXMsIHBhcnNlUGF0Y2gsIG1ha2VQYXRjaGVzLCBzdHJpbmdpZnlQYXRjaGVzIH0gZnJvbSBcIkBzYW5pdHkvZGlmZi1tYXRjaC1wYXRjaFwiO1xuY29uc3QgQkVGT1JFID0gXCJiZWZvcmVcIiwgQUZURVIgPSBcImFmdGVyXCI7XG5mdW5jdGlvbiBpbnNlcnQkMShhcnJheSwgcG9zaXRpb24sIGluZGV4LCAuLi5hcmdzKSB7XG4gIGlmIChwb3NpdGlvbiAhPT0gQkVGT1JFICYmIHBvc2l0aW9uICE9PSBBRlRFUilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBwb3NpdGlvbiBcIiR7cG9zaXRpb259XCIsIG11c3QgYmUgZWl0aGVyICR7QkVGT1JFfSBvciAke0FGVEVSfWBcbiAgICApO1xuICBjb25zdCBpdGVtcyA9IGZsYXR0ZW4oLi4uYXJncyk7XG4gIGlmIChhcnJheS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGgsIGlkeCA9IE1hdGguYWJzKChsZW4gKyBpbmRleCkgJSBsZW4pICUgbGVuLCBub3JtYWxpemVkSWR4ID0gcG9zaXRpb24gPT09IFwiYWZ0ZXJcIiA/IGlkeCArIDEgOiBpZHgsIGNvcHkgPSBhcnJheS5zbGljZSgpO1xuICByZXR1cm4gY29weS5zcGxpY2Uobm9ybWFsaXplZElkeCwgMCwgLi4uZmxhdHRlbihpdGVtcykpLCBjb3B5O1xufVxuZnVuY3Rpb24gZmxhdHRlbiguLi52YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKHByZXYsIGl0ZW0pID0+IHByZXYuY29uY2F0KGl0ZW0pLCBbXSk7XG59XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwuYmluZChcbiAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuKTtcbmZ1bmN0aW9uIG1vdmUoYXJyLCBmcm9tLCB0bykge1xuICBjb25zdCBuZXh0VmFsdWUgPSBhcnIuc2xpY2UoKSwgdmFsID0gbmV4dFZhbHVlW2Zyb21dO1xuICByZXR1cm4gbmV4dFZhbHVlLnNwbGljZShmcm9tLCAxKSwgbmV4dFZhbHVlLnNwbGljZSh0bywgMCwgdmFsKSwgbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gZmluZFRhcmdldEluZGV4KGFycmF5LCBwYXRoU2VnbWVudCkge1xuICBpZiAodHlwZW9mIHBhdGhTZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHBhdGhTZWdtZW50O1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gITEgOiBpbmRleDtcbn1cbmZ1bmN0aW9uIGFwcGx5JDModmFsdWUsIHBhdGNoKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIGFycmF5IHRvIGEgbm9uLWFycmF5XCIpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBwYXRjaC52YWx1ZSA6IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBhcnJheSB0byBhIG5vbi1hcnJheVwiKTtcbiAgICAgIHJldHVybiBwYXRjaC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIGlmICghcGF0Y2gudmFsdWUgfHwgIWhhc093bihwYXRjaC52YWx1ZSwgXCJmcm9tXCIpIHx8ICFoYXNPd24ocGF0Y2gudmFsdWUsIFwidG9cIikpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgb2YgJ21vdmUnIHBhdGNoLiBFeHBlY3RlZCBhIHZhbHVlIHdpdGggXCJmcm9tXCIgYW5kIFwidG9cIiBpbmRleGVzLCBpbnN0ZWFkIGdvdDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgcGF0Y2gudmFsdWVcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBtb3ZlKG5leHRWYWx1ZSwgcGF0Y2gudmFsdWUuZnJvbSwgcGF0Y2gudmFsdWUudG8pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aCwgaW5kZXggPSBmaW5kVGFyZ2V0SW5kZXgodmFsdWUsIGhlYWQpO1xuICBpZiAoaW5kZXggPT09ICExKVxuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIGlmICh0YWlsLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9uLCBpdGVtcyB9ID0gcGF0Y2g7XG4gICAgICByZXR1cm4gaW5zZXJ0JDEodmFsdWUsIHBvc2l0aW9uLCBpbmRleCwgaXRlbXMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgYXJyYXkgaW5kZXggdG8gYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IFwiJHtpbmRleH1cImBcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBuZXh0VmFsdWUuc3BsaWNlKGluZGV4LCAxKSwgbmV4dFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFZhbHVlW2luZGV4XSA9IF9hcHBseShuZXh0VmFsdWVbaW5kZXhdLCB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogdGFpbFxuICB9KSwgbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gYXBwbHkkMih2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gY2xvbmUodmFsdWUpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKCFpc09iamVjdChwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gb2JqZWN0IHRvIGEgbm9uLW9iamVjdFwiKTtcbiAgICAgIHJldHVybiBwYXRjaC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9iamVjdCBvcGVyYXRpb246ICR7cGF0Y2gudHlwZX1gKTtcbiAgfVxuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBwYXRjaC5wYXRoO1xuICBpZiAodHlwZW9mIGhlYWQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGZpZWxkIG5hbWUgdG8gYmUgYSBzdHJpbmcsIGluc3RhZCBnb3Q6ICR7aGVhZH1gKTtcbiAgcmV0dXJuIHRhaWwubGVuZ3RoID09PSAwICYmIHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiA/IG9taXQobmV4dFZhbHVlLCBoZWFkKSA6IChuZXh0VmFsdWVbaGVhZF0gPSBfYXBwbHkobmV4dFZhbHVlW2hlYWRdLCB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogdGFpbFxuICB9KSwgbmV4dFZhbHVlKTtcbn1cbmNvbnN0IE9QRVJBVElPTlMkMSA9IHtcbiAgcmVwbGFjZShfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXQoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0SWZNaXNzaW5nKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gdm9pZCAwID8gbmV4dFZhbHVlIDogY3VycmVudFZhbHVlO1xuICB9LFxuICB1bnNldChfY3VycmVudFZhbHVlLCBfbmV4dFZhbHVlKSB7XG4gIH0sXG4gIGluYyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgKyBuZXh0VmFsdWU7XG4gIH0sXG4gIGRlYyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgLSBuZXh0VmFsdWU7XG4gIH1cbn0sIFNVUFBPUlRFRF9QQVRDSF9UWVBFUyQxID0gT2JqZWN0LmtleXMoT1BFUkFUSU9OUyQxKTtcbmZ1bmN0aW9uIGFwcGx5JDEodmFsdWUsIHBhdGNoKSB7XG4gIGlmICghU1VQUE9SVEVEX1BBVENIX1RZUEVTJDEuaW5jbHVkZXMocGF0Y2gudHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkIHBhdGNoIG9mIHVuc3VwcG9ydGVkIHR5cGU6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGF0Y2gudHlwZVxuICAgICAgKX1cIiBmb3IgcHJpbWl0aXZlcy4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IGFwcGx5IGRlZXAgb3BlcmF0aW9ucyBvbiBwcmltaXRpdmUgdmFsdWVzLiBSZWNlaXZlZCBwYXRjaCB3aXRoIHR5cGUgXCIke3BhdGNoLnR5cGV9XCIgYW5kIHBhdGggXCIke3BhdGNoLnBhdGgubWFwKChwYXRoKSA9PiBKU09OLnN0cmluZ2lmeShwYXRoKSkuam9pbihcIi5cIil9IHRoYXQgdGFyZ2V0ZWQgdGhlIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XCJgXG4gICAgKTtcbiAgcmV0dXJuIE9QRVJBVElPTlMkMVtwYXRjaC50eXBlXSh2YWx1ZSwgcGF0Y2gudmFsdWUpO1xufVxuY29uc3QgT1BFUkFUSU9OUyA9IHtcbiAgcmVwbGFjZShfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXQoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0SWZNaXNzaW5nKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gdm9pZCAwID8gbmV4dFZhbHVlIDogY3VycmVudFZhbHVlO1xuICB9LFxuICB1bnNldChfY3VycmVudFZhbHVlLCBfbmV4dFZhbHVlKSB7XG4gIH0sXG4gIGRpZmZNYXRjaFBhdGNoKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgY29uc3QgW3Jlc3VsdF0gPSBhcHBseVBhdGNoZXMocGFyc2VQYXRjaChuZXh0VmFsdWUpLCBjdXJyZW50VmFsdWUsIHtcbiAgICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogITBcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59LCBTVVBQT1JURURfUEFUQ0hfVFlQRVMgPSBPYmplY3Qua2V5cyhPUEVSQVRJT05TKTtcbmZ1bmN0aW9uIGFwcGx5KHZhbHVlLCBwYXRjaCkge1xuICBpZiAoIVNVUFBPUlRFRF9QQVRDSF9UWVBFUy5pbmNsdWRlcyhwYXRjaC50eXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgcGF0Y2ggb2YgdW5zdXBwb3J0ZWQgdHlwZTogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBwYXRjaC50eXBlXG4gICAgICApfVwiIGZvciBzdHJpbmcuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gc3RyaW5nIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIGNvbnN0IGZ1bmMgPSBPUEVSQVRJT05TW3BhdGNoLnR5cGVdO1xuICBpZiAoZnVuYylcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSwgcGF0Y2gudmFsdWUpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBhdGNoIHR5cGVcIik7XG59XG5mdW5jdGlvbiBhcHBseUFsbCh2YWx1ZSwgcGF0Y2hlcykge1xuICByZXR1cm4gcGF0Y2hlcy5yZWR1Y2UoX2FwcGx5LCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoKHZhbHVlLCBwYXRjaCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBhcHBseSQzKHZhbHVlLCBwYXRjaCkgOiBpc1N0cmluZyh2YWx1ZSkgPyBhcHBseSh2YWx1ZSwgcGF0Y2gpIDogaXNPYmplY3QodmFsdWUpID8gYXBwbHkkMih2YWx1ZSwgcGF0Y2gpIDogYXBwbHkkMSh2YWx1ZSwgcGF0Y2gpO1xufVxuZnVuY3Rpb24gX2FwcGx5KHZhbHVlLCBwYXRjaCkge1xuICByZXR1cm4gYXBwbHlQYXRjaCh2YWx1ZSwgcGF0Y2gpO1xufVxuZnVuY3Rpb24gc2V0SWZNaXNzaW5nKHZhbHVlLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldElmTWlzc2luZ1wiLFxuICAgIHBhdGgsXG4gICAgdmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZNYXRjaFBhdGNoKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlLCBwYXRoID0gW10pIHtcbiAgY29uc3QgcGF0Y2hlcyA9IG1ha2VQYXRjaGVzKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSwgcGF0Y2ggPSBzdHJpbmdpZnlQYXRjaGVzKHBhdGNoZXMpO1xuICByZXR1cm4geyB0eXBlOiBcImRpZmZNYXRjaFBhdGNoXCIsIHBhdGgsIHZhbHVlOiBwYXRjaCB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0KGl0ZW1zLCBwb3NpdGlvbiwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBwYXRoLFxuICAgIHBvc2l0aW9uLFxuICAgIGl0ZW1zXG4gIH07XG59XG5mdW5jdGlvbiBzZXQodmFsdWUsIHBhdGggPSBbXSkge1xuICByZXR1cm4geyB0eXBlOiBcInNldFwiLCBwYXRoLCB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gdW5zZXQocGF0aCA9IFtdKSB7XG4gIHJldHVybiB7IHR5cGU6IFwidW5zZXRcIiwgcGF0aCB9O1xufVxuZnVuY3Rpb24gcHJlZml4UGF0aChwYXRjaCwgc2VnbWVudCkge1xuICByZXR1cm4ge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IFtzZWdtZW50LCAuLi5wYXRjaC5wYXRoXVxuICB9O1xufVxuZXhwb3J0IHtcbiAgYXBwbHlBbGwsXG4gIGRpZmZNYXRjaFBhdGNoLFxuICBpbnNlcnQsXG4gIHByZWZpeFBhdGgsXG4gIHNldCxcbiAgc2V0SWZNaXNzaW5nLFxuICB1bnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value?.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsa0NBQWtDLHFEQUFxRDtBQUNyVCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4Qiw2QkFBNkIsZUFBZTtBQUNwSTtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGUvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzPzQwYTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX2V4Y2x1ZGVkID0gW1wiYmxvY2tcIiwgXCJsaXN0XCIsIFwibGlzdEl0ZW1cIiwgXCJtYXJrc1wiLCBcInR5cGVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wibGlzdEl0ZW1cIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJfa2V5XCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IHMubGVuZ3RoOyByKyspIG8gPSBzW3JdLCB0LmluY2x1ZGVzKG8pIHx8IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTsgfSByZXR1cm4gaTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKGUuaW5jbHVkZXMobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgbmVzdExpc3RzLCBMSVNUX05FU1RfTU9ERV9IVE1MLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdG9QbGFpblRleHQgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBkZWZhdWx0TGlzdHMgPSB7XG4gICAgbnVtYmVyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJvbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJ1bGxldDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBEZWZhdWx0TGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgbGluayA9ICh7XG4gICAgY2hpbGRyZW4sXG4gICAgdmFsdWVcbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYVwiLCB7XG4gICAgaHJlZjogdmFsdWU/LmhyZWYsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIHVuZGVybGluZVN0eWxlID0ge1xuICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gIH0sXG4gIGRlZmF1bHRNYXJrcyA9IHtcbiAgICBlbTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZW1cIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBzdHJvbmc6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInN0cm9uZ1wiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGNvZGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImNvZGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICB1bmRlcmxpbmU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IHVuZGVybGluZVN0eWxlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBcInN0cmlrZS10aHJvdWdoXCI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImRlbFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGxpbmtcbiAgfSxcbiAgZ2V0VGVtcGxhdGUgPSAodHlwZSwgcHJvcCkgPT4gYFtAcG9ydGFibGV0ZXh0L3JlYWN0XSBVbmtub3duICR7dHlwZX0sIHNwZWNpZnkgYSBjb21wb25lbnQgZm9yIGl0IGluIHRoZSBcXGBjb21wb25lbnRzLiR7cHJvcH1cXGAgcHJvcGAsXG4gIHVua25vd25UeXBlV2FybmluZyA9IHR5cGVOYW1lID0+IGdldFRlbXBsYXRlKGBibG9jayB0eXBlIFwiJHt0eXBlTmFtZX1cImAsIFwidHlwZXNcIiksXG4gIHVua25vd25NYXJrV2FybmluZyA9IG1hcmtUeXBlID0+IGdldFRlbXBsYXRlKGBtYXJrIHR5cGUgXCIke21hcmtUeXBlfVwiYCwgXCJtYXJrc1wiKSxcbiAgdW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nID0gYmxvY2tTdHlsZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLFxuICB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0XCIpLFxuICB1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3QgaXRlbSBzdHlsZSBcIiR7bGlzdFN0eWxlfVwiYCwgXCJsaXN0SXRlbVwiKTtcbmZ1bmN0aW9uIHByaW50V2FybmluZyhtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmNvbnN0IGhpZGRlbiA9IHtcbiAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICB9LFxuICBEZWZhdWx0VW5rbm93blR5cGUgPSAoe1xuICAgIHZhbHVlLFxuICAgIGlzSW5saW5lXG4gIH0pID0+IHtcbiAgICBjb25zdCB3YXJuaW5nID0gdW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKTtcbiAgICByZXR1cm4gaXNJbmxpbmUgPyAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pIDogLyogQF9fUFVSRV9fICovanN4KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiBoaWRkZW4sXG4gICAgICBjaGlsZHJlbjogd2FybmluZ1xuICAgIH0pO1xuICB9LFxuICBEZWZhdWx0VW5rbm93bk1hcmsgPSAoe1xuICAgIG1hcmtUeXBlLFxuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogYHVua25vd25fX3B0X19tYXJrX18ke21hcmtUeXBlfWAsXG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duQmxvY2tTdHlsZSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdCA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkxpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRIYXJkQnJlYWsgPSAoKSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJiclwiLCB7fSksXG4gIGRlZmF1bHRCbG9ja1N0eWxlcyA9IHtcbiAgICBub3JtYWw6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBibG9ja3F1b3RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJibG9ja3F1b3RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDE6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgxXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgyXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDM6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImgzXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg0XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg1XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgaDY6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImg2XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSxcbiAgZGVmYXVsdENvbXBvbmVudHMgPSB7XG4gICAgdHlwZXM6IHt9LFxuICAgIGJsb2NrOiBkZWZhdWx0QmxvY2tTdHlsZXMsXG4gICAgbWFya3M6IGRlZmF1bHRNYXJrcyxcbiAgICBsaXN0OiBkZWZhdWx0TGlzdHMsXG4gICAgbGlzdEl0ZW06IERlZmF1bHRMaXN0SXRlbSxcbiAgICBoYXJkQnJlYWs6IERlZmF1bHRIYXJkQnJlYWssXG4gICAgdW5rbm93blR5cGU6IERlZmF1bHRVbmtub3duVHlwZSxcbiAgICB1bmtub3duTWFyazogRGVmYXVsdFVua25vd25NYXJrLFxuICAgIHVua25vd25MaXN0OiBEZWZhdWx0VW5rbm93bkxpc3QsXG4gICAgdW5rbm93bkxpc3RJdGVtOiBEZWZhdWx0VW5rbm93bkxpc3RJdGVtLFxuICAgIHVua25vd25CbG9ja1N0eWxlOiBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGVcbiAgfTtcbmZ1bmN0aW9uIG1lcmdlQ29tcG9uZW50cyhwYXJlbnQsIG92ZXJyaWRlcykge1xuICBjb25zdCB7XG4gICAgICBibG9jayxcbiAgICAgIGxpc3QsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIG1hcmtzLFxuICAgICAgdHlwZXNcbiAgICB9ID0gb3ZlcnJpZGVzLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3ZlcnJpZGVzLCBfZXhjbHVkZWQpO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnQpLCB7fSwge1xuICAgIGJsb2NrOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJibG9ja1wiKSxcbiAgICBsaXN0OiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0XCIpLFxuICAgIGxpc3RJdGVtOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJsaXN0SXRlbVwiKSxcbiAgICBtYXJrczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibWFya3NcIiksXG4gICAgdHlwZXM6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcInR5cGVzXCIpXG4gIH0sIHJlc3QpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIGtleSkge1xuICBjb25zdCBvdmVycmlkZSA9IG92ZXJyaWRlc1trZXldLFxuICAgIHBhcmVudFZhbCA9IHBhcmVudFtrZXldO1xuICByZXR1cm4gdHlwZW9mIG92ZXJyaWRlID09IFwiZnVuY3Rpb25cIiB8fCBvdmVycmlkZSAmJiB0eXBlb2YgcGFyZW50VmFsID09IFwiZnVuY3Rpb25cIiA/IG92ZXJyaWRlIDogb3ZlcnJpZGUgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFZhbCksIG92ZXJyaWRlKSA6IHBhcmVudFZhbDtcbn1cbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dCh7XG4gIHZhbHVlOiBpbnB1dCxcbiAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICBsaXN0TmVzdGluZ01vZGUsXG4gIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbn0pIHtcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3AsXG4gICAgYmxvY2tzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF0sXG4gICAgbmVzdGVkID0gbmVzdExpc3RzKGJsb2NrcywgbGlzdE5lc3RpbmdNb2RlIHx8IExJU1RfTkVTVF9NT0RFX0hUTUwpLFxuICAgIGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IGNvbXBvbmVudE92ZXJyaWRlcyA/IG1lcmdlQ29tcG9uZW50cyhkZWZhdWx0Q29tcG9uZW50cywgY29tcG9uZW50T3ZlcnJpZGVzKSA6IGRlZmF1bHRDb21wb25lbnRzLCBbY29tcG9uZW50T3ZlcnJpZGVzXSksXG4gICAgcmVuZGVyTm9kZSA9IHVzZU1lbW8oKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLCBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF0pLFxuICAgIHJlbmRlcmVkID0gbmVzdGVkLm1hcCgobm9kZSwgaW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICB9KTtcbn1cbmNvbnN0IGdldE5vZGVSZW5kZXJlciA9IChjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSA9PiB7XG4gIGZ1bmN0aW9uIHJlbmRlck5vZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lXG4gICAgICB9ID0gb3B0aW9ucyxcbiAgICAgIGtleSA9IG5vZGUuX2tleSB8fCBgbm9kZS0ke2luZGV4fWA7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkgPyByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpID8gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpID8gcmVuZGVyU3Bhbihub2RlLCBpbmRleCwga2V5KSA6IGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkgPyByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpID8gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkgPyByZW5kZXJUZXh0KG5vZGUsIGtleSkgOiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuX3R5cGUgaW4gY29tcG9uZW50cy50eXBlcztcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSksXG4gICAgICByZW5kZXJlciA9IGNvbXBvbmVudHMubGlzdEl0ZW0sXG4gICAgICBMaSA9ICh0eXBlb2YgcmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gcmVuZGVyZXIgOiByZW5kZXJlcltub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW07XG4gICAgaWYgKExpID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgdHlwZTogc3R5bGUsXG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RJdGVtU3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0gPSBub2RlLFxuICAgICAgICBibG9ja05vZGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG4gICAgICBjaGlsZHJlbiA9IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBibG9ja05vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpLCB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLl9rZXkgPyBjaGlsZCA6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY2hpbGQpLCB7fSwge1xuICAgICAgICAgIF9rZXk6IGBsaS0ke2luZGV4fS0ke2NoaWxkSW5kZXh9YFxuICAgICAgICB9KSxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpLFxuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50cy5saXN0LFxuICAgICAgTGlzdCA9ICh0eXBlb2YgY29tcG9uZW50ID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFtub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdDtcbiAgICBpZiAoTGlzdCA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0U3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICBub2RlVHlwZTogXCJsaXN0U3R5bGVcIixcbiAgICAgICAgdHlwZTogc3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KExpc3QsIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclNwYW4obm9kZSwgX2luZGV4LCBrZXkpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWYsXG4gICAgICAgIG1hcmtUeXBlLFxuICAgICAgICBtYXJrS2V5XG4gICAgICB9ID0gbm9kZSxcbiAgICAgIFNwYW4gPSBjb21wb25lbnRzLm1hcmtzW21hcmtUeXBlXSB8fCBjb21wb25lbnRzLnVua25vd25NYXJrLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSkpO1xuICAgIHJldHVybiBTcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bk1hcmtXYXJuaW5nKG1hcmtUeXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwibWFya1wiLFxuICAgICAgdHlwZTogbWFya1R5cGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KFNwYW4sIHtcbiAgICAgIHRleHQ6IHNwYW5Ub1BsYWluVGV4dChub2RlKSxcbiAgICAgIHZhbHVlOiBtYXJrRGVmLFxuICAgICAgbWFya1R5cGUsXG4gICAgICBtYXJrS2V5LFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IF9zZXJpYWxpemVCbG9jayA9IHNlcmlhbGl6ZUJsb2NrKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgX2tleVxuICAgICAgfSA9IF9zZXJpYWxpemVCbG9jayxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9zZXJpYWxpemVCbG9jaywgX2V4Y2x1ZGVkMyksXG4gICAgICBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIixcbiAgICAgIEJsb2NrID0gKHR5cGVvZiBjb21wb25lbnRzLmJsb2NrID09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXSkgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICByZXR1cm4gQmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICB0eXBlOiBzdHlsZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goQmxvY2ssIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgdmFsdWU6IHByb3BzLm5vZGUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVGV4dChub2RlLCBrZXkpIHtcbiAgICBpZiAobm9kZS50ZXh0ID09PSBgXG5gKSB7XG4gICAgICBjb25zdCBIYXJkQnJlYWsgPSBjb21wb25lbnRzLmhhcmRCcmVhaztcbiAgICAgIHJldHVybiBIYXJkQnJlYWsgPyAvKiBAX19QVVJFX18gKi9qc3goSGFyZEJyZWFrLCB7fSwga2V5KSA6IGBcbmA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9O1xuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKG5vZGUuX3R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJibG9ja1wiLFxuICAgICAgdHlwZTogbm9kZS5fdHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IFVua25vd25UeXBlID0gY29tcG9uZW50cy51bmtub3duVHlwZTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFVua25vd25UeXBlLCBfb2JqZWN0U3ByZWFkKHt9LCBub2RlT3B0aW9ucyksIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICAgIGlzSW5saW5lLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSxcbiAgICAgIE5vZGUgPSBjb21wb25lbnRzLnR5cGVzW25vZGUuX3R5cGVdO1xuICAgIHJldHVybiBOb2RlID8gLyogQF9fUFVSRV9fICovanN4KE5vZGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGU7XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplQmxvY2sob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9ID0gb3B0aW9ucyxcbiAgICBjaGlsZHJlbiA9IGJ1aWxkTWFya3NUcmVlKG5vZGUpLm1hcCgoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZTogY2hpbGQsXG4gICAgICBpc0lubGluZTogITAsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiB7XG4gICAgX2tleTogbm9kZS5fa2V5IHx8IGBibG9jay0ke2luZGV4fWAsXG4gICAgY2hpbGRyZW4sXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnQgeyBQb3J0YWJsZVRleHQsIGRlZmF1bHRDb21wb25lbnRzLCBtZXJnZUNvbXBvbmVudHMsIHRvUGxhaW5UZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4QiwwQ0FBMEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsb0NBQW9DLHVFQUF1RTtBQUN6UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQSwySUFBMkk7QUFDM0k7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE1BQU0sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDaVM7QUFDalMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvdG9vbGtpdC9kaXN0L2luZGV4LmpzPzVmNjQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID4gXCJ1XCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KG1hcmsgPT4gdHlwZW9mIG1hcmsgPT0gXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBibG9jayBkb2Vzbid0IF9oYXZlXyB0byBiZSBuYW1lZCAnYmxvY2snIC0gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgLy8gYWxsb3dlZCBjaGlsZCB0eXBlcyBhbmQgbWFya3MsIG9uZSBtaWdodCBuYW1lIHRoZW0gZGlmZmVyZW50bHlcbiAgICB0eXBlb2Ygbm9kZS5fdHlwZSA9PSBcInN0cmluZ1wiICYmXG4gICAgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIChcbiAgICAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJlxuICAgIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoZGVmID0+IHR5cGVvZiBkZWYuX2tleSA9PSBcInN0cmluZ1wiKSkgJiZcbiAgICAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiZcbiAgICAvLyBBbGwgY2hpbGRyZW4gYXJlIG9iamVjdHMgd2l0aCBgX3R5cGVgICh1c3VhbGx5IHNwYW5zLCBidXQgY2FuIGNvbnRhaW4gb3RoZXIgc3R1ZmYpXG4gICAgbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spICYmIFwibGlzdEl0ZW1cIiBpbiBibG9jayAmJiB0eXBlb2YgYmxvY2subGlzdEl0ZW0gPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGJsb2NrLmxldmVsID4gXCJ1XCIgfHwgdHlwZW9mIGJsb2NrLmxldmVsID09IFwibnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChibG9jaykge1xuICByZXR1cm4gYmxvY2suX3R5cGUgPT09IFwiQGxpc3RcIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oc3Bhbikge1xuICByZXR1cm4gc3Bhbi5fdHlwZSA9PT0gXCJAc3BhblwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJAdGV4dFwiO1xufVxuY29uc3Qga25vd25EZWNvcmF0b3JzID0gW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJjb2RlXCIsIFwidW5kZXJsaW5lXCIsIFwic3RyaWtlLXRocm91Z2hcIl07XG5mdW5jdGlvbiBzb3J0TWFya3NCeU9jY3VyZW5jZXMoc3BhbiwgaW5kZXgsIGJsb2NrQ2hpbGRyZW4pIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgfHwgIXNwYW4ubWFya3MpIHJldHVybiBbXTtcbiAgaWYgKCFzcGFuLm1hcmtzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3Muc2xpY2UoKSxcbiAgICBvY2N1cmVuY2VzID0ge307XG4gIHJldHVybiBtYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgIG9jY3VyZW5jZXNbbWFya10gPSAxO1xuICAgIGZvciAobGV0IHNpYmxpbmdJbmRleCA9IGluZGV4ICsgMTsgc2libGluZ0luZGV4IDwgYmxvY2tDaGlsZHJlbi5sZW5ndGg7IHNpYmxpbmdJbmRleCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gYmxvY2tDaGlsZHJlbltzaWJsaW5nSW5kZXhdO1xuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNQb3J0YWJsZVRleHRTcGFuKHNpYmxpbmcpICYmIEFycmF5LmlzQXJyYXkoc2libGluZy5tYXJrcykgJiYgc2libGluZy5tYXJrcy5pbmRleE9mKG1hcmspICE9PSAtMSkgb2NjdXJlbmNlc1ttYXJrXSsrO2Vsc2UgYnJlYWs7XG4gICAgfVxuICB9KSwgbWFya3Muc29ydCgobWFya0EsIG1hcmtCKSA9PiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSk7XG59XG5mdW5jdGlvbiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSB7XG4gIGNvbnN0IGFPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQV0sXG4gICAgYk9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtCXTtcbiAgaWYgKGFPY2N1cmVuY2VzICE9PSBiT2NjdXJlbmNlcykgcmV0dXJuIGJPY2N1cmVuY2VzIC0gYU9jY3VyZW5jZXM7XG4gIGNvbnN0IGFLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtBKSxcbiAgICBiS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQik7XG4gIHJldHVybiBhS25vd25Qb3MgIT09IGJLbm93blBvcyA/IGFLbm93blBvcyAtIGJLbm93blBvcyA6IG1hcmtBLmxvY2FsZUNvbXBhcmUobWFya0IpO1xufVxuZnVuY3Rpb24gYnVpbGRNYXJrc1RyZWUoYmxvY2spIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbWFya0RlZnMgPSBbXVxuICB9ID0gYmxvY2s7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBzb3J0ZWRNYXJrcyA9IGNoaWxkcmVuLm1hcChzb3J0TWFya3NCeU9jY3VyZW5jZXMpLFxuICAgIHJvb3ROb2RlID0ge1xuICAgICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG1hcmtUeXBlOiBcIjx1bmtub3duPlwiXG4gICAgfTtcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzcGFuID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCFzcGFuKSBjb250aW51ZTtcbiAgICBjb25zdCBtYXJrc05lZWRlZCA9IHNvcnRlZE1hcmtzW2ldIHx8IFtdO1xuICAgIGxldCBwb3MgPSAxO1xuICAgIGlmIChub2RlU3RhY2subGVuZ3RoID4gMSkgZm9yIChwb3M7IHBvcyA8IG5vZGVTdGFjay5sZW5ndGg7IHBvcysrKSB7XG4gICAgICBjb25zdCBtYXJrID0gKChfYSA9IG5vZGVTdGFja1twb3NdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya0tleSkgfHwgXCJcIixcbiAgICAgICAgaW5kZXggPSBtYXJrc05lZWRlZC5pbmRleE9mKG1hcmspO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICBtYXJrc05lZWRlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBub2RlU3RhY2sgPSBub2RlU3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBtYXJrS2V5IG9mIG1hcmtzTmVlZGVkKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWYgPSBtYXJrRGVmcy5maW5kKGRlZiA9PiBkZWYuX2tleSA9PT0gbWFya0tleSksXG4gICAgICAgICAgbWFya1R5cGUgPSBtYXJrRGVmID8gbWFya0RlZi5fdHlwZSA6IG1hcmtLZXksXG4gICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXksXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgICAgbWFya1R5cGUsXG4gICAgICAgICAgICBtYXJrS2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKSwgbm9kZVN0YWNrLnB1c2gobm9kZSksIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGFuLnRleHQuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSBsaW5lcy5sZW5ndGg7IGxpbmUtLSA+IDE7KSBsaW5lcy5zcGxpY2UobGluZSwgMCwgYFxuYCk7XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KGxpbmVzLm1hcCh0ZXh0ID0+ICh7XG4gICAgICAgICAgX3R5cGU6IFwiQHRleHRcIixcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGVsc2UgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykpIHtcbiAgICAgICAgdHJlZS5wdXNoKGJsb2NrKSwgY3VycmVudExpc3QgPSB2b2lkIDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGlzdCkge1xuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA+IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdExpc3RJdGVtID0gY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBuZXdMYXN0Q2hpbGQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxhc3RMaXN0SXRlbSksIHt9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXdMYXN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKG5ld0xpc3QpO1xuICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwgYmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5saXN0SXRlbSAhPT0gY3VycmVudExpc3QubGlzdEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7XG4gICAgICAgICAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGlzdEl0ZW0gPT09IGJsb2NrLmxpc3RJdGVtKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBzdGF0ZSBlbmNvdW50ZXJlZCBmb3IgYmxvY2tcIiwgYmxvY2spLCB0cmVlLnB1c2goYmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGxpc3QpIHtcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGxpc3RGcm9tQmxvY2soYmxvY2ssIGluZGV4LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IFwiQGxpc3RcIixcbiAgICBfa2V5OiBgJHtibG9jay5fa2V5IHx8IGAke2luZGV4fWB9LXBhcmVudGAsXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMSxcbiAgICBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIsXG4gICAgZmlsdGVyT25UeXBlID0gdHlwZW9mIG1hdGNoaW5nLmxpc3RJdGVtID09IFwic3RyaW5nXCI7XG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSByZXR1cm4gcm9vdE5vZGU7XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlLmNoaWxkcmVuW3Jvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUoY3VycmVudCkgPyB0ZXh0ICs9IGN1cnJlbnQudGV4dCA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkgJiYgKHRleHQgKz0gc3BhblRvUGxhaW5UZXh0KGN1cnJlbnQpKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBsZWFkaW5nU3BhY2UgPSAvXlxccy8sXG4gIHRyYWlsaW5nU3BhY2UgPSAvXFxzJC87XG5mdW5jdGlvbiB0b1BsYWluVGV4dChibG9jaykge1xuICBjb25zdCBibG9ja3MgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gYmxvY2tzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BvcnRhYmxlVGV4dEJsb2NrKGN1cnJlbnQpKSByZXR1cm47XG4gICAgbGV0IHBhZCA9ICExO1xuICAgIGN1cnJlbnQuY2hpbGRyZW4uZm9yRWFjaChzcGFuID0+IHtcbiAgICAgIGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSA/ICh0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCIsIHRleHQgKz0gc3Bhbi50ZXh0LCBwYWQgPSAhMSkgOiBwYWQgPSAhMDtcbiAgICB9KSwgaW5kZXggIT09IGJsb2Nrcy5sZW5ndGggLSAxICYmICh0ZXh0ICs9IGBcblxuYCk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiLFxuICBMSVNUX05FU1RfTU9ERV9ESVJFQ1QgPSBcImRpcmVjdFwiO1xuZXhwb3J0IHsgTElTVF9ORVNUX01PREVfRElSRUNULCBMSVNUX05FU1RfTU9ERV9IVE1MLCBidWlsZE1hcmtzVHJlZSwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBuZXN0TGlzdHMsIHNvcnRNYXJrc0J5T2NjdXJlbmNlcywgc3BhblRvUGxhaW5UZXh0LCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;